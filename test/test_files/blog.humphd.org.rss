<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[seneca - Bread & Circuits]]></title><description><![CDATA[The blog of David Humphrey]]></description><link>https://blog.humphd.org/</link><image><url>http://blog.humphd.org/favicon.png</url><title>seneca - Bread &amp; Circuits</title><link>https://blog.humphd.org/</link></image><generator>Ghost 2.15</generator><lastBuildDate>Mon, 20 Jan 2020 17:23:21 GMT</lastBuildDate><atom:link href="https://blog.humphd.org/tag/seneca/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Teaching Open Source, Fall 2019]]></title><description><![CDATA[<p>Today I've completed another semester of teaching open source, and wanted to write something about what happened, experiments I tried, and what I learned.</p><p>This fall I taught the first of our two open source classes, cross-listed in our degree and diploma programs as OSD600 and DPS909.  This course focuses</p>]]></description><link>https://blog.humphd.org/open-source-fall-2019/</link><guid isPermaLink="false">5df7bbd924511e03496b4734</guid><category><![CDATA[seneca]]></category><category><![CDATA[mozilla]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Mon, 16 Dec 2019 20:37:14 GMT</pubDate><content:encoded><![CDATA[<p>Today I've completed another semester of teaching open source, and wanted to write something about what happened, experiments I tried, and what I learned.</p><p>This fall I taught the first of our two open source classes, cross-listed in our degree and diploma programs as OSD600 and DPS909.  This course focuses on getting students engaged in open source development practices, and has them participate in half-a-dozen different open source projects, making an average of 10 pull requests over 14 weeks.  The emphasis is on learning git, GitHub, and how to cope in large open source projects, code bases, and communities. </p><p>This is the 15th year I've taught it, and I had one of my largest groups: 60 students spread across two sections.  I don't think I could cope with more than this, especially when I'm also teaching other courses at the same time.</p><h2 id="running-the-numbers">Running the Numbers</h2><p>I ran an analysis this morning, and here's some data on the work the students did:</p><ul><li><strong>665 Pull Requests</strong> (2,048 commits) to <strong>266 GitHub Repositories</strong></li><li>425 have already been <strong>merged (63%)</strong></li><li><strong>+85,873/-25,510</strong> lines changed in <strong>2,049 files</strong></li></ul><p>They worked on all kinds of things, big and small.  I kept a list of projects and organizations I knew while I was marking this week, and some of what I saw included:</p><ul><li>Lots from <strong>Mozilla</strong>, including: <a href="https://github.com/mozilla/addons-code-manager">mozilla/addons-code-manager</a>, <a href="https://github.com/mozilla/hubs/">mozilla/hubs</a>, <a href="https://github.com/mozilla/web-ext">mozilla/web-ext</a>, <a href="https://github.com/mozilla/foundation.mozilla.org">mozilla/foundation.mozilla.org</a>, <a href="https://github.com/mozilla-lockwise/lockwise-android">mozilla-lockwise/lockwise-android</a>, <a href="https://github.com/firefox-devtools/profiler">firefox-devtools/profiler</a></li><li>All kinds of things with <strong>Micosoft</strong> (more than any other org), including <a href="https://github.com/microsoft/vscode">microsoft/vscode</a>, <a href="https://github.com/microsoft/vscode-vsce">microsoft/vscode-vsce</a>, <a href="https://github.com/microsoft/STL">microsoft/STL</a>, <a href="https://github.com/microsoft/accessibility-insights-web">microsoft/accessibility-insights-web</a>, <a href="https://github.com/microsoft/calculator">microsoft/calculator</a>, <a href="https://github.com/microsoft/react-native-windows">microsoft/react-native-windows</a>, <a href="https://github.com/microsoft/fast-dna">microsoft/fast-dna</a>, <a href="https://github.com/xtermjs/xterm.js">xtermjs/xterm.js</a>, <a href="https://github.com/dotnet/winforms">dotnet/winforms</a></li><li><strong>Google</strong>: <a href="https://github.com/google/blockly">google/blockly</a>, <a href="https://github.com/google/coding-with-chrome">google/coding-with-chrome</a>, <a href="https://github.com/angular/angular">angular/angular</a></li><li><a href="https://github.com/ruby/www.ruby-lang.org">ruby/www.ruby-lang.org</a></li><li>Lots of localization with <strong>GatsbyJS</strong>: <a href="https://github.com/gatsbyjs/gatsby-vi">gatsbyjs/gatsby-vi</a>, <a href="https://github.com/gatsbyjs/gatsby-es">gatsbyjs/gatsby-es</a>, <a href="https://github.com/gatsbyjs/gatsby-ru">gatsbyjs/gatsby-ru</a></li><li><a href="https://github.com/moment/moment">moment/moment</a></li><li><a href="https://github.com/bitcoin/bitcoin">bitcoin/bitcoin</a></li><li><a href="https://github.com/elastic/kibana">elastic/kibana</a>, <a href="https://github.com/elastic/eui">elastic/eui</a></li><li><a href="https://github.com/facebook/create-react-app">facebook/create-react-app</a></li><li>Quite a few PRs to <strong>WordPress</strong>: <a href="https://github.com/wordpress-mobile/WordPress-iOS">wordpress-mobile/WordPress-iOS</a>, <a href="https://github.com/WordPress/gutenberg">WordPress/gutenberg</a></li><li><a href="https://github.com/nodejs/node">nodejs/node</a></li><li>A few to projects run by <strong>Nasa</strong>: <a href="https://github.com/nasa-gibs/worldview">nasa-gibs/worldview</a>, <a href="https://github.com/nasa/PSP">nasa/PSP</a></li><li><a href="https://github.com/home-assistant/home-assistant">home-assistant/home-assistant</a>, <a href="https://github.com/home-assistant/home-assistant-polymer">home-assistant/home-assistant-polymer</a></li><li><a href="https://github.com/zeit/hyper">zeit/hyper</a></li><li><a href="https://github.com/uber/baseweb">uber/baseweb</a></li></ul><p>Whatever they worked on, I encouraged the students to <em>progress</em> as they went, which I define as building on previous experience, and trying to do a bit <em>more</em> with each PR.  "More" could mean working on a larger project, moving from a smaller "good first issue" type fix to something larger, or fixing multiple small bugs where previously they only did one.  I'm interested in seeing growth.</p><h2 id="personal-experiences">Personal Experiences</h2><p>The students find their way into lots of projects I've never heard of, or wouldn't know to recommend.  By following their own passions and interests, fascinating things happen.</p><p>For example, one student fixed a bunch of things in <a href="https://github.com/knitcodemonkey/hexagon-quilt-map">knitcodemonkey/hexagon-quilt-map</a>, a <a href="https://knitcodemonkey.github.io/hexagon-quilt-map/">web app for creating quilt patterns</a>.  Another got deeply involved in the community of a service mesh project called <a href="https://github.com/layer5io">Layer5</a>. A few women in one of my sections got excited about <a href="https://github.com/microsoft/STL">Microsoft’s recently open sourced C++ Standard Library</a>.  If you'd ask me which projects students would work on, I wouldn't have guessed the STL; and yet it turned out to be a really great fit.  One of the students wrote it about it in her blog:</p><blockquote>Why do I always pick issues from Microsoft/STL?  It's because of the way they explain each bug. It is very well defined, there is a description of how to reproduce the bug and files that are crashing or need updates. Another reason is that there are only 20 contributors to this project and I'm 8th by the amount of contributing (even though it is only 31 line of code). The contributors are very quick to respond if I need any help or to review my PR.</blockquote><p>Working on projects like those I've listed above isn't easy, but has its own set of rewards, not least that it adds useful experience to the students' resume.  As one student put it in his blog:</p><blockquote>I have officially contributed to <em>Facebook, Angular, Microsoft, Mozilla and many more projects </em>(feels kinda nice to say it).  </blockquote><p>Another wrote:</p><blockquote>I contribute to various repositories all over the world and my work is being accepted and appreciated! My work and I are valued by the community of the Software Developers!</blockquote><p>And another put it this way:</p><blockquote>The most important thing — I am now a real Open-Source Developer!</blockquote><p>Becoming a <em>real</em> open source developer means dealing with real problems, too.  One student put it well in his blog:</p><blockquote>Programming is not an easy thing.</blockquote><p>No, it isn't.  Despite the positive results, if you talked to the students during the labs, you would have heard them complaining about all sorts of problems doing this work, from wasting time finding things to work on, to problems with setting up their development environments, to difficulties understanding the code.  However, regardless of their complaints, most manage to get things done, and a lot do quite interesting work.</p><p>There's no doubt that having real deadlines, and a course grade to motivate them to find and finish open source work helps a lot more of them get involved than would if they were doing this on the side.  The students who don't take these courses could get involved in open source, but don't tend to--a lot more people are capable of this work than realize it.  They just need to put in the time.</p><h2 id="the-devil-s-in-the-details">The Devil's in the Details</h2><p>I wish I could say that I've found a guaranteed strategy to get students to come to class or do their homework, but alas, I haven't.  Not all students <em>do</em> put in the time, and for them, this can be a really frustrating and defeating process, as they find out that you can't do this sort of work last minute. They might be able to stay up all night and cram for a test, or write a half-hearted paper; but you can't fix software bugs this way.  Everything that can go wrong will (especially for those using Windows), and these <a href="https://en.wiktionary.org/wiki/yak_shaving">Yaks won't shave themselves</a>.  You need hours of uninterrupted development, patience, and time to communicate with the community.</p><p>One of the themes that kept repeating in my head this term is that work like this is all about <strong>paying attention to small details</strong>.  I'm amazed when I meet students taking an advanced programming course who can't be bothered with the details of this work.  I don't mean being able to answer trivia questions about the latest tech craze.  Rather, I mean being attuned to the importance and interplay of software, versions, libraries, tools, operating systems, syntax, and the like.  Computers aren't forgiving.  They don't care how hard you try.  If you aren't interested in examining software at the cellular level, it's really hard to breath life into source code.</p><p>Everything matters.  Students are amazed when they have to fix their commit messages ("too long", "wrong format", "reference this issue..."); squash and rebase commits (I warned them!), fix formatting (or vice versa when their editor got too ambitious autoformatting unrelated lines); change the names of variables; add comments; remove comments; add tests; fix tests; update version numbers; avoid updating version numbers! sign CLAs; add their name to AUTHORS files; don't add their name to other files!  pay attention to the failures on CI; ignore these other CI failures.</p><p>Thankfully, a lot of them do understand this, and as they travel further down the stacks of the software they use, and fix bugs deep inside massive programs, the value of small, delicate changes starts to make sense.  One of my students sent me a note to explain why one of her PRs was so small.  She had worked for weeks on a fix to a Google project, and in the end, all that investment of research, time, and debugging had resulted in a single line of code being changed.  Luckily I don't grade submissions by counting lines of code.  To me, this was a perfect fix.  I tried to reassure her by pointing out all the bugs she <em>hadn't</em> added by including more code than necessary.  Google agreed, and merged her fix.</p><h2 id="something-new">Something New</h2><p>This term I also decided to try something new.  We do a bunch of case studies, looking at successful open source projects (e.g., Redis, Prettier, VSCode) and I wanted to try and build an open source project together with the whole class using as much of the same tech and processes as possible.</p><p>I always get students involved in "external" projects (projects like those mentioned above, not run by me).  But by adding an "internal" project (one we run), a whole new kind of learning takes place.  Rather than showing up to an existing project, submitting a pull request and then moving on to the next, having our own project meant that students had to learn what it's like to be on the other side of a pull request, to become a maintainer vs. a contributor.</p><p>I've done smaller versions of this in the past, where I let students work in groups.  But to be honest it rarely works out the way I want.  Most students don't have enough experience designing and implementing software to be able to build something, and especially not something with lots of opportunity for people to contribute in parallel.</p><p>Our project was an RSS/Atom blog aggregator service and frontend called <a href="https://github.com/Seneca-CDOT/telescope">Telescope</a>.  The 60 of us wrote it in a month, and I'm pleased to say that "it works!" (though <a href="https://twitter.com/humphd/status/1204558634329530368">it doesn't "Just Work" yet</a>).  I recorded a <a href="https://www.youtube.com/watch?v=WAJ_T2rcKhU&amp;feature=youtu.be">visualization of the development process and put it on YouTube</a>.</p><figure class="kg-card kg-image-card"><img src="https://blog.humphd.org/content/images/2019/12/telescope-gource.png" class="kg-image"><figcaption>A day in the life of Telescope development</figcaption></figure><p>I've written a lot of open source software with students before, but never this many at once.  It was an interesting experience.  Here are some of my take-aways:</p><ul><li>I tried to file Issues and review PRs vs. writing code.  We got to 500 Issues and PRs by the end, and I filed and reviewed hundreds of these.  Most students are still learning how to file bugs, and how to think about decomposing a feature into actionable steps.  As the weeks went on, they started to get the hang of it.  But in the end, I had to write the first bit of code to get people to join me.  I also had to be patient to let the code evolve in "interesting" ways, and have faith we'd get to where we need to be in the end (we did).</li></ul><p></p><ul><li>No matter what I did (lessons in class, writing docs, helping people in the lab), people managed to get their git repos in a mess.  Because so many of the external open source projects the students worked on require a rebase workflow, I encouraged the same in our project.  However, that didn't stop people from merging <code>master</code> into their branches over and over again, sometimes a dozen times in the same pull request.  I still haven't figured out how to teach this perfectly.  I love git, but it's still really hard for beginners to use properly.  In the end I often did rebases myself to help get students out of a mess.  But despite the problems, most people got the hang of it after a few weeks.  One of the students put it this way in his blog: <em>"This summer I knew very little about git/GitHub…it was pure hell. Now we are jumping between branches and rebasing commits as gracefully and confident as squirrels."</em></li></ul><p></p><ul><li>Having a mix of macOS, Linux, and Windows meant we had to spend a lot of time on environment issues.  I think this is good, because it helps prepare students for the realities of modern programming.  However, I didn't love fighting with Windows on so, so many minor things.  Despite what I read online, I remain unconvinced that Windows is ready to be used as a primary development environment.</li></ul><p></p><ul><li>As we slowly added automation, tooling, and CI to the project, things got so much better.  One of the students added eslint with Airbnb's style guide.  This was interesting to watch, because it is very particular about spacing, and it made everyone have to adjust their work.  Later, we added Prettier and a .vscode directory with default extensions and project settings for line-endings, format-on-save, etc.  This fixed 99% of the issues we'd had previously, though we still needed a <code>.gitattributes</code> fix for Windows line endings to make git happy in Windows CI.</li></ul><p></p><ul><li>We used Jest for automated testing, and most students got to work on writing tests for the first time.  When I showed them how test coverage worked, a lot of them got really interested in increasing test coverage.  They also had to contend with lots of interesting issues, like rate-limits in live APIs vs. using mocks for network requests, dealing with test isolation and ordering issues, environment issues in CI that didn't manifest locally, and learning to write code defensively.</li></ul><p></p><ul><li>We used Docker and docker-compose to start our various services.  This was new for almost everyone, and quite a few students got really interested in how containers work.  Again, Windows made this an extremely frustrating experience for many students, who could never get it to run properly, and we had to work around that, too.</li></ul><p></p><ul><li> We tried to implement various pieces of the <a href="https://12factor.net/">12 Factor approach</a>, a lot of which were new to them.  For example, using environment variables.  Over the weeks they learned how various things can go wrong, like having authentication tokens slip into git.  It's invaluable learning, and making mistakes is how you do it.</li></ul><p></p><ul><li>I started with <code>package-lock.json</code> in git, and eventually removed it and went to exact versioning in <code>package.json</code>.  The amount of churn it caused with this many people was unworkable, especially with people learning git and npm at the same time.</li></ul><p></p><ul><li>The pace of development was frenetic.  For some people, this was a plus, and it got them excited.  For others, it was a turn off, and helped to further isolate them when they couldn't get their environment to work, or when they had to continually rebase branches that couldn't get merged fast enough.  It was imperative that I be there to help keep things moving, jump in with tricky rebases and merges, and help to finish certain problematic fixes.  For this to work, you really need a few "senior" people who can help keep things moving.</li></ul><p></p><ul><li>Despite what I wrote above, students will not ask for help.  Not in person.  Not on Slack.  Not in issues.  It's not a tooling problem.  By putting them all together in one place, the natural tendency to not want to look stupid gets multiplied, and people become less collaborative, rather than more.  They want to show-up with something finished vs. in process and broken.  I set-up a Slack channel, and it was mostly empty.  However, a whole bunch of private chat rooms and Discords sprouted in parallel.  It's hard to know how to make this work perfectly.  I try to model "not knowing" and asking questions, but it takes a long time to become comfortable working this way.  I know I don't know everything, and that's OK. Students are still figuring out how they feel about this.</li></ul><p></p><ul><li>Students reviewing each other's (and my) code is really valuable.  I made all the students Collaborators, and set GitHub so that you needed 2 approvals to merge any code on <code>master</code>.  Sometimes I used my admin rights to merge something fast, but for the most part this worked really well.  One of the students commented in his blog how much he'd learned just by reviewing everyone's code.  We also talked a lot about how to write changes so they'd be more reviewable, and this got better over time, especially as we studied <a href="https://google.github.io/eng-practices/review/">Google's Code Review process</a>.  It's a real skill to know how to do a review, and unless you get to practice it, it's hard to make much progress.  We also got to see the fallout of bad reviews, which let test failures land, or which removed code that they should not have.</li></ul><p>In the winter term I'm going to continue working on the project in the second course, and take them through the process of shipping it into production.  Moving from <em>fixing a bug</em> to <em>fixing enough bugs in order to ship</em> is yet another experience they need to have.  If you want to join us, you'd be welcome to do so.</p><p>All in all, it was a busy term, and I'm ready for a break.  I continue to be incredibly grateful to all the projects and maintainers who reviewed code and worked with my students this time.  Thank you to all of you.  I couldn't do any of this if you weren't so open and willing for us to show up in your projects.</p>]]></content:encoded></item><item><title><![CDATA[What is a blog post?]]></title><description><![CDATA[<p>I've been working on some RSS/Atom blog aggregation software with my open source students.  Recently we got everything working, and it let me do an analysis of the past 15 years of blogging by my students.</p><p>I wanted to answer the question, "What is a blog post?"  That is,</p>]]></description><link>https://blog.humphd.org/what-is-a-blog-post/</link><guid isPermaLink="false">5df2aa4c24511e03496b46bc</guid><category><![CDATA[mozilla]]></category><category><![CDATA[seneca]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Thu, 12 Dec 2019 21:29:46 GMT</pubDate><content:encoded><![CDATA[<p>I've been working on some RSS/Atom blog aggregation software with my open source students.  Recently we got everything working, and it let me do an analysis of the past 15 years of blogging by my students.</p><p>I wanted to answer the question, "What is a blog post?"  That is, which HTML elements are used at all, and most often?  Which are never used?  My students have used every blogging platform you can think of over the years, from WordPress to Blogger to Medium, and many have rolled their own.  Therefore, while not perfect, this is a pretty good view into what blogging software uses.</p><p>Analyzing many thousands of posts, and hundreds of thousands of elements, here's what I found.  The top 5 elements account for 75% of all elements used.  A blog post is mostly:</p><ol><li><code>&lt;br&gt;</code> (35%)</li><li><code>&lt;p&gt;</code> (18%)</li><li><code>&lt;a&gt;</code> (10%)</li><li><code>&lt;div&gt;</code> (15%)</li><li><code>&lt;li&gt;</code> (8%)</li></ol><p>I'm really surprised at <code>&lt;br&gt;</code> being on top.  The next 18% is made up of the following:</p><ol><li><code>&lt;td&gt;</code> (3%)</li><li><code>&lt;strong&gt;</code> (3%)</li><li><code>&lt;img&gt;</code> (3%)</li><li><code>&lt;pre&gt;</code> (2%)</li><li><code>&lt;code&gt;</code> (2%)</li><li><code>&lt;b&gt;</code> (1.5%)</li><li><code>&lt;em&gt;</code> (1.3%)</li><li><code>&lt;ul&gt;</code> (1.1%)</li><li><code>&lt;tr&gt;</code> (1%)</li></ol><p>And the remainder are all used infrequently (&lt; 1%):</p><ol><li><code>&lt;h3&gt;</code></li><li><code>&lt;figure&gt;</code></li><li><code>&lt;i&gt;</code></li><li><code>&lt;h4&gt;</code></li><li><code>&lt;blockquote&gt;</code></li><li><code>&lt;ol&gt;</code></li><li><code>&lt;hr&gt;</code></li><li><code>&lt;table&gt;</code></li><li><code>&lt;tbody&gt;</code></li><li><code>&lt;th&gt;</code></li><li><code>&lt;h5&gt;</code></li><li><code>&lt;iframe&gt;</code></li><li><code>&lt;strike&gt;</code></li><li><code>&lt;h6&gt;</code></li><li><code>&lt;thead&gt;</code></li><li><code>&lt;caption&gt;</code></li></ol><p>It's intresting to see the order of the heading levels match their frequency.  I'm also interested in what isn't here.  In all these posts, there's no <code>&lt;span&gt;</code>, ever.</p>]]></content:encoded></item><item><title><![CDATA[Hacktoberfest 2019]]></title><description><![CDATA[<p>I've been marking student submissions in my open source course this weekend, and with only a half-dozen more to do, the procrastinator in me decided a blog post was in order.</p><p>Once again I've asked my students to participate in <a href="https://hacktoberfest.digitalocean.com/">Hacktoberfest</a>.  I <a href="https://blog.humphd.org/observations-on-hacktoberfest-2018/">wrote about the experience last year</a>, and wanted</p>]]></description><link>https://blog.humphd.org/hacktoberfest-2019/</link><guid isPermaLink="false">5dc89fce24511e03496b45b3</guid><category><![CDATA[seneca]]></category><category><![CDATA[mozilla]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Mon, 11 Nov 2019 00:17:53 GMT</pubDate><content:encoded><![CDATA[<p>I've been marking student submissions in my open source course this weekend, and with only a half-dozen more to do, the procrastinator in me decided a blog post was in order.</p><p>Once again I've asked my students to participate in <a href="https://hacktoberfest.digitalocean.com/">Hacktoberfest</a>.  I <a href="https://blog.humphd.org/observations-on-hacktoberfest-2018/">wrote about the experience last year</a>, and wanted to give an update on how it went this time.</p><p>I layer a few extra requirements on the students, some of them to deal with things I've learned in the past.  For one, I ask them to set some personal goals for the month, and look at each pull request as a chance to progress toward achieving these goals.  The students are quite different from one another, which I want to celebrate, and this lets them go in different directions, and move at different paces.</p><p>Here are some examples of the goals I heard this time around:</p><ul><li>Finish all the required PRs</li><li>Increase confidence in myself as a developer</li><li>Master git/GitHub</li><li>Learn new languages and technologies (Rust, Python, React, etc)</li><li>Contribute to projects we use and enjoy on a daily basis (e.g., VSCode)</li><li>Contribute to some bigger projects (e.g., Mozilla)</li><li>Add more experience to our resume</li><li>Read other people's code, and get better at understanding new code</li><li>Work on projects used around the world</li><li>Work on projects used locally</li><li>Learn more about how big projects do testing</li></ul><p>So how did it go?  First, the numbers:</p><ul><li><strong>62 students</strong> completed all 4 PRs during the month (95% completion rate)</li><li><strong>246 Pull Requests</strong> were made, consisting of <strong>647 commits to 881 files</strong></li><li><strong>32K lines of code</strong> were added or modified</li></ul><p>I'm always interested in the languages they choose.  I let them work on any open source projects, so given this freedom, how will they use it?  The most popular languages by pull request ere:</p><ul><li>JavaScript/TypeScript - 50%</li><li>HTML/CSS - 11%</li><li>C/C++/C# - 11%</li><li>Python - 10%</li><li>Java - 5%</li></ul><p>Web technology projects dominate GitHub, and it's interesting to see that this is not entirely out of sync with <a href="https://octoverse.github.com/#top-languages">GitHub's own stats</a> on language positions.  As always, the long-tail provides interesting info as well.  A lot of people worked on bugs in languages they didn't know previously, including:</p><p>Swift, PHP, Go, Rust, OCaml, PowerShell, Ruby, Elixir, Kotlin</p><p>Because I ask the students to "progress" with the complexity and involvement of their pull requests, I had fewer people working in "Hacktoberfest" style repos (projects that popup for October, and quickly vanish).  Instead, many students found their way into larger and well known repositories and organizations, including:</p><p>Polymer, Bitcoin, Angular, Ethereum, VSCode, Microsoft Calculator, React Native for Windows, Microsoft STL, Jest, WordPress, node.js, Nasa, Mozilla, Home Assistant, Google, Instacart</p><p>The top GitHub organization by pull request volume was Microsoft.  Students worked on many Microsoft projects, which is interesting, since they didn't coordinate their efforts.  It turns out that Microsoft has a lot of open source these days.</p><p>When we were done, I asked the students to reflect on the process a bit, and answer a few questions.  Here's what I heard.</p><p><strong>1. What are you proud of?  What did you accomplish during October?</strong></p><ul><li>Contributing to big projects (e.g., Microsoft STL, Nasa, Rust)</li><li>Contributing to small projects, who really needed my help</li><li>Learning a new language (e.g., Python)</li><li>Having PRs merged into projects we respect</li><li>Translation work -- using my personal skills to help a project</li><li>Seeing our work get shipped in a product we use</li><li>Learning new tech (e.g., complex dev environments, creating browser extensions)</li><li>Successfully contributing to a huge code base</li><li>Getting involved in open source communities</li><li>Overcoming the intimidation of getting involved</li></ul><p><strong>2. What surprised you about Open Source?  How was it different than you expected?</strong></p><ul><li>People in the community were much nicer than I expected</li><li>I expected more documentation, it was lacking</li><li>The range of projects: big companies, but also individuals and small communities</li><li>People spent time commenting on, reviewing, and helping with our PRs</li><li>People responded faster than we anticipated</li><li>At the same time, we also found that some projects never bothered to respond</li><li>Surprised to learn that everything I use has some amount of open source in it</li><li>Surprised at how many cool projects there are, so many that I don’t know about</li><li>Even on small issues, lead contributors will get involved in helping (e.g., 7 reviews in a node.js fix)</li><li>Surprised at how unhelpful the “Hacktoberfest” label is in general</li><li>“Good First Issue” doesn’t mean it will be easy.  People have different standards for what this means</li><li>Lots of things on GitHub are inactive, be careful you don’t waste your time</li><li>Projects have very different standards from one to the next, in terms of process, how professional they are, etc.</li><li>Surprised to see some of the hacks even really big projects use</li><li>Surprised how willing people were to let us get involved in their projects</li><li>Lots of camaraderie between devs in the community</li></ul><p><strong>3. What advice would you give yourself for next time?</strong></p><ul><li>Start small, progress from there</li><li>Manage your time well, it takes way longer than you think</li><li>Learn how to use GitHub’s Advanced Search well</li><li>Make use of your peers, ask for help</li><li>Less time looking for a perfect issue, more time fixing a good-enough issue</li><li>Don’t rely on the Hacktoberfest label alone.</li><li>Don’t be afraid to fail.  Even if a PR doesn’t work, you’ll learn a lot in the process</li><li>Pick issues in projects you are interested in, since it takes so much time</li><li>Don’t be afraid to work on things you don’t (yet) know.  You can learn a lot more than you think.</li><li>Read the contributing docs, and save yourself time and mistakes</li><li>Run and test code locally before you push</li><li>Don’t be too picky with what you work on, just get involved</li><li>Look at previously closed PRs in a project for ideas on how to solve your own.</li></ul><p>One thing that was new for me this time around was seeing students get involved in repos and projects that didn't use English as their primary language.  I've had lots of students do localization in projects before.  But this time, I saw quite a few students working in languages other than English in issues and pull requests.  This is something I've been expecting to see for a while, especially with <a href="https://github.com/trending">GitHub's Trending</a> page so often featuring projects not in English.  But it was the first time it happened organically with my own students.</p><p>Once again, I'm grateful to the Hacktoberfest organizers, and to the hundreds of maintainers we encountered as we made our way across GitHub during October.  When you've been doing open source a long time, and work in git/GitHub everyday, it can be hard to remember what it's like to begin.  Because I continually return to the place where people start, I know first-hand how valuable it is to be given the chance to get involved, for people to acknowledge and accept your work, and for people to see that it's possible to contribute.</p>]]></content:encoded></item><item><title><![CDATA[Some Assembly Required]]></title><description><![CDATA[<p>In my open source courses, I spend a lot of time working with new developers who are trying to make sense of issues on GitHub and figure out how to begin.  When it comes to how people write their issues, I see all kinds of styles.  Some people write for</p>]]></description><link>https://blog.humphd.org/some-assembly-required/</link><guid isPermaLink="false">5d700d6a24511e03496b4378</guid><category><![CDATA[mozilla]]></category><category><![CDATA[seneca]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Wed, 04 Sep 2019 20:30:26 GMT</pubDate><content:encoded><![CDATA[<p>In my open source courses, I spend a lot of time working with new developers who are trying to make sense of issues on GitHub and figure out how to begin.  When it comes to how people write their issues, I see all kinds of styles.  Some people write for themselves, using issues like a TODO list: "I need to fix X and Y."  Other people log notes from a call or meeting, relying on the collective memory of those who attended: "We agreed that so-and-so is going to do such-and-such."  Still others write issues that come from outside the project, recording a bug or some other problem: "Here is what is happening to me..."</p><p>Because I'm getting ready to take another cohort of students into the wilds of GitHub, I've been thinking once more about ways to make this process better.  Recently I spent a number of days assembling furniture from IKEA with my wife.  Spending that much time with Allen keys got me thinking about what we could learn from IKEA's work to enable contribution from customers.</p><figure class="kg-card kg-image-card"><img src="https://blog.humphd.org/content/images/2019/09/instructions_IKEA_billy.jpg" class="kg-image"></figure><p>I am not a furniture maker.  Not even close.  While I own some power tools, most were gifts from my father, who actually knows how to wield them.  I'm fearless when it comes to altering bits in a computer; but anything that puts holes in wood, metal, or concrete terrifies me.  And yet, like so many other people around the world, I've "built" all kinds of furniture in our house--at least I've <em>assembled </em>it.</p><p>In case you haven't bought furniture from IKEA, they are famous for designing not only the furniture itself, but also the materials, packaging, and saving cost by offloading most of the assmbly to the customer.  Each piece comes with instructions, showing the parts manifest, tools you'll need (often simple ones are included), and pictorial, step-wise instructions for assembling the piece.</p><p>IKEA's model is amazing: amazing that people will do it, amazing that it's doable at all by the general public!  You're asking people to do a task that they a) probably have never done before; b) probably won't do again.  Sometimes you'll buy 4 of some piece, a chair, and through repeated trial and error, get to the point where you can assemble it intuitively.  But this isn't the normal use case.  For the most part, we buy something we don't have, assemble it, and then we have it.  This means that the process has to work during the initial attempt, without training.  IKEA is keen that it work because they don't want you to return it, or worse, never come back again.</p><p>Last week I assembled all kinds of things for a few rooms in our basement: chairs, a couch, tables, etc.  I spent hours looking at, and working my way through IKEA instructions.  Take another look at the Billy instructions I included above.  Here's some of what I notice:</p><ul><li>It starts with the end-goal: here is how things should look when you're done</li><li>It tells you what tools you'll need in order to make this happen and, importantly, imposes strict limits on the sorts of tools that might be required.  An expert could probably make use of more advanced tools; but this isn't for experts.</li><li>It gives you a few GOTCHAs to avoid up front.  "Be careful to do it <em>this</em> way, not <em>that</em> way.<em>" </em> This repeats throughout the rest of the steps.  Like this, not that.</li><li>It itemizes and names (via part number) all the various pieces you'll need.  There should be 16 of these, 18 of these, etc.</li><li>It takes you step-by-step through maniplating the parts on the floor into the product you saw in the store, all without words.</li><li>Now look at how short this thing is.  The information density is high even though the complexity is low.</li></ul><p>It got me thinking about lessons we could learn when filing issues in open source projects.  I realize that there isn't a perfect analogy between assmbling furniture and fixing a bug.  IKEA mass produces the same bookshelf, chairs, and tables, and these instructions work on all of them.  Meanwhile, a bug (hopefully) vanishes as soon as it's fixed.  We can't put the same effort into our instructions for a one-off experience as we can for a mass produced one.  However, in both cases, I would stress that the experience is similar for the person working through the "assembly," it's often their first time following these steps.</p><p>When filing a GitHub issue, what could we learn from IKEA instructions?</p><ol><li>Show the end goal of the work.  "This issue is about moving this button to the right.  Currently it looks like <em>this</em> and we want it to look like <em>this</em>."  A lot of people do this, especially with visual, UI related bugs.  However, we could do a version of it on lots of non-visual bugs too.  <em>Here is what you're trying to acheive with this work</em>.  When we file bugs, we assume this is always clear.  But imagine it needs to be clear based solely on these "instructions."</li><li>List the tools you'll need to accomplish this, and include any that are not common.  We do this sometimes. "Go read the CONTRIBUTING.md page."  That might be enough.  But we could put more effort into calling out specific things you'll need that might not be obvious, URLs to things, command invocation examples, etc.  I think a lot of people bristle at the idea of using issues to teach people "common knowledge."  I agree that there's a limit to what is reasonable in an issue (recall how short IKEA's was).  But we often err on the side of not-enough, and assume that <em>our</em> knowledge is the same as our reader's.  It almost certainly won't be if this is for a new contributor.</li><li>Call out the obsticles in the way of accomplishing this work.  Probably there are some things you should know about how the tests run when we change this part of the code.  Or maybe you need to be aware that we need to run some script after we update things in this directory.  Any mistakes that people have made in the past, and which haven't been dealt with through automation, are probably in scope here.  Even better, put them in a more sticky location like the official docs, and link to them from here.</li><li>Include a manifest of the small parts involved.  For example, see the lines of code <em>here, here, and here</em>.  You'll have to update <em>this file, this file,</em> and <em>that file</em>.  This is the domain of the change you're going to need to make.  Be clear about what's involved.  I've done this a lot, and it often doesn't take much time when you know the code well.  However, for the new contributor, this is a lifesaver.</li><li>Include a set of steps that one could follow on the way to making this fix.  This is espeically important in the case that changes need to happen in a sequence.</li></ol><p>These steps aren't always possible or practical.  But it takes less work than you might think, and the quality of the contributions you get as a result is worth the upfront investment.  In reality, you'll likely end up having to it in reviews after the fact, when people get it wrong.  Try doing it at the beginning.</p><p>Here's a fantastic example of how to do it well.  I've tweeted about this in the past, but Devon Abbott's issue in the Lona repo is fantastic: <a href="https://github.com/airbnb/Lona/issues/338">https://github.com/airbnb/Lona/issues/338</a>.  Here we see many of the things outlined above.  As a result of this initial work, <a href="https://github.com/airbnb/Lona/pull/348">one of my students was able to jump in</a>.</p><p>I want to be careful to not assume that everyone has time to do all this when filing bugs.  Not all projects are meant for external contributors (GitHub actually needs some kind of signal so that people know when to engage and when to avoid certain repos), and not all developers on GitHub are looking to mentor or work with new contributors.  Regardless, I think we could all improve our issues if we thought back to these IKEA instructions from time to time.  A lot of code fixes and regular maintenance tasks should really feel more like assembling furniture vs. hand carving a table leg.  There's so much to do to keep all this code working, we are going to have to find ways to engage and involve new generations of developers who need a hand getting started.</p>]]></content:encoded></item><item><title><![CDATA[irc.mozilla.org]]></title><description><![CDATA[<p>Today I read <a href="http://exple.tive.org/blarg/2019/04/26/synchronous-text/">Mike Hoye's blog post</a> about Mozilla's IRC server coming to an end.  He writes:</p><blockquote>Mozilla has relied on IRC as our main synchronous communications tool since the beginning...While we still use it heavily, IRC is an ongoing source of abuse and  harassment for many of our</blockquote>]]></description><link>https://blog.humphd.org/irc-mozilla-org/</link><guid isPermaLink="false">5cc3a0f724511e03496b4057</guid><category><![CDATA[mozilla]]></category><category><![CDATA[seneca]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Sat, 27 Apr 2019 02:51:04 GMT</pubDate><content:encoded><![CDATA[<p>Today I read <a href="http://exple.tive.org/blarg/2019/04/26/synchronous-text/">Mike Hoye's blog post</a> about Mozilla's IRC server coming to an end.  He writes:</p><blockquote>Mozilla has relied on IRC as our main synchronous communications tool since the beginning...While we still use it heavily, IRC is an ongoing source of abuse and  harassment for many of our colleagues and getting connected to this now-obscure forum is an unnecessary technical barrier for anyone finding their way to Mozilla via the web.   </blockquote><p>And, while "<em>Mozilla intends to deprecate IRC</em>," he goes on to say: </p><blockquote>we definitely still need a globally-available, synchronous and text-first communication tool.</blockquote><p>While I made dinner tonight, I thought back over my long history using Mozilla's IRC system, and tried to understand its place in my personal development within Mozilla and open source.</p><h3 id="-invite">/invite</h3><p>I remember the very first time I used IRC.  It was 2004, and earlier in the week I had met with Mike Shaver at Seneca, probably for the first time, and he'd ended our meeting with a phrase I'd never heard before, but I nodded knowingly nevertheless: <em>"Ping me in #developers."</em></p><p>Ping me.  What on earth did that mean!? Little did I know that this phrase would come to signify so much about the next decade of my life.  After some research and initial trial and error, 'dave' joined irc.mozilla.org and found his way to the unlisted #developers channel.  And there was 'shaver', along with 300 or so other #developers.</p><p>The immediacy of it was unlike anything I'd used before (or since).  To join irc was to be transported somewhere else.  You weren't anywhere, or rather, you were simultaneously everywhere.  For many of these years I was connecting to irc from an old farm house in the middle of rural Ontario over a satellite internet connection.  But when I got online, there in the channels with me were people from New Zealand, the US, Sweden, and everywhere in between.</p><p>Possibly you've been on video calls with people from around the world, and felt something similar.  However, what was different from a video call, or teleconference, or any other medium I've used since, is that the time together didn't need to end.  You weren't <em>meeting</em> as such, and there wasn't a timebox or shared goal around your presence there.  Instead, you were working amongst one another, co-existing, listening, and most importantly for me, learning.</p><h3 id="-join">/join</h3><p>Over the next year, irc went from being something I used here and there to something I used all the time.  I became 'humph' (one day Brendan confused me for Dave Herman, and shaver started calling me 'humph' to clarify) and have remained so ever since.  There are lots of people who have only ever called me 'humph' even to my face, which is hilarious and odd, but also very special.</p><p>Mike Beltzner taught me how to overcome one of the more difficult aspects of IRC: maintaining context after you log off.  Using <a href="https://quadpoint.org/articles/irssi/">screen and irssi</a> I was able to start, leave, and then pick up conversations at a later time.  It's something you take for granted on Slack, but was critical to me being able to leverage IRC as a source of knowledge: if I asked a question, it might be hours before the person who could answer it would wake up and join irc from another part of the planet. </p><p>I became more engaged with different areas of the project.  IRC is siloed.  A given server is partitioned into many different channels, and each has its own sub-culture, appropriate topics, and community.  However, people typically participate in many channels.  As you get to know someone in one channel, you'll often hear more about the work happening in another.  Slowly I got invited into other channels and met more and more people across the Mozilla ecosystem.</p><p>Doing so took me places I hadn't anticipated.  For example, at some point I started chatting with people in #thunderbird, which led to me becoming an active contributor--I remember 'dascher' just started assigning me bugs to fix!  Another time I discovered the #static channel and a guy named 'taras' who was building crazy static analysis tools with gcc.  Without irc I can confidently say that I would have never started <a href="https://github.com/mozilla/dxr">DXR</a>, or worked on web audio, WebGL, all kinds of Firefox patches, or many of the other things I did.  I needed to be part of a community of peers and mentors for this work to be possible.</p><p>At a certain point I went from joining other channels to creating my own.  I started to build many communities within Mozilla to support new developers.  It was incredible to watch them fill up with a mix of experienced Mozilla contributors and people completely new to the project.  Over the years it helped to shape my approach to getting students involved in open source through direct participation.</p><h3 id="-list">/list</h3><p>In some ways, IRC was short for "I Really Can do this."  On my own?  No.  No way. But with the support of a community that wasn't going to abandon me, who would answer my questions, spend long hours helping me debug things, or introduce me to people who might be able to unlock my progress, I was able to get all kinds of new things done.  People like shaver, ted, gavin, beltzner, vlad, jorendorff, reed, preed, bz, stuart, Standard8, Gijs, bsmedberg, rhelmer, dmose, myk, Sid, Pomax, and a hundred other friends and colleagues.</p><p>The kind of help you get on irc isn't perfect.  I can remember many times asking a question, and having bsmedberg give a reply, which would take me the rest of the day (or week!) to unpack and fully understand.  You got hints.  You got clues.  You were (sometimes) pointed in the right direction.  But no one was going to hold your hand the whole way.  You were at once surrounded by people who knew, and also completely on your own.  It still required a lot of personal research.  Everyone was also struggling with their own pieces of the puzzle, and it was key to know how much to ask, and how much to do on your own.</p><h3 id="-query">/query</h3><p>Probably the most rewarding part of irc were the private messages.  Out of the blue, someone would <em>ping</em> you, sometimes in channel (or a new channel), but often just to you personally.  I developed many amazing friendships this way, some of them with people I've never met outside of a text window.</p><p>When I was working on the <a href="https://wiki.mozilla.org/Audio_Data_API">Firefox Audio Data API</a>, I spent many weeks fighting with the DOM implementation.  There were quite a few people who knew this code, but their knowledge of it was too far beyond me, and I needed to work my way up to a place where we could discuss things.  I was very much on my own, and it was hard work.</p><p>One day I got a ping from someone calling themselves 'notmasteryet'.  I'd been blogging about my work, and linked to my patches, and 'notmasteryet' had started working on them.  You can't imagine the feeling of having someone on the internet randomly find you and say, "I think I figured out this tricky bit you've been struggling to make work."  That's exactly what happened, and we went on to spend many amazing weeks and months working on this together, sharing this quiet corner of Mozilla's irc server, moving at our own pace.</p><p>I hesitated to tell a story like this because there is no way to do justice to the many relationships I formed during the next decade.  I can't tell you all the amazing stories.  At one time or another, I got to work with just about everyone in Mozilla, and many became friends.  IRC allowed me to become a part of Mozilla in ways that would have been impossible just reading blogs, mailing lists, or bugzilla.  To build relationships, one needs long periods of time together.  It happens slowly.</p><h3 id="-part">/part </h3><p>But then, at a certain point, I stopped completely.  It's maybe been four or five years since I last used irc.  There are lots of reasons for it.  Partly it was due to things mhoye discussed in his blog post (I can confirm that harassment is real on irc). But also Mozilla had changed, and many of my friends and colleagues had moved on.  IRC, and the Mozilla that populated it, is part of the past.</p><p>Around the same time I was leaving IRC, Slack was just starting to take off.  Since then, Slack has come to dominate the space once occupied by tools like irc.  As I write this, Slack is in the process of doing its IPO, with an impressive $400M in revenue last year.  Slack is popular.</p><p>When I gave up irc, I really didn't want to start in on another version of the same thing.  I've used it a lot out of necessity, and even in my open source classes as a way to expose my students to it, so they'll know how it works.  But I've never really found it compelling.  Slack is a better irc, there's no doubt.  But it's also not what I loved about irc.mozilla.org.</p><p>Mike writes that he's in the process of evaluating possible replacements for irc within Mozilla.  I think it's great that he and Mozilla are wrestling with this.  I wish more open source projects would do it, too.  Having a way to get deeply engaged with a community is important, especially one as large as Mozilla.</p><p>Whatever product or tool gets chosen, it needs to allow people to join without being invited.  Tools like Slack do a great job with authentication and managing identity.  But to achieve it they rely on gatekeeping.  I wasn't the typical person who used irc.mozilla.org when I started; but by using it for a long time, I made it a different place.  It's really important that any tool like this does more than just support the in-groups (e.g., employees, core contributors, etc).  It's also really important that any tool like this does better than <a href="https://twitter.com/ehsanakhgari/status/1075821897877729280">create out-groups</a>.</p><h3 id="-quit">/quit</h3><p>IRC was a critical part of my beginnings in open source.  I loved it.  I still miss many of the friends I used to talk to daily.  I miss having people ping me.  As I work with my open source students, I think a lot about what I'd do if I was starting today.  It's not possible to follow the same path I took.  The conclusion I've come to is that the only way to get started is to focus on connecting with people.  In the end, the tools don't matter, they change.  But the people matter a lot, and we should put all of our effort into building relationships with them.  </p>]]></content:encoded></item><item><title><![CDATA[Teaching Open Source: Sept 2018 - April 2019]]></title><description><![CDATA[<p>Today I submitted my grades and completed another year of teaching.  I've spent the past few weeks marking student projects non-stop, which has included reading <strong>a lot</strong> of pull requests in my various open source courses.</p><p>As a way to keep myself sane while I marked, I wrote some code</p>]]></description><link>https://blog.humphd.org/teaching-open-source-sept-2018-april/</link><guid isPermaLink="false">5cbde3e624511e03496b3be2</guid><category><![CDATA[mozilla]]></category><category><![CDATA[seneca]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Tue, 23 Apr 2019 02:31:19 GMT</pubDate><content:encoded><![CDATA[<p>Today I submitted my grades and completed another year of teaching.  I've spent the past few weeks marking student projects non-stop, which has included reading <strong>a lot</strong> of pull requests in my various open source courses.</p><p>As a way to keep myself sane while I marked, I wrote some code to do analysis of all the pull requests my students worked on during the fall and winter terms.  I've been teaching open source courses at Seneca since 2005, and I've always wanted to do this.  Now that I've got all of my students contributing to projects on GitHub, it's become much easier to collect this info via the amazing <a href="https://developer.github.com/v3/">GitHub API</a>.</p><p>I never teach these classes exactly the same way twice.  Some years I've had everyone work on different parts of a larger project, for example, implementing features in Firefox, or working on specific web tooling.  This year I took a different approach, and let each student be self-directed, giving them more freedom to choose whatever open source projects they wanted.  Having done so, I wanted to better understand the results, and what lessons I could draw for subsequent years.</p><h2 id="github-analysis">GitHub Analysis</h2><p>To begin, here are some of the numbers:</p><p><strong>104 students</strong> participated in my open source courses from Sept 2018 to April 2019, some taking both the first and second courses I teach.</p><p>Together, these students made <strong>1,014 Pull Requests</strong> to <strong>308 Repositories.</strong>  The average number of PRs per student was 9.66 (mode=12, median=10, max=22).  Here's a breakdown of what happened with these PRs:</p><table>
<thead>
<tr>
<th></th>
<th>Total</th>
<th>Percent</th>
</tr>
</thead>
<tbody>
<tr>
<td>Merged</td>
<td>606</td>
<td>60%</td>
</tr>
<tr>
<td>Still Open</td>
<td>258</td>
<td>25%</td>
</tr>
<tr>
<td>Closed (Unmerged)</td>
<td>128</td>
<td>13%</td>
</tr>
<tr>
<td>Deleted (By Student)</td>
<td>22</td>
<td>2%</td>
</tr>
</tbody>
</table>
<p>I was glad to see so many get merged, and so few get closed without full resolution.  There are lots of projects that are slow to respond to PRs, or never respond.  But the majority of the "Still Open" PRs are those that were completed in the last few weeks.</p><p>Next, I was really interested to see which languages the students would choose.  All of the students are in their final semesters of a programming diploma or degree, and have learned half-a-dozen programming languages by now.  What did they choose?  Here's the top of the list:</p><table>
<thead>
<tr>
<th>Language</th>
<th>Total (PRs)</th>
<th>Percent</th>
</tr>
</thead>
<tbody>
<tr>
<td>JavaScript</td>
<td>508</td>
<td>51%</td>
</tr>
<tr>
<td>Python</td>
<td>85</td>
<td>9%</td>
</tr>
<tr>
<td>C++</td>
<td>79</td>
<td>8%</td>
</tr>
<tr>
<td>Java</td>
<td>68</td>
<td>7%</td>
</tr>
<tr>
<td>TypeScript</td>
<td>39</td>
<td>3.9%</td>
</tr>
<tr>
<td>C#</td>
<td>34</td>
<td>3.4%</td>
</tr>
<tr>
<td>Swift</td>
<td>28</td>
<td>2.8%</td>
</tr>
<tr>
<td>Other</td>
<td>152</td>
<td>14.9%</td>
</tr>
</tbody>
</table>
<p>In some ways, no surprises here. This list mirrors other similar lists I've seen around the web.  I suspect the sway toward JS also reflects my own influence in the courses, since I teach using a lot of case studies of JS projects.</p><p>The "Other" category is interesting to me.  Many students purposely chose to work in languages they <em>didn't</em> know in order to try something new (I love and encourage this, by the way).  Among these languages I saw PRs in all of:</p><p>Rust (16), Go (13), Kotlin (11), PHP (5), Ruby (3), Clojure (3), Lua (2), as well as Scala, F#, Dart, PowerShell, Assembly, GDScript, FreeMaker, and Vim script.</p><p>Over the weeks and months, my goal for the students is that they would progress, working on larger and more significant projects and pull requests.  I don't define <em>progress</em> or <em>significant</em> in absolute terms, since each student is at a different place when they arrive in the course, and progress can mean something quite different depending on your starting point.  That said, I was interested to see the kinds of "larger" and more "complex" projects the students chose.  Some examples of more recognizable projects and repos I saw:</p><ul><li>Lots of Microsoft projects: <a href="https://github.com/Microsoft/vscode">vscode</a>, <a href="https://github.com/microsoft/calculator">calculator</a>, <a href="https://github.com/Microsoft/fast-dna">fast-dna</a>, <a href="https://github.com/Microsoft/monaco-editor">monaco-editor</a>, and half a dozen others.</li><li>Lots of Mozilla projects: <a href="https://github.com/mozilla-mobile/fenix">fenix</a>, <a href="https://github.com/mozilla-mobile/focus-ios/">focus-ios</a>, <a href="https://github.com/mozilla/gecko-dev">Firefox</a>, <a href="https://github.com/mozilla/addons-frontend/">addons-frontend</a>, <a href="https://github.com/mozilla/voice-web/">voice-web</a>, <a href="https://github.com/firefox-devtools/debugger">Firefox devtools-debugger</a></li><li>Python, Data Science and ML tools: <a href="https://github.com/pandas-dev/pandas">pandas</a>, <a href="https://github.com/numpy/numpy">numpy</a>, <a href="https://github.com/keras-team/keras">keras</a>, <a href="https://github.com/pypa/pipenv">pipenv</a></li><li>Node projects: <a href="https://github.com/nodejs/node">nodejs</a>, <a href="https://github.com/mochajs/mocha">mochajs</a>, <a href="https://github.com/expressjs/express">expressjs</a></li><li>Facebook projects: <a href="https://github.com/facebook/docusaurus">docusaurus</a>, <a href="https://github.com/facebook/jest">jest</a>, <a href="https://github.com/reactjs/reactjs.org/">reactjs.org</a></li><li>Airbnb: <a href="https://github.com/airbnb/Lona">Lona</a></li><li>Brave: <a href="https://github.com/brave/brave-ios">Brave iOS</a></li><li>GitHub: <a href="https://github.com/desktop/desktop">desktop</a></li></ul><p>They worked on editors (<a href="https://github.com/notepad-plus-plus/notepad-plus-plus">Notepad++</a>, <a href="https://github.com/neovim/neovim">Neovim</a>), blogging platforms (<a href="https://github.com/TryGhost/Ghost">Ghost</a>, <a href="https://github.com/wordpress-mobile/WordPress-Android">WordPress</a>), compilers (<a href="https://github.com/emscripten-core/emscripten">emscripten</a>), blockchain, game engines, email apps, online books, linting tools, mapping tools, terminals, web front-end toolkits, and just about everything you can think of, including lots of things I wouldn't have thought of (or recommended!).</p><p>They also did lots and lots of very small contributions: typos, dead code removal, translation and localization, "good first issue," "help wanted," "hacktoberfest."  I saw everything.</p><h2 id="stories-from-student-blogs">Stories from Student Blogs</h2><p>Along the way I had them write blog posts, and reflect on what they were learning, what was working and what wasn't, and how they felt.  Like all students, many do the bare minimum to meet this requirement; but some understand the power and reach of a good blog post.  I read some great ones this term.  Here are just a few stories of the many I enjoyed watching unfold.</p><h3 id="i-">I.</h3><p><a href="https://medium.com/@juliakmdev/the-virtues-of-open-source-4cd3e080399d">Julia</a> pushed herself to work on a lot of different projects, from VSCode to Mozilla's Voice-Web to nodejs.  Of her contribution to node, she writes:</p><blockquote>I think one of my proudest contributions to date was for Node.js. This is something I never would have imagined contributing to even just a  year ago.</blockquote><p>We talk a lot, and openly, about imposter syndrome.  Open source gives students a chance to prove to themselves, and the world, that they are indeed capable of working at a high level.  Open source is hard, and when you're able to do it, and your work gets merged, it's very affirming on a personal level.  I love to see students realize they do in fact have something to contribute, that maybe they <em>do</em> belong.</p><p>Having gained this confidence working on node, Julia went on to really find her stride working within <a href="https://github.com/Microsoft/fast-dna">Microsoft's Fast-DNA</a> project, fixing half-a-dozen issues during the winter term:</p><blockquote>I’ve gotten to work with a team that seems dedicated to a strong  development process and code quality, which in turn helps me build good  habits when writing code.</blockquote><p>Open source takes students out of the confines and limitations of a traditional academic project, and lets them work with professionals in industry, learning how they work, and how to build world-class software.</p><h3 id="ii-">II.</h3><p><a href="https://opensource-topics.blogspot.com/2019/04/progress-in-open-source.html">Alexander</a> was really keen to learn more about Python, ML, and data science.  In the fall he <a href="https://opensource-topics.blogspot.com/2019/01/planning-pandas-contributions-for-next.html">discovered the data analysis library Pandas</a>, and slowly began learning how to contribute to the project.  At first he focused on bugs related to documentation and linting, which led to him <a href="https://opensource-topics.blogspot.com/2019/01/unit-tests-in-pandas.html">learning how their extensive unit tests worked</a>.  I think he was a bit surprised to discover just how much his experience with the unit tests would help him move forward to fixing bugs:</p><blockquote>In the beginning, I had almost no idea what any of the functions did and I would get lost navigating through the directories when searching for something. Solving linting errors was a great start for me and was also challenging enough due to my lack of knowledge in open  source and the Pandas project specifically. Now I could identify where the issue originates from easily and also  write tests to ensure that the requested functionality works as expected. Solving the actual issue is still challenging because finding a solution to the actual problem requires the most time and research.  However, now I am able to solve real code problems in Pandas, which I  would not be able to do when I started. I'm proud of my progress...</blockquote><p>Open source development tends to favour many small, incremental improvements vs. big changes, and this maps well to the best way for students to build confidence and learn: bit at a time, small steps on the road of discovery.</p><p>One of the many Pandas APIs that Alexander worked on was the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dropna.html">dropna() function</a>.  He fixed a <a href="https://opensource-topics.blogspot.com/2019/03/another-dropna-bug-in-pandas.html">number</a> <a href="https://opensource-topics.blogspot.com/2019/03/fixing-couple-small-issues-in-pandas.html">of</a> <a href="https://opensource-topics.blogspot.com/2019/02/working-with-incomplete-multiindex-keys.html">bugs</a> related to its implementation. Why bother fixing dropna?  With the recent <a href="https://www.jpl.nasa.gov/edu/news/2019/4/19/how-scientists-captured-the-first-image-of-a-black-hole/">black hole imaging announcement</a>, I noticed that <a href="https://github.com/achael/eht-imaging">source code for the project was put on GitHub</a>.  Within that code I thought it was interesting to discover <a href="https://github.com/achael/eht-imaging/blob/b3593731b394a58b6f948e84d14fbed7420729da/ehtim/statistics/dataframes.py#L68">Pandas and dropna()</a> being used, and further, that it had been <a href="https://github.com/achael/eht-imaging/pull/55">commented out due to a bug</a>.  Was this fixed by one of Alexander's recent PRs?  Hard to say, but regardless, lots of future  scientists and researchers will benefit from his work to fix these bugs.  Software maintenance is rewarding work.</p><p>Over and over again during the year, I heard students discuss how surprised they were to find bugs in big software projects.  If you've been working on software for a long time, you know that all software has bugs.  But when you're new, it feels like only <em>you</em> make mistakes.</p><p>In the course I emphasize the importance of software maintenance, the value of fixing or removing existing code vs. always adding new features.  Alexander spent all his time maintaining Pandas and functions like dropna(), and I think it's an ideal way for students to get involved in the software stack.</p><h3 id="iii-">III.</h3><p><a href="https://medium.com/@volodymyrklymenko/from-writing-unit-tests-to-working-on-the-software-from-mozilla-microsoft-and-airbnb-4ef5fbcaec48">Volodymyr</a> was interested to gain more experience developing for companies and projects he could put on his resume after he graduates.  Through the fall and winter he contributed to lots of big projects: Firefox, Firefox Focus, Brave for iOS, VSCode, and more.  Eventually he found his favourite, <a href="https://medium.com/@volodymyrklymenko/contribution-to-lona-how-to-set-up-ruby-environment-on-macos-d8c7fb35433e">Airbnb's Lona project</a>.</p><p>With repeated success and a trail of merged PRs, Volodymyr described being able to slowly overcome his feelings of self doubt: "I wasn’t sure if I was good enough to work on these bugs." </p><p>A real turning point for him came with a <a href="https://twitter.com/dan_abramov/status/1090431078945484802?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1090431078945484802&amp;ref_url=https%3A%2F%2Fmedium.com%2Fmedia%2F3b0acef201cd2ef5b86aed4cce937248%3FpostId%3D4ef5fbcaec48">tweet from Dan Abramov</a>, announcing a project to localize the React documentation:</p><blockquote>I develop a lot using React, and I love this library a lot. I wanted to  contribute to the React community, and it was a great opportunity to do  it, so I applied for it. Shortly after it, the repository for Ukrainian  translation was created, and I was assigned to maintain it 🤠</blockquote><p>Over the next three months, Volodymyr took on that task of maintaining a <a href="https://github.com/reactjs/uk.reactjs.org/issues/1">very active and high-profile localization project</a> (96% complete as I write this), and in so doing learned all kinds of things about what it's like to be on the other side of a pull request, this time having to do reviews, difficult merges, learning how to keep community engaged, etc.  <a href="https://uk.reactjs.org/">Seeing the work ship</a> has been very rewarding.</p><p>Open source gives students a chance to show up, to take on responsibility, and become part of the larger community.  Having the opportunity to move from being a user to a contributor to a leader is unique and special.</p><h2 id="my-own-personal-learning">My Own Personal Learning</h2><p>Finally, I wanted to pause for a moment to consider some of the things I learned with this iteration of the courses.  In no particular order, here are some of the thoughts I've been having over the last week:</p><p>Mentoring 100+ students across 300+ projects and 28 programming languages is daunting for me.  Students come to me every day, all day, and ask for help with broken dev environments, problems with reviewers, issues with git, etc.  I miss having a single project where everyone works together, because it allows me to be more focused and helpful.  At the same time, the diversity of what the students did speaks to the value of embracing the chaos of open source in all its many incarnations.</p><p>Related to my previous point, I've felt a real lack of stable community around a lot of the projects the students worked in.  I don't mean there aren't people working on them.  Rather, it's not always easy to find ways to plug them in.  Mailing lists are no longer hot, and irc has mostly disappeared.  GitHub Issues usually aren't the right place to discuss things that aren't laser focused on a given bug, but students need places to go and talk about tools, underlying concepts in the code, and the like.  "What about Slack?"  Some projects have it, some don't.  Those that do don't always give invitations easily.  It's a bit of a mess, and I think it's a thing that's really missing.</p><p>Open source work on a Windows machine is still unnecessarily hard.  Most of my students use Windows machines.  I think this is partly due to cost, but also many of them simply like it as an operating system.  However, trying to get them involved in open source projects on a Windows machine is usually painful.  I can't believe how much time we waste getting basic things setup, installed, and building.  Please support Windows developers in your open source projects.</p><p>When we start the course, I often ask the students which languages they like, want to learn, and feel most comfortable using.  Over and over again I'm told "C/C++".  However, looking at the stats above, C-like languages only accounted for ~15% of all pull requests.  There's a disconnect between what students tell me they want to do, and what they eventually do.  I don't fully understand this, but my suspicion is that real-world C/C++ code is much more complicated than their previous academic work.</p><p>Every project thinks they know how to do open source the right way, and yet, they all do it differently.  It's somewhat hilarious for me to watch, from my perch atop 300+ repos.  If you only contribute to a handful of projects within a small ecosystem, you can start to assume that how "we" work is how "everyone" works.  It's not.  The processes for claiming a bug, making a PR, managing commits, etc. is different in just about every project.  Lots of them expect exactly the opposite behaviour!  It's confusing for students.  It's confusing for me.  It's confusing for everyone.</p><p>It's still too hard to match new developers with bugs in open source projects.  One of my students told me, "It was easier to find a husband than a good open source project to work in!"  There are hundreds of thousands of issues on GitHub that need a developer.  You'd think that 100+ students should have no problem finding good work to do.  And yet, I still find it's overly difficult.  It's a hard problem to solve on all sides: I've been in every position, and none of them are easy.  I think students waste a lot of time looking for the "right" project and "perfect" bug, and could likely get going on lots of things that don't initially look "perfect."  Until you have experience and confidence to dive into the unknown, you tend to want to work on things you feel you can do easily.  I need to continue to help students build more of this confidence earlier.  It happens, but it's not quick.</p><p>Students don't understand the difference between apps and the technologies out of which they are made.  Tools, libraries, frameworks, test automation--there is a world of opportunity for contribution just below the surface of visible computing.  Because these areas are unknown and mysterious to students, they don't tend to gravitate to them.  I need to find ways to change this.  Whenever I hear "I want to work on Android apps..." I despair a little.</p><p>Teaching open source in 2019 has really been a proxy for teaching git and GitHub.  While I did have some students work outside GitHub, it was really rare.  As such, students need a deep understanding of git and its various workflows, so this is what I've focused on in large part.  Within days of joining a project, students are expected to be able to branch, deal with remotes, rebase, squash commits, fix commit messages, and all sorts of other intermediate to advanced things with git.  I have to move fast to get them ready in time.</p><p>Despite all the horrible examples you'll see on Twitter, the open source community has, in large part, been really welcoming and kind to the majority of my students.  I'm continually amazed how much time maintainers will take with reviews, answering questions, and helping new people get started.  It's not uncommon for one of my students to start working on a project, and all of a sudden be talking to its creator, who is patiently walking them through some setup problem. Open source isn't always a loving place (I could tell you some awful stories, too).  But the good outweighs the bad, and I'm still happy to take students there.</p><h2 id="conclusion">Conclusion</h2><p>I'm ready for a break, but I've also had a lot of fun, and been inspired by many of my best students.  I'm hoping I'll be able to teach these courses again in the fall.  Until then, I'll continue to reflect on what worked and what didn't, and try to improve things next time.</p><p>In the meantime, I'll mention that I could use your support.  Doing this work is hard, and requires a lot of my time.  In the past I've had companies like Mozilla generously help me stay on track.  If you or your company would like to find ways to partner or support this work, please get in touch.  Also, if you're hiring new developers or interns, please consider hiring some of these amazing students I've been teaching.  I know they would be grateful to talk to you as well.</p><p>Thanks for your continued interest in what we're doing.  I see lots of you out there in the wild, doing reviews, commenting on pull requests, giving students a favourite on Twitter, leaving a comment in their blog.  Open source works because people take the time to help one another.</p>]]></content:encoded></item><item><title><![CDATA[The technology of nostalgia]]></title><description><![CDATA[<p>Today one of my first year web students emailed me a question:</p><blockquote>Today when I was searching some questions on StackOverflow, I found their website turns to a really interesting display and can be changed to the regular one back and forth by a button on the top. I guess</blockquote>]]></description><link>https://blog.humphd.org/the-technology-of-nostalgia/</link><guid isPermaLink="false">5ca23c3624511e03496b3aef</guid><category><![CDATA[mozilla]]></category><category><![CDATA[seneca]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Mon, 01 Apr 2019 17:04:01 GMT</pubDate><content:encoded><![CDATA[<p>Today one of my first year web students emailed me a question:</p><blockquote>Today when I was searching some questions on StackOverflow, I found their website turns to a really interesting display and can be changed to the regular one back and forth by a button on the top. I guess it's some April Fool's day joke...how did they make the mouse pointer thing? There are stars dropping and tracking the pointer when you move it, I was thinking of inspecting it to get a sense, but then I realized I usually use the pointer to click on an element for inspecting, but I can't click the mouse itself, so I'm lost...Here's a website to explain what I'm saying: <a href="https://stackoverflow.com/questions/1098040/checking-if-a-key-exists-in-a-javascript-object?rq=1">https://stackoverflow.com/questions/1098040/checking-if-a-key-exists-in-a-javascript-object?rq=1</a> Could you tell me how does that work, is this till done by CSS? or JS?</blockquote><p>I went to look, and here is an animation of what I found.  Notice the trail of stars behind my mouse pointer as it moves:</p><figure class="kg-card kg-image-card"><img src="https://blog.humphd.org/content/images/2019/04/stackoverflow-cursor.gif" class="kg-image"></figure><p>My first thought is that they must have a <code>mousemove</code> handler on the <code>body</code>.  I <a href="https://developers.google.com/web/tools/chrome-devtools/console/events#view_event_listeners_registered_on_dom_elements">opened the dev tools and looked through the registered event listeners</a> for <code>mousemove</code>.  Sure enough, there was one one registered on the <code>document</code>, and the code looked like this:</p><pre><code>function onMouseMove(e) {
    cursor.x = e.clientX;
    cursor.y = e.clientY;

    addParticle(
           cursor.x,
           cursor.y,
           possibleColors[Math.floor(Math.random()*possibleColors.length)]
    );
}</code></pre><p>Reading a bit further into the file revealed this comment:</p><pre><code>/*!
 * Fairy Dust Cursor.js
 * - 90's cursors collection
 * -- https://github.com/tholman/90s-cursor-effects
 * -- https://codepen.io/tholman/full/jWmZxZ/
 */</code></pre><p>This is using <a href="https://github.com/tholman/cursor-effects">tholman's cursor-effects JS library</a>, and specifically the <a href="https://github.com/tholman/cursor-effects/blob/master/js/fairyDustCursor.js">fairyDustCursor</a>.</p><p>This code is really fun to read, especially for my early web students.  It's short, readable, not unnecessarily clever, and uses really common things in interesting ways.  Almost everything it does, my students have seen before--they just might not have thought to put it all together into one package like this.</p><p>Essentially how it works is that <code>Partcle</code> objects are stored in an array, and each one gets added to the DOM as a <code>&lt;span&gt;*&lt;/span&gt;</code> with a different colour, and CSS is used to move (translate) each away from an origin (the mouse pointer's <code>x</code> and <code>y</code> position).  Over time (iterations of the <code>requestAnimationFrame</code> loop), each of these particles ages, and eventually dies, getting removed from the array and DOM.</p><p>As I read the code, something else struck me.  Both Stack Overflow and the cursor-effects library talk about this style of web site being from the 90s.  It's true, we didn't have the kind of refined and "delightful experiences" we take for granted today.  It was a lot of flashing, banner adds, high contrast colours, and people inventing (often badly) as they went.</p><p>Yet reading the code for how this effect was done, I couldn't help but pause to reflect on how modern it is at the same time.  Consider some of the browser APIs necessary to make this "90s" effect possible, and when they were first shipped (all dates are from <a href="https://caniuse.com">caniuse.com</a>):</p><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector"><code>querySelector</code> c. 2008 WebKit</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d"><code>translate3d</code> c. 2009 WebKit</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/touchstart_event"><code>touchstart</code> event c. 2009 Google</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame"><code>requestAnimationFrame</code> c. 2010 Mozilla</a></li><li><code><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events">pointer-events</a></code>, <code><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action">touch-action</a></code> c. 2012 Microsoft</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/will-change"><code>will-change</code> c. 2014 Google</a></li></ol><p>The progress that's been made on the web in the past 10 years is incredible.  In 2019 it only takes a few lines of code to do the kind of creative things we struggled with in 1999.  The web platform has evolved to something really great, and I love being part of it.</p>]]></content:encoded></item><item><title><![CDATA[Browsing open source projects]]></title><description><![CDATA[<p>This week I've asked my open source students to research three new (to them) projects.  In the spirit of walking-the-talk, I wanted to share three that I found recently.</p><p>I'm constantly looking at new projects and repos.  I love <a href="https://github.com/trending">GitHub's Trending</a> feed, and discovering new things via Twitter, podcasts, and</p>]]></description><link>https://blog.humphd.org/browsing-open-source-projects/</link><guid isPermaLink="false">5c59b0dd6b6baf39f0b1bc86</guid><category><![CDATA[seneca]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Tue, 05 Feb 2019 17:12:03 GMT</pubDate><content:encoded><![CDATA[<p>This week I've asked my open source students to research three new (to them) projects.  In the spirit of walking-the-talk, I wanted to share three that I found recently.</p><p>I'm constantly looking at new projects and repos.  I love <a href="https://github.com/trending">GitHub's Trending</a> feed, and discovering new things via Twitter, podcasts, and blog posts.  Partly I'm just curious, and love to find inspiration in other people's work.  And partly I'm always shopping for new places that my students can get involved.  Helping hundreds of students find open source projects each year is a full-time job.</p><p>Without further ado, here are the projects I wanted to discuss:</p><ol><li>The <a href="https://buttercup.pw/">Buttercup password manager</a></li><li>The <a href="https://github.com/OpenRCT2/OpenRCT2">Open Railroad Tycoon 2 game</a></li><li>The <a href="https://svelte.technology/">Svelte UI Framework</a></li></ol><h3 id="buttercup">Buttercup</h3><p>I'm a huge fan of password managers.  I myself use <a href="https://1password.com/">1Password</a>, and have purchased the <a href="https://1password.com/families/">Family Plan</a> so everyone in our house can use it, safely share accounts, sensitive documents, sync between all our devices, etc.  However, not everyone needs all these features, nor does it make sense for everyone to take on the subscription cost. </p><p>Luckily there are a number of good free and/or open alternatives to 1Password.  One that I've recently learned about is <a href="https://buttercup.pw/">Buttercup</a>.  I first learned about it via <a href="https://changelog.com/podcast/325">this Changelog podcast episode</a>.  In it, one of the two core maintainers of Buttercup, <a href="https://github.com/perry-mitchell">Perry Mitchell</a>, discuss the history and future of the project.</p><p>The scope and quality of the project is really striking, with desktop clients for every OS, mobile apps, and browser extensions, all of which look beautiful.</p><figure class="kg-card kg-image-card"><img src="https://buttercup.pw/static/img/desktop.png" class="kg-image"><figcaption>Buttercup desktop (Electron) client</figcaption></figure><p>The project is built using React, Electron, React-Native, and also includes encryption code in Rust and WebAssembly.  Very often I have students tell me that they want to work on something that <em>uses</em> React vs. contributing to React itself, and in my experience, it can hard to find projects like this.  Everyone uses it, but not everyone who uses it does so in an open source context.  Similarly, people want to work on mobile apps, or tell me they want to try something with Rust.  Having so much of this modern tech all in one project is great.  </p><p>I also really like how the whole thing is split up into an <a href="https://github.com/buttercup">ecosystem of separate apps, tools, and repos</a>.  There are lots of ways someone could get involved without having to necessarily take on the whole thing.  Right now there are <a href="https://github.com/search?q=org%3Abuttercup&amp;state=open&amp;type=Issues">232 open issues</a> across all these repos--plenty of opportunity for a few students to dive in and make a contribution.</p><h3 id="openrtc2">OpenRTC2</h3><p>The second project I wanted to mention is one I <a href="https://twitter.com/gitstartracker/status/1092410450824835072">recently saw via Twitter</a>, an <a href="https://openrct2.io/">open source remake</a> of the popular game RollerCoaster Tycoon 2.  I don't play many games, but many of my students do, and this is what caught my interest.  </p><figure class="kg-card kg-image-card"><img src="https://camo.githubusercontent.com/888d993a9716208446bd0d5a762977d6b7993058/68747470733a2f2f692e696d6775722e636f6d2f6537434b3553632e706e67" class="kg-image"></figure><p>OpenRTC2 is a fairly big project, with <a href="https://www.openhub.net/p/OpenRCT2">roughly half-a-million lines of C/C++ code</a>, and a very <a href="https://github.com/OpenRCT2/OpenRCT2/graphs/contributors">active developer</a> and <a href="https://openrct2.org/forums/">user community</a>.  There are <a href="https://github.com/OpenRCT2/OpenRCT2/wiki">great docs</a> and lots of <a href="https://github.com/OpenRCT2/OpenRCT2/issues">open issues (944)</a>, with some even <a href="https://github.com/OpenRCT2/OpenRCT2/issues?q=is%3Aissue+is%3Aopen+label%3A&quot;good+first+issue&quot;">labelled as good first issue</a>.</p><p>Because our students study C/C++ for 3 terms before they get to the open source courses, a lot of them tell me that they want to work on something in C++.  However, when I show them possible projects, the code often overwhelms them because there is too much of a gap between their academic experience and real-world C++.  Also, the projects written in C++ can often be very low level, abstract, and difficult to use in ways that are easy for a beginner to understand, or only work on particular platforms.  With OpenRTC2, a lot of these problems are less of an issue, with the game running on every OS, and the "build" being relatively easy and fun to test.</p><h3 id="svelte">Svelte</h3><p>The last project I wanted to discuss is one I also <a href="https://changelog.com/podcast/332">heard about via a podcast</a>.  <a href="https://svelte.technology/">Svelte</a> is a framework-less UI framework.  I've heard about it in the past, but never used it, or dug into the project in any depth.  Listening to <a href="https://twitter.com/Rich_Harris">Rich Harris</a> discuss the <a href="https://github.com/sveltejs/svelte/projects/3">upcoming 3.0 release</a>, I got really interested in the approach.  Where React and Vue update UI by applying runtime diffs between a virtual DOM and the real DOM, Svelte takes a <a href="https://svelte.technology/guide">different approach</a>: using compile time analysis to generate pure JavaScript UI code that doesn't need a runtime framework.</p><p>For work that I'm about to start on some UI components, I've been looking for a way to write code that isn't necessarily React, Vue, Angular, etc. but could be used in those frameworks, or in a vanilla DOM app.  Svelte seems like a good middle road for building something that can work in a lot of different contexts.</p><p>The community is a lot smaller than React or Vue, which you could view as a good or bad thing.  I think it's good from the standpoint of someone wanting to contribute, because there is a bit less pressure on the issues.  The community uses <a href="https://discordapp.com/invite/yy75DKs">Discord for real-time chat</a>, which is nice for contributors wanting to get a question answered.  There are <a href="https://github.com/search?q=org%3Asveltejs&amp;state=open&amp;type=Issues">lots of open issues</a> across all the various repos in the ecosystem.  Like Buttercup, the project is <a href="https://github.com/sveltejs">split into many separate, smaller repos</a>.</p>]]></content:encoded></item><item><title><![CDATA[Credit where credit's due]]></title><description><![CDATA[<p>This past week one of my open source students was presenting on a bug she'd fixed in a big project.  Toward the end of her demo, she made an off-hand comment about how a maintainer had included her fix, but not the commit itself.  Her code found its way into</p>]]></description><link>https://blog.humphd.org/credit-where-credits-due/</link><guid isPermaLink="false">5c4e5b3f6b6baf39f0b1bc60</guid><category><![CDATA[seneca]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Mon, 28 Jan 2019 01:48:04 GMT</pubDate><content:encoded><![CDATA[<p>This past week one of my open source students was presenting on a bug she'd fixed in a big project.  Toward the end of her demo, she made an off-hand comment about how a maintainer had included her fix, but not the commit itself.  Her code found its way into the project, but she didn't.</p><p>This is problematic on a number of levels.  IANAL, so I won't spend a lot of time diving into the legal and copyright issues.  However, I did want to say something practical about the community side of this.</p><p>When new people contribute to a project, part of what they're after is the chance to belong, to show up in the credits, and to be seen to be capable of doing work at this level.  It's an important signal.  I can't tell you how many former students come back to tell me about what it's like applying to jobs when you already have a significant open source contribution history.  One story I love: a former student was in an interview with 3 senior dev leads, and one asked: "What kind of software have you worked on?"  She causally pointed to his monitor, which was running VSCode.  "That," she pointed.  Enough said.</p><p>A developer who has been doing this day-in and day-out can become blasé about the whole thing.  Facebook's devs <a href="https://twitter.com/Grady_Booch/status/1089614371439800320">land 100K commits a week</a>, for example; so what's one more?  If it's your first, or represents a major step forward, I think it's important that it get treated with some care and respect.</p><p>To that end, I wanted to take a moment to point out to my colleagues the usefulness of <a href="https://help.github.com/articles/creating-a-commit-with-multiple-authors/">GitHub's <code>Co-authored-by</code> commit message parsing</a>.  In cases where you've somehow lost the original author info, this can allow you to still leave a note that more than one person worked on this.  All you need to do is structure your commit message like so:</p><pre><code>Fixing bug xyz

Co-authored-by: &lt;name@example.com&gt;
Co-authored-by: another-name &lt;another-name@example.com&gt;</code></pre><p>In GitHub, the commit will show all the various people involved in the work. It's a small thing, but it's really easy to add, and in so doing, visibly welcome someone into your project and community.</p>]]></content:encoded></item><item><title><![CDATA["I want to learn how to maintain software"]]></title><description><![CDATA[<p>I wanted to pause for a moment in order to reflect on one of the more interesting things I heard from a student last week.  I often begin my open source classes by asking students why they are there.  What is "open source", I want to know, since most haven't</p>]]></description><link>https://blog.humphd.org/i-want-to-learn-how-to-maintain-software/</link><guid isPermaLink="false">5c3e256d6b6baf39f0b1bbce</guid><category><![CDATA[seneca]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Tue, 15 Jan 2019 19:14:37 GMT</pubDate><content:encoded><![CDATA[<p>I wanted to pause for a moment in order to reflect on one of the more interesting things I heard from a student last week.  I often begin my open source classes by asking students why they are there.  What is "open source", I want to know, since most haven't done it before, and I'm curious why they've chosen to learn it.  Often I'm told that people want to learn new technology, gain experience, add interesting projects to their resume, etc; all excellent answers.</p><p>But this time, one woman put up her hand and said something I don't usually hear: <em>"I want to learn how to maintain software."</em>  Amazing.  What a thing to be aware of while still in school.  My experience is that most students (and professors) haven't had to deal with programs outside the context of an assignment; and assignments are never maintained.  Get something working (anything!) and hand it in before the deadline.  That's how software's built, right?</p><p>Truth be told, a lot of it is.  In much the same way that we do when creating our built environment, the demands of software projects require us to borrow heavily, and incur large amounts of <a href="https://en.wikipedia.org/wiki/Technical_debt">technical debt</a>.  "<a href="https://www.linkedin.com/pulse/arent-any-typos-essay-we-launched-too-late-reid-hoffman">If you're not embarrassed by your software, you waited too long to ship.</a>"  Catching up with that debt, iterating on your product, getting feedback from users, dealing with security issues, adding localization data, updating against shifting APIs, evolving regulation--software is never finished, and software can't possible continue to work without being maintained.</p><p>This last point can be <a href="https://twitter.com/stevekrouse/status/1083909584530653184?s=03">hard to understand if you don't work on software</a>.  It's not hard to understand why, since we prefer buzzword-compliant and aspirational descriptions of technology to what it's really like.  Let's be honest, "smart TV" sounds a lot better in the marketing material than discussing how none of the software will work with existing services, or your new phone, in 3 years.  In 2019 <em>all</em> of our devices are now <em>smart</em> in a way they didn't seem to be 20 years ago.  Very little changed with regard to how we build software in that same period.</p><p>I'm really fed up with the current fetish for INNOVATION, the worship of NEW, and the complete lack of honesty about the future and where this tech will be in 2 years.  We've been fooled by a conjurer's trick, and mistaken <em>fast</em> for <em>smart</em>: computers do things quickly, not intelligently.  Your computer, and all of its software, are incapable of adjusting to the changing environments in which they are used.  What they do, they do quickly.  But doing the wrong thing quickly is not smart.  Unless you point things in the right direction, moving fast doesn't get you where you need to go. At this point I don't even need to give you examples, <a href="https://twitter.com/internetofshit?lang=en">every one of us has been burned at some point already</a>.</p><p>Keeping software tuned to the <em>current</em> demands of users, and the ecosystems in which it runs, is something we need to talk about more.  It doesn't happen by prefixing a product name with SMART.  Rather, we have to carefully cajole legacy software into working with new code.  It's hard to do well, and it's an ongoing need.</p><p>For my students learning open source, there exists an interesting opportunity to get their hands dirty working in new and old code simultaneously.  Another of my students this week told me <a href="https://mordax.io/blog/seneca/2019/01/11/On-New-Open-Source-Projects.html">how excited she was to work on the Apache Web Server</a>, because she was so curious how you kept a project going across decades.  I understand what she sees here, and it's the same reason I keep coming back to the web and web browsers as my own source of inspiration.  Technology that doesn't vanish after being suddenly INNOVATED into existence has the potential to become core infrastructure, and change society.  To me, that's really exciting.</p><p>Working to maintain software is an incredible way to learn how both the old and the new work.  You end up having to understand both worlds, and it makes you a strong developer as a result.  "Surely someone has solved this already."  They have.  "Surely there's a better way than this."  There is.</p><p>Not all software needs to live forever.  There's a lot of code I'm happy to never have to use again.  The code that does last does so for reasons worth exploring.  Increasingly, that code is also open, and accessible to those who would come and get involved.  It has to be, because trying to maintain code for a long time is a team sport.  For example, I loved reading this week about the <a href="https://lwn.net/SubscriberLink/776435/664f2f0b0b6fc9f5/">work in the Linux Kernel to prepare for the year-2038 bug</a>.</p><p>If you want to learn about how to maintain software, get involved with open source software and learn how they keep the lights on year after year.  That's what I'll be doing this term.</p><p>On that note, I'm particularly interested in finding good projects for my students to work on that involve helping to maintain vs. create new tech.  There's been lots of talk of the <a href="https://medium.com/@nodejs/call-to-action-accelerating-node-js-growth-e4862bee2919">need for this</a> recently, and it is only going to increase.  I'd love to have better visibility into projects that need help doing this kind of work, beyond the "help needed" and "good first bug" labels everyone uses.  If you have a need, and want some people to join you in maintaining something, get in touch.  My students are looking for projects.</p>]]></content:encoded></item><item><title><![CDATA[Processing.js 2008-2018]]></title><description><![CDATA[<p>Yesterday <a href="https://twitter.com/TheRealPomax">Pomax</a> DM'ed me on Twitter to let me know he'd <a href="https://twitter.com/TheRealPomax/status/1068942375970435073">archived the Processing.js GitHub repo</a>.  He's been maintaining it mostly on his own for quite a while, and now with the amazing <a href="https://p5js.org/">p5js</a> project, there isn't really a need to keep it going.</p>
<p>I spent the rest of</p>]]></description><link>https://blog.humphd.org/processing-js-2008/</link><guid isPermaLink="false">5c048f238ee42603d33e3a51</guid><category><![CDATA[seneca]]></category><category><![CDATA[mozilla]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Mon, 03 Dec 2018 04:12:00 GMT</pubDate><content:encoded><![CDATA[<p>Yesterday <a href="https://twitter.com/TheRealPomax">Pomax</a> DM'ed me on Twitter to let me know he'd <a href="https://twitter.com/TheRealPomax/status/1068942375970435073">archived the Processing.js GitHub repo</a>.  He's been maintaining it mostly on his own for quite a while, and now with the amazing <a href="https://p5js.org/">p5js</a> project, there isn't really a need to keep it going.</p>
<p>I spent the rest of the day thinking back over the project, and reflecting on what it meant to me.  Like <a href="https://johnresig.com/blog/processingjs-aftermath/">everyone else</a> in May 2008, I was in awe when John Resig wrote his famous <a href="https://johnresig.com/blog/processingjs/">reverse birthday present blog post</a>, showing the world what he'd been hacking together:</p>
<blockquote>
<p>I've decided to release one of my largest projects, in recent memory. Processing.js is the project that I've been alluding to for quite some time now. I've ported the Processing visualization language to JavaScript, using the Canvas element. I've been working on this project, off-and-on now, for the past 7 months.</p>
</blockquote>
<p>It was nothing short of epic.  I had followed the development of Processing since I was an undergrad.  I remember stumbling into the <a href="http://acg.media.mit.edu/">aesthetics + computation group</a> website at MIT in my first year, and becoming aware of the work of <a href="http://acg.media.mit.edu/people/fry/">Ben Fry</a>, <a href="http://plw.media.mit.edu/people/maeda/">John Maeda</a>, <a href="http://acg.media.mit.edu/people/creas/">Casey Reas</a> and others.  I was smitten.  As a student studying both humanities and CS, I didn't know anyone else who loved computers <em>and</em> art, and here was an entire lab devoted to it.  For many years thereafter, I followed along from afar, always amazed at the work people there were doing.</p>
<p>Then, in the fall of 2009, as part of my work with Mozilla, <a href="https://en.wikipedia.org/wiki/Christopher_Blizzard">Chris Blizzard</a> approached me about helping Al MacDonald (f1lt3r) to work on getting Processing.js to 1.0, and adding the missing 3D API via WebGL.  In the lead-up to Firefox 3.7, Mozilla was interested in getting more canvas based tech on the web, and in finding performance and other bugs in canvas and WebGL.  Processing.js, they thought, would help to bring a community of artists, designers, educators, and other visual coders to the web.</p>
<p>Was I interested!?  Here was a chance to finally work alongside some of my technical heroes, and to get to contribute to a space I'd only ever looked at from the other side of the glass.  &quot;Yes, I'm interested.&quot;  I remember getting my first email from Ben, who started to explain what Processing was--I didn't need any introductions.</p>
<p>That term I used Processing.js as the main open source project in my open source class.  As Al and I worked on the code, I taught the students how things worked, and got them fixing small bugs.  The code was not the easiest first web project for students: take a hybrid of Java and make it work, unmodified, in the browser, using DOM and canvas APIs.  This was before transpilers, node, and the current JS ecosystem.  If you want to learn the web though, there was no better way than to come at it from underneath like this.</p>
<p>I had an energetic group of students with a nice set of complimentary skills.  A few had been working with <a href="https://twitter.com/vvuk">Vlad</a> on 3D in the browser for a while, as he developed what would become WebGL.  Andor Salga, Anna Sobiepanek, Daniel Hodgin, Scott Downe, Jon Buckley, and others would go on to continue working on it with me in our open source lab, CDOT.</p>
<p>Through 2009-11 we worked using the methods I'd learned from Mozilla: open bug tracker, irc, blogs, wikis, weekly community calls, regular dot-releases.</p>
<p>Because we were working in the open, and because the project had such an outsized reputation thanks to the intersections of &quot;Ben &amp; Casey&quot; and Resig, all kinds of random (and amazing) people showed up in our irc channel.  Every day someone new from the who's who of design, graphics, gaming, and the digital art worlds would pop in to show us a demo that had a bug, or to ask a question about how to make something work.  I spent most of my time helping people debug things, and writing tests to put back into the project for performance issues, parser bugs, and API weirdness.</p>
<p>One day a musician and digital artist named <a href="https://github.com/corbanbrook">Corban Brook</a> showed up.  He used Processing in his work, and was interested to help us fix some things he'd found while porting an old project.  He never left.  Over the months he'd help us rewrite huge amounts of the code, taught us git, and become a big brother to many of the students.  I learned a ton from him about git and JS.</p>
<p>Then there was the time this mathematician came into the channel, complaining about how poor our font code and bezier curve implementation.  It turned out <a href="https://pomax.github.io/bezierinfo/">he knew what he was talking about</a>, and we never let him leave either.  Pomax would go on to become one of the most important maintainers on the project, and a long time friend.</p>
<p>Another time an unknown nickname, &quot;notmasteryet,&quot; appeared.  He started submitting massive pull requests, but never really said anything.  At one point he rewrote our entire Java-to-JavaScript parser from scratch and magically fixed hundreds of bugs we couldn't solve.  &quot;notmasteryet&quot; turned out to be <a href="https://github.com/yurydelendik">Yury Delendik</a>, who would go on to join Mozilla and build every cool thing you've seen the web do in the past 10 years (<a href="https://github.com/mozilla/pdf.js">pdf.js</a>, <a href="https://github.com/mozilla/shumway">shumway</a> to name a few).</p>
<p>Being part of this eclectic mix of hackers and artists was intoxicating.  Whatever skill one of you lacked, others in the group had it.  At one point, the conversation moved toward how to use the browser to mix audio and visuals with processing.js.  I had no idea how sound worked, but I did understand how to hack into Gecko and get the data, Corban was a master with FFTs, Al knew how to make the visuals work, and Yury knew everything the rest of us didn't.</p>
<p>We <a href="https://blog.humphd.org/vocamus-914/">set out to see if we could connect all the dots</a>, and began hacking on a new branch of our code that used a version of Firefox I modified to emit audio events.  Our work would eventually be shipped in Firefox 4 as the <a href="https://wiki.mozilla.org/Audio_Data_API">Audio Data API</a>, and lead to what is now the <a href="https://blog.humphd.org/vocamus-1626/">standardization of the Web Audio AI</a>.  I still remember the first time we got all of our pieces working together in the browser, and <a href="https://vimeo.com/8525101">Corban filmed it</a>.  Magic!</p>
<p>From there the group only got larger, and the ideas for processing.js more ambitious.  With the addition of people like <a href="https://twitter.com/ccliffe">CJ</a> and <a href="https://twitter.com/secretrobotron">Bobby</a>, we started <a href="https://www.youtube.com/watch?v=1Uw0CrQdYYg">building big demos for Mozilla</a>, which doubled as massive performance tests for browsers trying to compete for speed with WebGL: <a href="https://www.youtube.com/watch?v=rSSf_umjOgU">Flight of the Navigator</a>, <a href="https://www.youtube.com/watch?v=FsTXlcENeVo">No Comply</a>.  And these led to yet more browser APIs for gaming, like <a href="https://blog.humphd.org/vocamus-1393/">Pointer Lock</a> and <a href="https://www.w3.org/TR/gamepad/">Gamepad</a>.</p>
<p>Since then it's been amazing to watch all the places that processing.js has gone.  Twitter has always been full of people discovering it, and sharing their work, not least because of <a href="https://www.khanacademy.org/computer-programming/new/pjs">John and Khan Academy using it there in their curriculum</a>.  Years later, I even got to use it there <a href="https://blog.humphd.org/vocamus-1632/">with my own children</a> to teach them to code.</p>
<p>I truly loved working on processing.js, probably more than any other project I've done in the past 10 years.  It was my favourite kind of software to build for a few reasons:</p>
<ul>
<li>we were implementing Ben's spec.  All of our tests and decisions were based on &quot;what does p5 do?&quot;  The freedom not to have to decide, but to simply execute, was liberating.</li>
<li>we had an enormous amount of pre-existing code to test, and slowly make work.  There's no way I could have built processing.js from zero.  But I love porting everyone's existing projects.</li>
<li>the project was <a href="https://blog.humphd.org/vocamus-984/">totally based on tests</a>: unit tests, performance tests, visual snapshot/ref tests, parser tests.  I learned how to think about code in terms of tests by working on Mozilla, but I learned to love tests through processing.js</li>
<li>it could be run without installing anything.  Every time we made something new work, you just had to hit Refresh in your browser.  That sounds so obvious, but for the community of Java devs coming to the web via processing.js, it was eye opening.</li>
<li>we could put time and attention into <a href="http://processingjs.org/reference/">docs, examples, and guides</a>.  Casey and Ben had done so much of this, and we learned a lot from his approach and style.</li>
<li>it let me move up and down the web stack.  I spent as much time working on performance issues in Firefox as I did in JavaScript.  We found a ton of things in WebGL (I was even able to find and get a security bounty for a bug with TypedArrays).  I remember once sitting with Boris Zbarsky in Boston, and having him teach me, slowly, how to figure out why our code was falling off of the JIT tracing, and how to fix it.  Eventually we got back on JIT, thanks to bz :)</li>
</ul>
<p>While it's definitely time for processing.js to be archived and other projects to take its place, I wanted to at least say a proper goodbye.  I'm thankful I got to spend so many years working in the middle of it, and to have had the chance to work with such a creative part of the internet.</p>
<p>Thanks, too, to Pomax for keeping the lights on years after the rest of us had gone to other projects.</p>
<p>And to processing.js, goodnight.  Thanks for all the unit tests.</p>
]]></content:encoded></item><item><title><![CDATA[Observations on Hacktoberfest 2018]]></title><description><![CDATA[<p>This term I'm teaching two sections of our Topics in Open Source Development course.  The course aims to take upper-semester CS students into open source projects, and get them working on real-world software.</p>
<p>My usual approach is to put the entire class on the same large open source project.  I</p>]]></description><link>https://blog.humphd.org/observations-on-hacktoberfest-2018/</link><guid isPermaLink="false">5bde39098ee42603d33e3a4b</guid><category><![CDATA[seneca]]></category><category><![CDATA[mozilla]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Sun, 04 Nov 2018 01:53:30 GMT</pubDate><content:encoded><![CDATA[<p>This term I'm teaching two sections of our Topics in Open Source Development course.  The course aims to take upper-semester CS students into open source projects, and get them working on real-world software.</p>
<p>My usual approach is to put the entire class on the same large open source project.  I like this method, because it means that students can help mentor each other, and we can form a shadow-community off to the side of the main project.  Typically I've used Mozilla as a place to do this work.</p>
<p>However, this term I've been experimenting with having students work more freely within open source projects on GitHub in general.  I also wanted to try encouraging students to work on <a href="https://hacktoberfest.digitalocean.com/details">Hacktoberfest</a> as part of their work.</p>
<h3 id="hacktoberfest">Hacktoberfest</h3>
<p><a href="https://hacktoberfest.digitalocean.com/details">Hacktoberfest</a> is a yearly event sponsored by <a href="https://www.digitalocean.com/">DigitalOcean</a>, <a href="https://www.twilio.com/">Twilio</a>, and <a href="https://github.com/">GitHub</a>, which encourages new people to get involved in open source.  Submit five pull requests on GitHub during October, get a T-Shirt and stickers.  This year, many companies have joined in and offered to also give extra swag or prizes if people fix bugs in their repos (e.g., <a href="https://open.microsoft.com/2018/09/18/hacktoberfest-2018-microsoft/">Microsoft</a>).</p>
<p>Some of my students have done Hacktoberfest in the past and enjoyed it, so I thought I'd see what would happen if I got all my students involved.  During the month of October, I asked my students to work on 1 pull request per week, and also to write a blog post about the experience, what they learned, what they fixed, and to share their thoughts.</p>
<h3 id="results">Results</h3>
<p>Now that October has ended, I wanted to share what <em>I learned</em> by having my students do this.  During the month I worked with them to answer questions, support their problems with git and GitHub, explain build failures on Travis, intervene in the comments of pull requests, etc.  Along the way I got to see what happens when a lot of new people suddenly get thrust into open source.</p>
<p><a href="https://github.com/humphd/hacktoberfest-at-seneca-2018/wiki/Student-Submissions">You can find all the PRs and blog posts here</a>, but let me take you through some raw numbers and interesting facts:</p>
<ul>
<li><strong>61 Students</strong> began Hacktoberfest and <strong>91%</strong> were able to finish the required 5 PRs, three completed 6, and <a href="https://medium.com/seanprashad/hacktoberfest-2018-the-recap-d9b706a9fd61">one student completed 10</a>.</li>
<li><strong>307 Pull Requests</strong> were made to <strong>180 repositories</strong>.  As of Nov 1, <strong>53% of these have already been merged</strong>.</li>
<li><strong>42,661</strong> lines of code were added, <strong>10,387</strong> lines deleted in <strong>3,465 files</strong>.  Small changes add up.</li>
<li>The smallest PR was a <strong>fix for a single character</strong>, the largest added <strong>10K lines</strong> by refactoring an iOS project to use a new Swift networking library (NOTE: there were a few <em>really</em> large PRs which I haven't included, because they were mostly generated files in the form of <code>node_modules</code>).  Many PRs fixed bugs by simply deleting code.  <em>&quot;Sir, are you sure this counts?&quot;</em>  Yes, it most certainly does.</li>
</ul>
<p>One of the things I was interested in seeing was which languages the students would choose to work in, when given the choice.  As a result, I tried to keep track of the languages being used in PRs.  In no particular order:</p>
<ul>
<li>Rust</li>
<li>Swift</li>
<li>Scala</li>
<li>JavaScript</li>
<li>React</li>
<li>node.js</li>
<li>Markdown</li>
<li>PHP</li>
<li>Lua</li>
<li>Localization files (many types, many, many Natural languages)</li>
<li>JSON</li>
<li>C#</li>
<li>C++</li>
<li>Java</li>
<li>Go</li>
<li>Ruby</li>
<li>Python</li>
<li>HTML, CSS</li>
<li>Solidity (Etherium)</li>
</ul>
<p>I was also interested to see which projects the students would join.  I'll discuss this more broadly below, but here are some of the more notable projects to which I saw the students submit fixes:</p>
<ul>
<li>TravisCI</li>
<li>Microsoft VSCode</li>
<li>Mozilla Focus for iOS</li>
<li>Mozilla Addons (Frontend)</li>
<li>Brave for iOS</li>
<li>Handbrake</li>
<li>Ghost (blog platform)</li>
<li>Pandas</li>
<li>Keras</li>
<li>Jest</li>
<li>Monaco Editor</li>
<li>Microsoft (documentation for various projects)</li>
<li>Auth0</li>
<li>30 Seconds of Code</li>
<li>Angular Material</li>
<li>Oh my zsh</li>
</ul>
<p>A number of students did enough work in the project that they were asked to become collaborators.  In two cases, the students were asked to <em>take over</em> the project and become maintainers!  Careful what you touch.</p>
<h3 id="observations">Observations</h3>
<p>I think the most valuable feedback comes from the student blogs, which I'll share quotes from below.  Before I do that, let me share a few things that I observed and learned through this process.</p>
<ol>
<li>
<p>Because Hacktoberfest is a bit of a game, people game the system.  I was surprised at the number of &quot;Hacktoberfest-oriented&quot; repos I saw.  These were projects that were created specifically for Hacktoberfest in order to give people an easy way to contribute; or they were pre-existing but also provided a way to get started I hadn't foreseen.  For example:</p>
<ul>
<li><a href="https://github.com/jsonmc/jsonmc">JSON database of movie metadata</a></li>
<li><a href="https://github.com/Showndarya/Hacktoberfest">Collection of words</a></li>
</ul>
<p>I'll admit that I was not anticipating this sort of thing when I sent students out to work on open source projects.  However, after reading their blog posts about the experience, I have come to the conclusion that for many people, just gaining experience with git, GitHub, and the mechanics of contribution, is valuable no matter the significance of the &quot;code.&quot;</p>
</li>
<li>
<p>For those students who focused too much on repos like those mentioned above, there was often a lot of frustration, since the &quot;maintainers&quot; were absent and the &quot;community&quot; was chaotic.  People would steal issues from one another, merges would overwrite previous contributions, and there was little chance for personal growth.  I saw many people tire of this treatment, and eventually decide, on their own, that they needed a better project.  Eventually, the &quot;easy&quot; way became too crowded and untenable.</p>
</li>
<li>
<p>Finding good bugs to work on <a href="https://blog.humphd.org/why-good-first-bugs-often-arent/">continues</a> to be <a href="https://blog.humphd.org/experiments-with-good-first-experience/">hard</a>.  There are hundreds-of-thousands of bugs labeled &quot;Hacktoberfest&quot; on GitHub.  But my students eventually gave up trying to use this label to find things.  There were too many people trying to jump on the same bugs (~46K people participated in Hacktoberfest this year).  I know that many of the students spent as much time looking for bugs as they did fixing them.  This is an incredible statement, given that they are millions of open bugs on GitHub.  The open source community in general needs to do a much better job connecting people with projects.  Our current methods don't work.  If you already <em>know</em> what you want to work on, then it's trivial.  But if you are truly new (most of my students were), it's daunting.  You should be able to match your skills to the kinds of work happening in repos, and then find things you can contribute toward.  GitHub needs to do better here.</p>
</li>
<li>
<p>A lot of my students speak more than one language, and wanted to work on localization.  However, Hacktoberfest only counts work done in PRs toward your total.  Most projects use third-party tools (e.g., <a href="https://www.transifex.com/">Transifex</a>) outside of GitHub for localization.  I think we should do more to recognize localization as first-order contribution.  If you go and translate a big part of a project or app, that should count toward your total too.</p>
</li>
<li>
<p>Most of the students participated in three or more projects vs. focusing in just one.  When you have as many students as I do all moving in and out of new projects, you come to realize how different open source projects are.  For example, there are very few standards for how one &quot;signs up&quot; to work on something: some projects wanted an Issue; some wanted you to open a WIP PR with special tags; some wanted you to get permission; some wanted you to message a bot; etc.  People (myself included) tend to work in their own projects, or within an ecosystem of projects, and don't realize how diverse and confusing this can be for new people.  A project being on GitHub doesn't tell you that much about what the expectations are going to be, and simply having a <code>CONTRIBUTING.md</code> file isn't enough.  Everyone has one, and they're all different!</p>
</li>
</ol>
<h3 id="quotesfromstudentblogswhatamonth">Quotes from Student Blogs: &quot;What. A. Month!&quot;</h3>
<p>More than the code they wrote, I was interested in the reflections of the students as they moved from being beginners to feeling more and more confident.  You can find <a href="https://github.com/humphd/hacktoberfest-at-seneca-2018/wiki/Student-Submissions">links to all of the blog posts and PRs here</a>.  Here are some examples of what it was like for the students, in their own words.</p>
<h4 id="differentapproachestogettingstarted">Different approaches to getting started</h4>
<p>Many students began by choosing projects using tech they already knew.</p>
<blockquote>
<p>&quot;I decided to play to my strengths, and look at projects that had issues recommended for beginners, as well as developed in python&quot;</p>
</blockquote>
<blockquote>
<p>&quot;Having enjoyed working with Go during my summer internship, I was like: Hey, let's look for a smaller project that uses Go!&quot;</p>
</blockquote>
<p>Others started with something unknown, new, and different.</p>
<blockquote>
<p>&quot;my goal for this month is to contribute to at least two projects that use Rust&quot;</p>
</blockquote>
<blockquote>
<p>&quot;I'm in a position where I have to learn C# for another project in another course, so the first thing I did was search up issues on Github that were labeled 'hacktoberfest' and uses the C# language.&quot;</p>
</blockquote>
<blockquote>
<p>&quot;My first pull request was on a new language I have not worked with before called Ruby...I chose to work with Ruby because it was a chance to work with something that I have not worked with before.&quot;</p>
</blockquote>
<p>I was fascinated to see people evolve over the five weeks, and some who were scared to venture out of familiar territory at first, ended up in something completely new by the end.</p>
<blockquote>
<p>&quot;After I completed my pull request, I felt very proud of myself because I learned a new language which I did not think I was able to do at the beginning of this.&quot;</p>
</blockquote>
<blockquote>
<p>&quot;I was able to learn a new programming language, Python, which was something I always wanted to do myself. If it wasn't for Hacktoberfest, I might keep procrastinating and never get started.&quot;</p>
</blockquote>
<h4 id="overcomingimpostorsyndrome">Overcoming Impostor Syndrome</h4>
<p>Perhaps the single greatest effect of working on five PRs (vs. one or two), is that it helped to slowly convince people that they despite how they felt initially, they could in fact contribute, and did belong.</p>
<blockquote>
<p>&quot;Everyone posting here (on GitHub) is a genius, and it's very daunting.&quot;</p>
</blockquote>
<blockquote>
<p>&quot;In the beginning, I am afraid to find issues that people post on GitHub.&quot;</p>
</blockquote>
<blockquote>
<p>&quot;As I am looking at the C code I am daunted by the sheer size of some of the function, and how different functions are interacting with each other. This is surprisingly different from my experience with C++, or Object Oriented Programming in general.&quot;</p>
</blockquote>
<p>Small successes bring greater confidence:</p>
<blockquote>
<p>&quot;Fixing the bug wasn't as easy as I thought it would be - the solution wasn't too straightforward - but with the help of the existing code as reference, I was able to find a solution. When working on a project at school, the instructions are laid out for you. You know which functions to work on, what they should do, and what they shouldn't do. Working on OSS was a completely different experience. School work is straightforward and because of that I'd be able to jump straight in and code. Being used to coding in this way made my first day trying to fix the bug very frustrating. After a day of trying to fix functions that looked as if they could be related to the bug without success, I decided to look at it again the next day. This time, I decided to take my time. I removed all of my edits to the code and spent around an hour just reading the code and drawing out the dependencies. This finally allowed me to find a solution.&quot;</p>
</blockquote>
<blockquote>
<p>&quot;I learned that it's not going to be easy to contribute to a project right away, and that's okay...it's important to not get overwhelmed with what you're working on, and continue 1 step at a time, and ask questions when you need help. Be confident, if I can do it, you can too.&quot;</p>
</blockquote>
<blockquote>
<p>&quot;I learned that an issue didn't need to be tagged as 'beginner friendly' for it to be viable for me, that I could and should take on more challenging issues at this point, ones that would feel more rewarding and worthwhile.&quot;</p>
</blockquote>
<h4 id="asenseofaccomplishment">A Sense of Accomplishment</h4>
<p>Many students talked about being &quot;proud&quot; of their work, or expressed surprise when a project they use personally accepted their code:</p>
<blockquote>
<p>&quot;I do feel genuinely proud that I have 10 lines of code landed in the VSCode project&quot;</p>
</blockquote>
<blockquote>
<p>&quot;After solving this issue I felt very proud. Not only did I contribute to a project I cared about, I was able to tackle an issue that I had almost no knowledge of going in, and was able to solve it without giving up. I had never worked with React before, and was scared that I would not be able to understand anything. In actuality it was mostly similar to JavaScript and I could follow along pretty well. I also think I did a good job of quickly finding the issue in the codebase and isolating the part of code where the issue was located.&quot;</p>
</blockquote>
<blockquote>
<p>&quot;I used to think those projects are maintained by much more capable people than me, now the thinking is 'yeah, I can contribute to that.' To be honest, I would never think I was able to participate in an event like Hacktoberfest and contribute to the open-source community in this way. Now, it is so rewarding to see my name amount the contributors.&quot;</p>
</blockquote>
<h4 id="joiningthelargeropensourcecommunity">Joining the Larger Open Source Community</h4>
<p>Finally, a theme I saw again and again was students beginning to find their place within the larger, global, open source community.  Many students had their blogs quoted or featured on social media, and were surprised that other people around the world had seen them and their work.</p>
<blockquote>
<p>&quot;I really liked how people from different backgrounds and ethnicity can help one another when it comes to diversifying their code with different cultures. I really like the fact I got to share my language (Punjabi) with other people in the community through localizing&quot;</p>
</blockquote>
<blockquote>
<p>&quot;getting to work with developers in St.Petersburg, Holland, Barcelona and America.&quot;</p>
</blockquote>
<blockquote>
<p>&quot;Now I can say I have worked with people from around the world!&quot;</p>
</blockquote>
<h3 id="conclusion">Conclusion</h3>
<p>I'm really impressed with Hacktoberfest, and thankful for <a href="https://www.digitalocean.com/">DigitalOcean</a>, <a href="https://www.twilio.com/">Twilio</a>, <a href="https://github.com/">GitHub</a> and others who take it upon themselves to sponsor this.  We need events like this where everyone is aware that new people are joining, and it's OK to get involved.  Having a sense that &quot;during October, lots of new people are going to be coming&quot; is important.  Projects can label issues, people can approach reviews a bit differently, and everyone can use a bit more patience and support.  And there's no need for any of that to end now that it's November.</p>
<p>Hopefully this helps you if you're thinking about having your students join Hacktoberfest next year.  If you have other questions, get in touch.  And if you'd like to help me grade all this work, I'd be happy for that contribution :)</p>
]]></content:encoded></item><item><title><![CDATA[Building Large Code on Travis CI]]></title><description><![CDATA[<p>This week I was doing an experiment to see if I could automate a build step in a project I'm working on, which requires binary resources to be included in a web app.</p>
<p>I'm building a custom Linux kernel and bundling it with a root filesystem in order to embed</p>]]></description><link>https://blog.humphd.org/building-large-code-on-travis/</link><guid isPermaLink="false">5b29074f8ee42603d33e3a3e</guid><category><![CDATA[seneca]]></category><category><![CDATA[mozilla]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Tue, 19 Jun 2018 14:45:06 GMT</pubDate><content:encoded><![CDATA[<p>This week I was doing an experiment to see if I could automate a build step in a project I'm working on, which requires binary resources to be included in a web app.</p>
<p>I'm building a custom Linux kernel and bundling it with a root filesystem in order to embed it in the browser.  To do this, I'm using a dockerized <a href="https://buildroot.org/">Buildroot</a> build environment (I'll write about the details of this in a follow-up post).  On my various computers, this takes anywhere from 15-25 minutes.  Since my buildroot/kernel configs won't change very often, I wondered if I could move this to Travis and automate it away from our workflow?</p>
<p><a href="https://docs.travis-ci.com/user/docker/">Travis has no problem using docker</a>, and as long as you can fit your build into the alloted <a href="https://docs.travis-ci.com/user/customizing-the-build/#Build-Timeouts">50 minute build timeout window</a>, it <em>should</em> work.  Let's do this!</p>
<h3 id="firstattempt">First attempt</h3>
<p>In the simplest case, doing a build like this would be as simple as:</p>
<pre><code class="language-yml">sudo: required
services:
  - docker
...
before_script:
  - docker build -t buildroot .
  - docker run --rm -v $PWD/build:/build buildroot
...
deploy:
  # Deploy built binaries in /build along with other assets
</code></pre>
<p>This happily builds my docker <code>buildroot</code> image, and then starts the build within the container, logging everything as it goes.  But once the log gets to 10,000 lines in length, Travis won't produce more output.  You can still download the Raw Log as a file, so I wait a bit and then periodically download a snapshot of the log in order to check on the build's progress.</p>
<p>At a certain point the build is terminated: once the log file grows to 4M, Travis assumes that all the size is noise, for example, a command running in an infinite loop, and terminates the build with an error.</p>
<h3 id="secondattempt">Second attempt</h3>
<p>It's clear that I need to reduce the output of my build.  This time I redirect build output to a log file, and then tell Travis to dump the tail-end of the log file in the case of a failed build.  The <a href="https://docs.travis-ci.com/user/customizing-the-build#Breaking-the-Build"><code>after_failre</code> and <code>after_success</code></a> build stage hooks are perfect for this.:</p>
<pre><code class="language-yml">before_script:
  - docker build -t buildroot . &gt; build.log 2&gt;&amp;1
  - docker run --rm -v $PWD/build:/build buildroot &gt;&gt; build.log 2&gt;&amp;1

after_failure:
  # dump the last 2000 lines of our build, and hope the error is in that!
  - tail --lines=2000 build.log

after_success:
  # Log that the build worked, because we all need some good news
  - echo &quot;Buildroot build succeeded, binary in ./build&quot;
</code></pre>
<p>I'm pretty proud of this until it fails after 10 minutes of building with an error about Travis assuming the lack of log messages (which are all going to my <code>build.log</code> file) means my build has stalled and should be terminated.  Turns out you <a href="https://docs.travis-ci.com/user/customizing-the-build/#Build-Timeouts">must produce console output every 10 minutes to keep Travis builds alive</a>.</p>
<h3 id="thirdattempt">Third attempt</h3>
<p>Not only is this a common problem, Travis has a built-in solution in the form of <a href="https://docs.travis-ci.com/user/common-build-problems/#Build-times-out-because-no-output-was-received"><code>travis_wait</code></a>.  Essentially, you can prefix your build command with <code>travis_wait</code> and it will tolerate there being no output for 20 minutes.  Need more than 20, you can optionally pass it the number of minutes to wait before timing out.  Let's try 30 minutes:</p>
<pre><code class="language-yml">before_script:
  - docker build -t buildroot . &gt; build.log 2&gt;&amp;1
  - travis_wait 30 docker run --rm -v $PWD/build:/build buildroot &gt;&gt; build.log 2&gt;&amp;1
</code></pre>
<p>This builds perfectly...for 10 minutes.  Then it dies with a timeout due to there being no console output.  Some more research reveals that <a href="https://github.com/travis-ci/travis-ci/issues/6934#issuecomment-262961742"><code>travis_wait</code> doesn't play nicely with processes that <code>fork</code> or <code>exec</code></a>.</p>
<h3 id="fourthattempt">Fourth attempt</h3>
<p>Lots of people suggest variations on the same theme: run a command that spins and periodically prints something to <code>stdout</code>, and have it fork your build process:</p>
<pre><code class="language-yml">before_script:
  - docker build -t buildroot . &gt; build.log 2&gt;&amp;1
  - while sleep 5m; do echo &quot;=====[ $SECONDS seconds, buildroot still building... ]=====&quot;; done &amp;
  - time docker run --rm -v $PWD/build:/build buildroot &gt;&gt; build.log 2&gt;&amp;1
  # Killing background sleep loop
  - kill %1
</code></pre>
<p>Here we log something at 5 minute intervals, while the build progresses in the background.  When it's done, we kill the <code>while</code> loop.  This works perfectly...until it hits the 50 minute barrier and gets killed by Traivs:</p>
<pre><code>$ docker build -t buildroot . &gt; build.log 2&gt;&amp;1
before_script
$ while sleep 5m; do echo &quot;=====[ $SECONDS seconds, buildroot still building... ]=====&quot;; done &amp;
$ time docker run --rm -v $PWD/build:/build buildroot &gt;&gt; build.log 2&gt;&amp;1
=====[ 495 seconds, buildroot still building... ]=====
=====[ 795 seconds, buildroot still building... ]=====
=====[ 1095 seconds, buildroot still building... ]=====
=====[ 1395 seconds, buildroot still building... ]=====
=====[ 1695 seconds, buildroot still building... ]=====
=====[ 1995 seconds, buildroot still building... ]=====
=====[ 2295 seconds, buildroot still building... ]=====
=====[ 2595 seconds, buildroot still building... ]=====
=====[ 2895 seconds, buildroot still building... ]=====
The job exceeded the maximum time limit for jobs, and has been terminated.
</code></pre>
<p>The build took over 48 minutes on the Travis builder, and combined with the time I'd already spent cloning, installing, etc. there isn't enough time to do what I'd hoped.</p>
<p>Part of me wonders whether I could hack something together that uses successive builds, <a href="https://docs.travis-ci.com/user/caching/">Travis caches</a> and move the build artifacts out of docker, such that I can do incremental builds and leverage <code>ccache</code> and the like.  I'm sure someone has done it, and it's in a <code>.travis.yml</code> file in GitHub somewhere already.  I leave this as an experiment for the reader.</p>
<p>I've got nothing but love for Travis and the incredible free service they offer open source projects.  Every time I concoct some new use case, I find that they've added it or supported it all along.  The Travis docs are incredible, and well worth your time if you want to push the service in interesting directions.</p>
<p>In this case I've hit a wall and will go another way.  But I learned a bunch and in case it will help someone else, I leave it here for your CI needs.</p>
]]></content:encoded></item><item><title><![CDATA[Experiments with "Good First Experience"]]></title><description><![CDATA[<p>Since writing my post about <a href="https://blog.humphd.org/why-good-first-bugs-often-arent/">good-first-bug vs. good-first-experience</a> I've been experimenting with different approaches to creating useful walkthroughs.  I think I've settled on a method that works well, and wanted to write about it, so as to encourage others to do the same.</p>
<p>First, a refresher on what I mean</p>]]></description><link>https://blog.humphd.org/experiments-with-good-first-experience/</link><guid isPermaLink="false">5aba4f377bee6a03d4f54208</guid><category><![CDATA[seneca]]></category><category><![CDATA[mozilla]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Tue, 27 Mar 2018 15:02:07 GMT</pubDate><content:encoded><![CDATA[<p>Since writing my post about <a href="https://blog.humphd.org/why-good-first-bugs-often-arent/">good-first-bug vs. good-first-experience</a> I've been experimenting with different approaches to creating useful walkthroughs.  I think I've settled on a method that works well, and wanted to write about it, so as to encourage others to do the same.</p>
<p>First, a refresher on what I mean by Good First Experience (GFE).  Unlike a Good First Bug (GFB), which can only be fixed by one person (i.e., it's destroyed in being solved), a GFE is reproducible by anyone and everyone willing to put in the time.  As such, a GFE is not tied to the current state of the project (i.e., rapidly changing), but rather uses an old commit to freeze the state of the project so it can be recreated. Following the steps doesn't alter the project; it alters you.</p>
<p>If we think of an OSS project like a team of climbers ascending a mountain, a GFE is a camp part-way up the route that backpackers can visit in order to get a feel for the real thing.  A GFE is also like a good detective novel: you know the mystery is going to get solved by the end, but nevertheless, it's thrilling to experience the journey, and see how it happens.  Could I solve this before the book does?</p>
<p>With my open source students, I've tried a mix of written and in-class presentation style.  My approach is usually to fix a bug in a project I don't know and document what I do.  I think it's useful to put yourself on an even footing with a new developer by working in unfamiliar code.  Doing so forces me to be more deliberate with how I use tools and debugging/code-reading techniques.  It also means I (mostly) can't rely on years of accumulated knowledge about how code is put together, and instead have to face the challenge fresh.  Obviously I can't leave my experience out of the mix, because I've been programming for over 30 years.  But I can remove familiarity, which is what a lot of us rely on without realizing it.  Try fixing a bug in a project and language you've never worked on before, and you'll be surprised at what you learn about yourself.  When I need to humble myself, a few hours with a CSS bug is usually all I need :)</p>
<p>My first attempts at this involved writing a blog post.  I've done a few of these:</p>
<ul>
<li><a href="https://blog.humphd.org/howto-first-github-pr/">In a node.js module</a></li>
<li><a href="https://blog.humphd.org/fixing-a-bug-in-mozilla-thimble/">In a web app (Thimble)</a></li>
<li><a href="https://blog.humphd.org/fixing-a-bug-in-tensorboard/">In TensorFlow's visualization tool, TensorBoard</a></li>
</ul>
<p>I enjoy this style.  It's easy for me to write in my blog.  However I've moved away from it for a number of reasons.  First, I don't like how it recedes into the past by being tied to the history of my blog.  It's important <em>what</em> I wrote, not <em>when</em> I wrote it.  Instead of a journal entry, I want this to feel more like documentation.  Another thing I don't like about using my blog is that it ends up being disconnected from the project and code in question.  There's an unnecessary separation between the experience and the code, one that I think encourages you to <em>read</em> but not <em>do</em> anything.</p>
<p>I've since started using another style: hijacking the project's <code>README.md</code> file and writing everything in a branch on my fork.  First, some examples:</p>
<ul>
<li><a href="https://github.com/humphd/vscode/tree/good-first-experience-issue-42726#walkthrough-fixing-a-bug-in-visual-studio-code">Fixing a bug in Visual Studio Code</a></li>
<li><a href="https://github.com/humphd/browser-laptop/tree/good-first-experience-issue-10554#walkthrough-fixing-a-bug-in-the-brave-browser">Fixing a bug in the Brave Browser</a></li>
</ul>
<p>I got the idea for this approach when I wrote my <a href="https://github.com/humphd/have-fun-with-machine-learning">guide on Machine Learning and Caffe</a>.  To do this, I needed a combination of documentation, source files, and images.  Obviously my blog wouldn't suffice, so I did it as its own repo.  I'd seen lots of people &quot;blog&quot; using Gist before (e.g., this <a href="https://gist.github.com/isaacs/62a2d1825d04437c6f08">Makefile tutorial</a>), and I was curious to know what would happen if I repurposed an entire repo as a writing medium.</p>
<p>In the case of my ML guide, it's meant a ton of exposure (4.5K stars and weeks as a top trending repo), and nearly 500 forks.  It's also formed its own community, with people filing bugs and still <em>other</em> people helping solve them.  It also resulted in a <a href="https://github.com/humphd/have-fun-with-machine-learning/blob/master/README_zh-tw.md">complete Chinese translation</a>, and thereby yet more exposure.</p>
<p>Knowing that I could use GitHub in this way, I was interested to try an even more symbiotic approach for my GFE guides:</p>
<ul>
<li>Fork the repo in question</li>
<li>Create a new branch, and freeze the project state so it is reproducable by others</li>
<li>Add a <code>screenshots/</code> directory for all the images I need to include.  Now I can just <code>git add</code> and <code>git commit</code> these into the repo</li>
<li>Erase the <code>README.md</code> file contents, and start writing my guide in there.</li>
<li>Link to files within the project, pinned to the commit that I'm on in this branch</li>
</ul>
<p>I've liked a number of things that this approach provides:</p>
<ul>
<li>As an outsider, you can contribute something to a project you like that will help others get involved.  I don't have to convince the project to do this.  I just do it.</li>
<li>Similarly, I can do something in the project without having to get permission.  I'm not asking any of the projects to make this official documentation.  Whether they do or don't, it exists on GitHub identically</li>
<li>People (my students, or others) who want to try what I'm doing can simply clone my fork, and checkout my branch.  All the files are there in the exactly the right state.  Everything <em>should</em> work as it did for me.  There are obviously going to be issues with environments and dependency versions I can't control as easily.</li>
<li>People can interact with what I've done to suggest corrections, file issues (just enable Issues on your fork), star the repo, etc.</li>
</ul>
<p>I taught my <a href="https://github.com/humphd/browser-laptop/tree/good-first-experience-issue-10554#walkthrough-fixing-a-bug-in-the-brave-browser">Brave walkthrough</a> in class yesterday, and I think it was ideally suited to the time I had (2 hours), and the level of the students.  Many times in the past I would have fixed a bug live in class, but I didn't produce a guide that could be used after the class ended.  By doing both, I've found that students can watch me do it live, and we can discuss lots of things that are happening; and then after class, they can read through it again, and ideally try it themselves, to further develop the skills.</p>
<p>This approach is something new that I'm enjoying, and I wanted to share it as a possible style for others to try.  If you have projects you think I should do this on, let me know.  I'm definitely going to try to do more of this.</p>
]]></content:encoded></item><item><title><![CDATA[On standards work]]></title><description><![CDATA[<p>This week I'm looking at standards with my open source class.  I find that students often don't know about standards and specs, how to read them, how they get created, or how to give feedback and participate.  The process is largely invisible.  The timing of this topic corresponds to a</p>]]></description><link>https://blog.humphd.org/on-standards-work/</link><guid isPermaLink="false">5aa036377bee6a03d4f541ff</guid><category><![CDATA[seneca]]></category><category><![CDATA[mozilla]]></category><dc:creator><![CDATA[David Humphrey]]></dc:creator><pubDate>Wed, 07 Mar 2018 20:18:43 GMT</pubDate><content:encoded><![CDATA[<p>This week I'm looking at standards with my open source class.  I find that students often don't know about standards and specs, how to read them, how they get created, or how to give feedback and participate.  The process is largely invisible.  The timing of this topic corresponds to a visit from <a href="https://twitter.com/DavidBruant">David Bruant</a>, who is a guest presenter in the class this week.  I wanted to discuss his background working &quot;open&quot; while he was here, and one of the areas he's focused on is open standards work for the web, in particular, for JavaScript.</p>
<p>All of the students are <em>using</em> JavaScript.  Where did it come from?  Who made it?  Who maintains it?  Who defines it?  Who is in charge? When we talk about open <em>source</em> we think about code, tests, documentation, and how all of these evolve.  But what about open <em>standards</em>?  What does working on a standard look like?</p>
<p>There's a great example being discussed this week all over Twitter, GitHub, Bugzilla and elsewhere.  It involves a <a href="https://tc39.github.io/proposal-flatMap/">proposal to add a new method</a> <code>flatten()</code> to <code>Array</code>s.  There are some good <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatten">docs for it on MDN</a> as well.</p>
<p>The basic idea is to allow an <code>Array</code> containing other <code>Array</code>s, or &quot;holes&quot; (i.e., empty elements), to be compressed into a new &quot;flat&quot; <code>Array</code>.  For example, the &quot;flattened&quot; version of <code>[1, 2, [3, 4]]</code> would be <code>[1, 2, 3, 4]</code>.  It's a great suggestion, and one of many <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype">innovative and useful things</a> that have been added to <code>Array</code> in that last few years.</p>
<p>However, changing the web is hard.  There's just so much of it being used (and abused) by people all over the world in unexpected ways.  You might have a good idea for a new thing the web and JavaScript can do, but getting it added is not easy.  You might say to yourself, <em>&quot;I can see how removing things would be hard, but why is adding something difficult?&quot;</em>  It's difficult because one of the goals of the people who look after web standards is to not intentionally break the web unnecessarily.  Where possible, something authored for the web of 1999 should still work in 2019.</p>
<p>So how does <code>flatten()</code> break the web?  Our story starts 150 years ago, back in the mid 1990s.  When it arrived on the scene, JavaScript was fairly small and limited.  However, people used it, loved it, (and hated it), and their practical uses of it began to wear grooves: as people wrote more and more code, best practices emerged, and some of those calcified into utility functions, libraries, and frameworks.</p>
<p>One of the frameworks was <a href="https://en.wikipedia.org/wiki/MooTools">MooTools</a>.  Among other conveniences, <a href="https://mootools.net/core/docs/1.6.0/Types/Array#Array:flatten">MooTools added a way</a> to <code>flatten()</code> an <code>Array</code>.  While JavaScript couldn't do this &quot;natively,&quot; it was possible to &quot;shim&quot; or &quot;polyfill&quot; the built-in <code>Array</code> type to add new properties and methods.  MooTools <a href="https://github.com/mootools/mootools-core/blame/604a893ca91865d3af5875459afee366ecc5b21c/Source/Core/Core.js#L52">did this in a way that causes problems</a>: we have all be told that it's a bad idea to modify, &quot;step on,&quot; or otherwise alter the definitions of the language and runtime without first checking to see if they are, in fact, available.  We wrote code in 2007 using assumptions that don't necessarily hold true in 2018: the browsers change, versions change, the language changes.</p>
<p>I remember when I started writing JavaScript, and looking at the long list of reserved keywords I wasn't supposed to use, things like <code>class</code> that <em>everyone</em> knew you'd be safe to use, since JS doesn't use classes!  Well, much like hundred-year land leases, eventually things change, and what was true once upon a time doesn't necessarily hold today.  It's easy to point a finger at MooTools (many people are), but honestly, none of us thinks with enough long-term vision to truly understand all the implications of our decisions now on the world 10, 20, or 50 years hence (code people are writing today <strong>will</strong> still be in use by then, I promise you--I was a developer during Y2K, so I know it's true!).</p>
<p>At any rate, MooTools' <code>flatten()</code> is going to collide with JavaScript's new <code>flatten()</code>, because they don't work exactly the same (i.e., different argument signatures), and any code that relies on MooTools' way of doing <code>flatten()</code> <a href="https://webcompat.com/issues/15121">will get...flattened</a>.</p>
<p>And so, someone <a href="https://github.com/tc39/proposal-flatMap/pull/56#issue-173327251">files a bug</a> on the proposal, suggesting <code>flatten()</code> get changed to <code>smoosh()</code>.  Before this gets resolved, imagine you have to make the decision.  What would you do?  Is &quot;smoosh&quot; logical?  Maybe you'd say &quot;smoosh&quot; is silly and instead suggest &quot;press&quot; or &quot;mix&quot;.  Are those safe choices?  What if you used a made-up word and just documented it?  What about &quot;clarmp&quot;?  What about using a <a href="https://twitter.com/rauschma/status/971202376056090624">word from another language</a>?  They say that naming things is one of the great problems in computer science?  It really is a hard problem!  On some level we really should have lexicographers sitting on these committees to help us sort things out.</p>
<p>I won't give you my opinion.  I intentionally stay out of a lot of these debates because I don't feel qualified to make good decisions, nor do I feel like it matters what I think.  I have ideas, possibly good ideas, but the scope and scale of the web is frightening.  I've had the privilege to work with some amazing web standards people in the past, and the things they know blow my mind.  Every choice is fraught, and every solution is a compromise.  It's one of the reasons why I'm so patient with standards bodies and implementors, who try their best and yet still make mistakes.</p>
<p>One thing I do know for sure is that the alternative, where one person or company makes all the decisions, where old code gets trampled and forgotten by progress, where we only care about what's new--is a world that I don't want either.  If I have to <code>smoosh()</code> in order to live on a web that's bigger than me and my preferences, I'm OK with that.</p>
<p>It's easy to laugh, but instead I think we should really be thanking the invisible, hard working, well intentioned open standards people who do amazing work to both advance the front and guard the flank.</p>
]]></content:encoded></item></channel></rss>