'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var signalExit = _interopDefault(require('signal-exit'));
var stripAnsi = _interopDefault(require('strip-ansi'));
var yogaLayoutPrebuilt = _interopDefault(require('yoga-layout-prebuilt'));
var chalk = _interopDefault(require('chalk'));
var redux = require('../../redux');
var gatsbyCoreUtils = require('gatsby-core-utils');
var gatsbyTelemetry = require('gatsby-telemetry');
var convertHrtime = _interopDefault(require('convert-hrtime'));
var path = _interopDefault(require('path'));

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

var n = "function" === typeof Symbol && Symbol.for,
    p = n ? Symbol.for("react.element") : 60103,
    q = n ? Symbol.for("react.portal") : 60106,
    r = n ? Symbol.for("react.fragment") : 60107,
    t = n ? Symbol.for("react.strict_mode") : 60108,
    u = n ? Symbol.for("react.profiler") : 60114,
    v = n ? Symbol.for("react.provider") : 60109,
    w = n ? Symbol.for("react.context") : 60110,
    x = n ? Symbol.for("react.forward_ref") : 60112,
    y = n ? Symbol.for("react.suspense") : 60113;
var z = n ? Symbol.for("react.memo") : 60115,
    aa = n ? Symbol.for("react.lazy") : 60116;
var A = "function" === typeof Symbol && Symbol.iterator;

function B(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);

  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}

var C = {
  isMounted: function () {
    return !1;
  },
  enqueueForceUpdate: function () {},
  enqueueReplaceState: function () {},
  enqueueSetState: function () {}
},
    D = {};

function E(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = D;
  this.updater = c || C;
}

E.prototype.isReactComponent = {};

E.prototype.setState = function (a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error(B(85));
  this.updater.enqueueSetState(this, a, b, "setState");
};

E.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};

function F() {}

F.prototype = E.prototype;

function G(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = D;
  this.updater = c || C;
}

var H = G.prototype = new F();
H.constructor = G;
objectAssign(H, E.prototype);
H.isPureReactComponent = !0;
var I = {
  current: null
},
    J = {
  current: null
},
    K = Object.prototype.hasOwnProperty,
    L = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};

function M(a, b, c) {
  var e,
      d = {},
      g = null,
      l = null;
  if (null != b) for (e in void 0 !== b.ref && (l = b.ref), void 0 !== b.key && (g = "" + b.key), b) K.call(b, e) && !L.hasOwnProperty(e) && (d[e] = b[e]);
  var f = arguments.length - 2;
  if (1 === f) d.children = c;else if (1 < f) {
    for (var k = Array(f), m = 0; m < f; m++) k[m] = arguments[m + 2];

    d.children = k;
  }
  if (a && a.defaultProps) for (e in f = a.defaultProps, f) void 0 === d[e] && (d[e] = f[e]);
  return {
    $$typeof: p,
    type: a,
    key: g,
    ref: l,
    props: d,
    _owner: J.current
  };
}

function ba(a, b) {
  return {
    $$typeof: p,
    type: a.type,
    key: b,
    ref: a.ref,
    props: a.props,
    _owner: a._owner
  };
}

function N(a) {
  return "object" === typeof a && null !== a && a.$$typeof === p;
}

function escape(a) {
  var b = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + ("" + a).replace(/[=:]/g, function (a) {
    return b[a];
  });
}

var O = /\/+/g,
    P = [];

function Q(a, b, c, e) {
  if (P.length) {
    var d = P.pop();
    d.result = a;
    d.keyPrefix = b;
    d.func = c;
    d.context = e;
    d.count = 0;
    return d;
  }

  return {
    result: a,
    keyPrefix: b,
    func: c,
    context: e,
    count: 0
  };
}

function R(a) {
  a.result = null;
  a.keyPrefix = null;
  a.func = null;
  a.context = null;
  a.count = 0;
  10 > P.length && P.push(a);
}

function S(a, b, c, e) {
  var d = typeof a;
  if ("undefined" === d || "boolean" === d) a = null;
  var g = !1;
  if (null === a) g = !0;else switch (d) {
    case "string":
    case "number":
      g = !0;
      break;

    case "object":
      switch (a.$$typeof) {
        case p:
        case q:
          g = !0;
      }

  }
  if (g) return c(e, a, "" === b ? "." + T(a, 0) : b), 1;
  g = 0;
  b = "" === b ? "." : b + ":";
  if (Array.isArray(a)) for (var l = 0; l < a.length; l++) {
    d = a[l];
    var f = b + T(d, l);
    g += S(d, f, c, e);
  } else if (null === a || "object" !== typeof a ? f = null : (f = A && a[A] || a["@@iterator"], f = "function" === typeof f ? f : null), "function" === typeof f) for (a = f.call(a), l = 0; !(d = a.next()).done;) d = d.value, f = b + T(d, l++), g += S(d, f, c, e);else if ("object" === d) throw c = "" + a, Error(B(31, "[object Object]" === c ? "object with keys {" + Object.keys(a).join(", ") + "}" : c, ""));
  return g;
}

function U(a, b, c) {
  return null == a ? 0 : S(a, "", b, c);
}

function T(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape(a.key) : b.toString(36);
}

function ca(a, b) {
  a.func.call(a.context, b, a.count++);
}

function da(a, b, c) {
  var e = a.result,
      d = a.keyPrefix;
  a = a.func.call(a.context, b, a.count++);
  Array.isArray(a) ? V(a, e, c, function (a) {
    return a;
  }) : null != a && (N(a) && (a = ba(a, d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(O, "$&/") + "/") + c)), e.push(a));
}

function V(a, b, c, e, d) {
  var g = "";
  null != c && (g = ("" + c).replace(O, "$&/") + "/");
  b = Q(b, g, e, d);
  U(a, da, b);
  R(b);
}

function W() {
  var a = I.current;
  if (null === a) throw Error(B(321));
  return a;
}

var X = {
  Children: {
    map: function (a, b, c) {
      if (null == a) return a;
      var e = [];
      V(a, e, null, b, c);
      return e;
    },
    forEach: function (a, b, c) {
      if (null == a) return a;
      b = Q(null, null, b, c);
      U(a, ca, b);
      R(b);
    },
    count: function (a) {
      return U(a, function () {
        return null;
      }, null);
    },
    toArray: function (a) {
      var b = [];
      V(a, b, null, function (a) {
        return a;
      });
      return b;
    },
    only: function (a) {
      if (!N(a)) throw Error(B(143));
      return a;
    }
  },
  createRef: function () {
    return {
      current: null
    };
  },
  Component: E,
  PureComponent: G,
  createContext: function (a, b) {
    void 0 === b && (b = null);
    a = {
      $$typeof: w,
      _calculateChangedBits: b,
      _currentValue: a,
      _currentValue2: a,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    };
    a.Provider = {
      $$typeof: v,
      _context: a
    };
    return a.Consumer = a;
  },
  forwardRef: function (a) {
    return {
      $$typeof: x,
      render: a
    };
  },
  lazy: function (a) {
    return {
      $$typeof: aa,
      _ctor: a,
      _status: -1,
      _result: null
    };
  },
  memo: function (a, b) {
    return {
      $$typeof: z,
      type: a,
      compare: void 0 === b ? null : b
    };
  },
  useCallback: function (a, b) {
    return W().useCallback(a, b);
  },
  useContext: function (a, b) {
    return W().useContext(a, b);
  },
  useEffect: function (a, b) {
    return W().useEffect(a, b);
  },
  useImperativeHandle: function (a, b, c) {
    return W().useImperativeHandle(a, b, c);
  },
  useDebugValue: function () {},
  useLayoutEffect: function (a, b) {
    return W().useLayoutEffect(a, b);
  },
  useMemo: function (a, b) {
    return W().useMemo(a, b);
  },
  useReducer: function (a, b, c) {
    return W().useReducer(a, b, c);
  },
  useRef: function (a) {
    return W().useRef(a);
  },
  useState: function (a) {
    return W().useState(a);
  },
  Fragment: r,
  Profiler: u,
  StrictMode: t,
  Suspense: y,
  createElement: M,
  cloneElement: function (a, b, c) {
    if (null === a || void 0 === a) throw Error(B(267, a));
    var e = objectAssign({}, a.props),
        d = a.key,
        g = a.ref,
        l = a._owner;

    if (null != b) {
      void 0 !== b.ref && (g = b.ref, l = J.current);
      void 0 !== b.key && (d = "" + b.key);
      if (a.type && a.type.defaultProps) var f = a.type.defaultProps;

      for (k in b) K.call(b, k) && !L.hasOwnProperty(k) && (e[k] = void 0 === b[k] && void 0 !== f ? f[k] : b[k]);
    }

    var k = arguments.length - 2;
    if (1 === k) e.children = c;else if (1 < k) {
      f = Array(k);

      for (var m = 0; m < k; m++) f[m] = arguments[m + 2];

      e.children = f;
    }
    return {
      $$typeof: p,
      type: a.type,
      key: d,
      ref: g,
      props: e,
      _owner: l
    };
  },
  createFactory: function (a) {
    var b = M.bind(null, a);
    b.type = a;
    return b;
  },
  isValidElement: N,
  version: "16.12.0",
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentDispatcher: I,
    ReactCurrentBatchConfig: {
      suspense: null
    },
    ReactCurrentOwner: J,
    IsSomeRendererActing: {
      current: !1
    },
    assign: objectAssign
  }
},
    Y = {
  default: X
},
    Z = Y && X || Y;
var react_production_min = Z.default || Z;

var react = createCommonjsModule(function (module) {

{
  module.exports = react_production_min;
}
});

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */

var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */

var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now = function () {
  return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */


function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */


function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */


function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */


function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

var lodash_throttle = throttle;

const getAllProperties = object => {
  const properties = new Set();

  do {
    for (const key of Reflect.ownKeys(object)) {
      properties.add([object, key]);
    }
  } while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);

  return properties;
};

var autoBind = (self, {
  include,
  exclude
} = {}) => {
  const filter = key => {
    const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);

    if (include) {
      return include.some(match);
    }

    if (exclude) {
      return !exclude.some(match);
    }

    return true;
  };

  for (const [object, key] of getAllProperties(self.constructor.prototype)) {
    if (key === 'constructor' || !filter(key)) {
      continue;
    }

    const descriptor = Reflect.getOwnPropertyDescriptor(object, key);

    if (descriptor && typeof descriptor.value === 'function') {
      self[key] = self[key].bind(self);
    }
  }

  return self;
};

var ansiEscapes = createCommonjsModule(function (module) {

const x = module.exports;
const ESC = '\u001B[';
const OSC = '\u001B]';
const BEL = '\u0007';
const SEP = ';';
const isTerminalApp = process.env.TERM_PROGRAM === 'Apple_Terminal';

x.cursorTo = (x, y) => {
  if (typeof x !== 'number') {
    throw new TypeError('The `x` argument is required');
  }

  if (typeof y !== 'number') {
    return ESC + (x + 1) + 'G';
  }

  return ESC + (y + 1) + ';' + (x + 1) + 'H';
};

x.cursorMove = (x, y) => {
  if (typeof x !== 'number') {
    throw new TypeError('The `x` argument is required');
  }

  let ret = '';

  if (x < 0) {
    ret += ESC + -x + 'D';
  } else if (x > 0) {
    ret += ESC + x + 'C';
  }

  if (y < 0) {
    ret += ESC + -y + 'A';
  } else if (y > 0) {
    ret += ESC + y + 'B';
  }

  return ret;
};

x.cursorUp = count => ESC + (typeof count === 'number' ? count : 1) + 'A';

x.cursorDown = count => ESC + (typeof count === 'number' ? count : 1) + 'B';

x.cursorForward = count => ESC + (typeof count === 'number' ? count : 1) + 'C';

x.cursorBackward = count => ESC + (typeof count === 'number' ? count : 1) + 'D';

x.cursorLeft = ESC + 'G';
x.cursorSavePosition = ESC + (isTerminalApp ? '7' : 's');
x.cursorRestorePosition = ESC + (isTerminalApp ? '8' : 'u');
x.cursorGetPosition = ESC + '6n';
x.cursorNextLine = ESC + 'E';
x.cursorPrevLine = ESC + 'F';
x.cursorHide = ESC + '?25l';
x.cursorShow = ESC + '?25h';

x.eraseLines = count => {
  let clear = '';

  for (let i = 0; i < count; i++) {
    clear += x.eraseLine + (i < count - 1 ? x.cursorUp() : '');
  }

  if (count) {
    clear += x.cursorLeft;
  }

  return clear;
};

x.eraseEndLine = ESC + 'K';
x.eraseStartLine = ESC + '1K';
x.eraseLine = ESC + '2K';
x.eraseDown = ESC + 'J';
x.eraseUp = ESC + '1J';
x.eraseScreen = ESC + '2J';
x.scrollUp = ESC + 'S';
x.scrollDown = ESC + 'T';
x.clearScreen = '\u001Bc';
x.clearTerminal = process.platform === 'win32' ? `${x.eraseScreen}${ESC}0f` : // 1. Erases the screen (Only done in case `2` is not supported)
// 2. Erases the whole screen including scrollback buffer
// 3. Moves cursor to the top-left position
// More info: https://www.real-world-systems.com/docs/ANSIcode.html
`${x.eraseScreen}${ESC}3J${ESC}H`;
x.beep = BEL;

x.link = (text, url) => {
  return [OSC, '8', SEP, SEP, url, BEL, text, OSC, '8', SEP, SEP, BEL].join('');
};

x.image = (buf, opts) => {
  opts = opts || {};
  let ret = OSC + '1337;File=inline=1';

  if (opts.width) {
    ret += `;width=${opts.width}`;
  }

  if (opts.height) {
    ret += `;height=${opts.height}`;
  }

  if (opts.preserveAspectRatio === false) {
    ret += ';preserveAspectRatio=0';
  }

  return ret + ':' + buf.toString('base64') + BEL;
};

x.iTerm = {};

x.iTerm.setCwd = cwd => OSC + '50;CurrentDir=' + (cwd || process.cwd()) + BEL;
});

var mimicFn = (to, from) => {
  // TODO: use `Reflect.ownKeys()` when targeting Node.js 6
  for (const prop of Object.getOwnPropertyNames(from).concat(Object.getOwnPropertySymbols(from))) {
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
  }

  return to;
};

var onetime = (fn, opts) => {
  // TODO: Remove this in v3
  if (opts === true) {
    throw new TypeError('The second argument is now an options object');
  }

  if (typeof fn !== 'function') {
    throw new TypeError('Expected a function');
  }

  opts = opts || {};
  let ret;
  let called = false;
  const fnName = fn.displayName || fn.name || '<anonymous>';

  const onetime = function () {
    if (called) {
      if (opts.throw === true) {
        throw new Error(`Function \`${fnName}\` can only be called once`);
      }

      return ret;
    }

    called = true;
    ret = fn.apply(this, arguments);
    fn = null;
    return ret;
  };

  mimicFn(onetime, fn);
  return onetime;
};

var restoreCursor = onetime(() => {
  signalExit(() => {
    process.stderr.write('\u001b[?25h');
  }, {
    alwaysLast: true
  });
});

var cliCursor = createCommonjsModule(function (module, exports) {



let hidden = false;

exports.show = stream => {
  const s = stream || process.stderr;

  if (!s.isTTY) {
    return;
  }

  hidden = false;
  s.write('\u001b[?25h');
};

exports.hide = stream => {
  const s = stream || process.stderr;

  if (!s.isTTY) {
    return;
  }

  restoreCursor();
  hidden = true;
  s.write('\u001b[?25l');
};

exports.toggle = (force, stream) => {
  if (force !== undefined) {
    hidden = force;
  }

  if (hidden) {
    exports.show(stream);
  } else {
    exports.hide(stream);
  }
};
});

/* eslint-disable yoda */

var isFullwidthCodePoint = x => {
  if (Number.isNaN(x)) {
    return false;
  } // code points are derived from:
  // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt


  if (x >= 0x1100 && (x <= 0x115f || // Hangul Jamo
  x === 0x2329 || // LEFT-POINTING ANGLE BRACKET
  x === 0x232a || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  0x2e80 <= x && x <= 0x3247 && x !== 0x303f || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  0x3250 <= x && x <= 0x4dbf || // CJK Unified Ideographs .. Yi Radicals
  0x4e00 <= x && x <= 0xa4c6 || // Hangul Jamo Extended-A
  0xa960 <= x && x <= 0xa97c || // Hangul Syllables
  0xac00 <= x && x <= 0xd7a3 || // CJK Compatibility Ideographs
  0xf900 <= x && x <= 0xfaff || // Vertical Forms
  0xfe10 <= x && x <= 0xfe19 || // CJK Compatibility Forms .. Small Form Variants
  0xfe30 <= x && x <= 0xfe6b || // Halfwidth and Fullwidth Forms
  0xff01 <= x && x <= 0xff60 || 0xffe0 <= x && x <= 0xffe6 || // Kana Supplement
  0x1b000 <= x && x <= 0x1b001 || // Enclosed Ideographic Supplement
  0x1f200 <= x && x <= 0x1f251 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  0x20000 <= x && x <= 0x3fffd)) {
    return true;
  }

  return false;
};

var emojiRegex = function () {
  // https://mths.be/emoji
  return /\uD83C\uDFF4(?:\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74)\uDB40\uDC7F|\u200D\u2620\uFE0F)|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDB0-\uDDB3])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDB0-\uDDB3]))|\uD83D\uDC69\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDB0-\uDDB3])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83D\uDC69\u200D[\u2695\u2696\u2708])\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC68(?:\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDB0-\uDDB3])|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF9]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD70\uDD73-\uDD76\uDD7A\uDD7C-\uDDA2\uDDB0-\uDDB9\uDDC0-\uDDC2\uDDD0-\uDDFF])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF9]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD70\uDD73-\uDD76\uDD7A\uDD7C-\uDDA2\uDDB0-\uDDB9\uDDC0-\uDDC2\uDDD0-\uDDFF])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDD1-\uDDDD])/g;
};

const emojiRegex$1 = emojiRegex();

var stringWidth = input => {
  input = input.replace(emojiRegex$1, '  ');

  if (typeof input !== 'string' || input.length === 0) {
    return 0;
  }

  input = stripAnsi(input);
  let width = 0;

  for (let i = 0; i < input.length; i++) {
    const code = input.codePointAt(i); // Ignore control characters

    if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {
      continue;
    } // Ignore combining characters


    if (code >= 0x300 && code <= 0x36F) {
      continue;
    } // Surrogates


    if (code > 0xFFFF) {
      i++;
    }

    width += isFullwidthCodePoint(code) ? 2 : 1;
  }

  return width;
};

var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};

var conversions = createCommonjsModule(function (module) {
/* MIT license */
 // NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)


var reverseKeywords = {};

for (var key in colorName) {
  if (colorName.hasOwnProperty(key)) {
    reverseKeywords[colorName[key]] = key;
  }
}

var convert = module.exports = {
  rgb: {
    channels: 3,
    labels: 'rgb'
  },
  hsl: {
    channels: 3,
    labels: 'hsl'
  },
  hsv: {
    channels: 3,
    labels: 'hsv'
  },
  hwb: {
    channels: 3,
    labels: 'hwb'
  },
  cmyk: {
    channels: 4,
    labels: 'cmyk'
  },
  xyz: {
    channels: 3,
    labels: 'xyz'
  },
  lab: {
    channels: 3,
    labels: 'lab'
  },
  lch: {
    channels: 3,
    labels: 'lch'
  },
  hex: {
    channels: 1,
    labels: ['hex']
  },
  keyword: {
    channels: 1,
    labels: ['keyword']
  },
  ansi16: {
    channels: 1,
    labels: ['ansi16']
  },
  ansi256: {
    channels: 1,
    labels: ['ansi256']
  },
  hcg: {
    channels: 3,
    labels: ['h', 'c', 'g']
  },
  apple: {
    channels: 3,
    labels: ['r16', 'g16', 'b16']
  },
  gray: {
    channels: 1,
    labels: ['gray']
  }
}; // hide .channels and .labels properties

for (var model in convert) {
  if (convert.hasOwnProperty(model)) {
    if (!('channels' in convert[model])) {
      throw new Error('missing channels property: ' + model);
    }

    if (!('labels' in convert[model])) {
      throw new Error('missing channel labels property: ' + model);
    }

    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error('channel and label counts mismatch: ' + model);
    }

    var channels = convert[model].channels;
    var labels = convert[model].labels;
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], 'channels', {
      value: channels
    });
    Object.defineProperty(convert[model], 'labels', {
      value: labels
    });
  }
}

convert.rgb.hsl = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var min = Math.min(r, g, b);
  var max = Math.max(r, g, b);
  var delta = max - min;
  var h;
  var s;
  var l;

  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }

  h = Math.min(h * 60, 360);

  if (h < 0) {
    h += 360;
  }

  l = (min + max) / 2;

  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }

  return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
  var rdif;
  var gdif;
  var bdif;
  var h;
  var s;
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var v = Math.max(r, g, b);
  var diff = v - Math.min(r, g, b);

  var diffc = function (c) {
    return (v - c) / 6 / diff + 1 / 2;
  };

  if (diff === 0) {
    h = s = 0;
  } else {
    s = diff / v;
    rdif = diffc(r);
    gdif = diffc(g);
    bdif = diffc(b);

    if (r === v) {
      h = bdif - gdif;
    } else if (g === v) {
      h = 1 / 3 + rdif - bdif;
    } else if (b === v) {
      h = 2 / 3 + gdif - rdif;
    }

    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }

  return [h * 360, s * 100, v * 100];
};

convert.rgb.hwb = function (rgb) {
  var r = rgb[0];
  var g = rgb[1];
  var b = rgb[2];
  var h = convert.rgb.hsl(rgb)[0];
  var w = 1 / 255 * Math.min(r, Math.min(g, b));
  b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
  return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var c;
  var m;
  var y;
  var k;
  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
};
/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */


function comparativeDistance(x, y) {
  return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
}

convert.rgb.keyword = function (rgb) {
  var reversed = reverseKeywords[rgb];

  if (reversed) {
    return reversed;
  }

  var currentClosestDistance = Infinity;
  var currentClosestKeyword;

  for (var keyword in colorName) {
    if (colorName.hasOwnProperty(keyword)) {
      var value = colorName[keyword]; // Compute comparative distance

      var distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest

      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
  }

  return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
  return colorName[keyword];
};

convert.rgb.xyz = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255; // assume sRGB

  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
  var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
  var xyz = convert.rgb.xyz(rgb);
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  var l;
  var a;
  var b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
  var h = hsl[0] / 360;
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var t1;
  var t2;
  var t3;
  var rgb;
  var val;

  if (s === 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }

  t1 = 2 * l - t2;
  rgb = [0, 0, 0];

  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1);

    if (t3 < 0) {
      t3++;
    }

    if (t3 > 1) {
      t3--;
    }

    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }

    rgb[i] = val * 255;
  }

  return rgb;
};

convert.hsl.hsv = function (hsl) {
  var h = hsl[0];
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var smin = s;
  var lmin = Math.max(l, 0.01);
  var sv;
  var v;
  l *= 2;
  s *= l <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  v = (l + s) / 2;
  sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
  return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
  var h = hsv[0] / 60;
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var hi = Math.floor(h) % 6;
  var f = h - Math.floor(h);
  var p = 255 * v * (1 - s);
  var q = 255 * v * (1 - s * f);
  var t = 255 * v * (1 - s * (1 - f));
  v *= 255;

  switch (hi) {
    case 0:
      return [v, t, p];

    case 1:
      return [q, v, p];

    case 2:
      return [p, v, t];

    case 3:
      return [p, q, v];

    case 4:
      return [t, p, v];

    case 5:
      return [v, p, q];
  }
};

convert.hsv.hsl = function (hsv) {
  var h = hsv[0];
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var vmin = Math.max(v, 0.01);
  var lmin;
  var sl;
  var l;
  l = (2 - s) * v;
  lmin = (2 - s) * vmin;
  sl = s * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


convert.hwb.rgb = function (hwb) {
  var h = hwb[0] / 360;
  var wh = hwb[1] / 100;
  var bl = hwb[2] / 100;
  var ratio = wh + bl;
  var i;
  var v;
  var f;
  var n; // wh + bl cant be > 1

  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;

  if ((i & 0x01) !== 0) {
    f = 1 - f;
  }

  n = wh + f * (v - wh); // linear interpolation

  var r;
  var g;
  var b;

  switch (i) {
    default:
    case 6:
    case 0:
      r = v;
      g = n;
      b = wh;
      break;

    case 1:
      r = n;
      g = v;
      b = wh;
      break;

    case 2:
      r = wh;
      g = v;
      b = n;
      break;

    case 3:
      r = wh;
      g = n;
      b = v;
      break;

    case 4:
      r = n;
      g = wh;
      b = v;
      break;

    case 5:
      r = v;
      g = wh;
      b = n;
      break;
  }

  return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
  var c = cmyk[0] / 100;
  var m = cmyk[1] / 100;
  var y = cmyk[2] / 100;
  var k = cmyk[3] / 100;
  var r;
  var g;
  var b;
  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
  var x = xyz[0] / 100;
  var y = xyz[1] / 100;
  var z = xyz[2] / 100;
  var r;
  var g;
  var b;
  r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

  r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
  g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
  b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  var l;
  var a;
  var b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
};

convert.lab.xyz = function (lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var x;
  var y;
  var z;
  y = (l + 16) / 116;
  x = a / 500 + y;
  z = y - b / 200;
  var y2 = Math.pow(y, 3);
  var x2 = Math.pow(x, 3);
  var z2 = Math.pow(z, 3);
  y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
  z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
  x *= 95.047;
  y *= 100;
  z *= 108.883;
  return [x, y, z];
};

convert.lab.lch = function (lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var hr;
  var h;
  var c;
  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;

  if (h < 0) {
    h += 360;
  }

  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
};

convert.lch.lab = function (lch) {
  var l = lch[0];
  var c = lch[1];
  var h = lch[2];
  var a;
  var b;
  var hr;
  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
  var r = args[0];
  var g = args[1];
  var b = args[2];
  var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

  value = Math.round(value / 50);

  if (value === 0) {
    return 30;
  }

  var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

  if (value === 2) {
    ansi += 60;
  }

  return ansi;
};

convert.hsv.ansi16 = function (args) {
  // optimization here; we already know the value and don't need to get
  // it converted for us.
  return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
  var r = args[0];
  var g = args[1];
  var b = args[2]; // we use the extended greyscale palette here, with the exception of
  // black and white. normal palette only has 4 greyscale shades.

  if (r === g && g === b) {
    if (r < 8) {
      return 16;
    }

    if (r > 248) {
      return 231;
    }

    return Math.round((r - 8) / 247 * 24) + 232;
  }

  var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
};

convert.ansi16.rgb = function (args) {
  var color = args % 10; // handle greyscale

  if (color === 0 || color === 7) {
    if (args > 50) {
      color += 3.5;
    }

    color = color / 10.5 * 255;
    return [color, color, color];
  }

  var mult = (~~(args > 50) + 1) * 0.5;
  var r = (color & 1) * mult * 255;
  var g = (color >> 1 & 1) * mult * 255;
  var b = (color >> 2 & 1) * mult * 255;
  return [r, g, b];
};

convert.ansi256.rgb = function (args) {
  // handle greyscale
  if (args >= 232) {
    var c = (args - 232) * 10 + 8;
    return [c, c, c];
  }

  args -= 16;
  var rem;
  var r = Math.floor(args / 36) / 5 * 255;
  var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
  var b = rem % 6 / 5 * 255;
  return [r, g, b];
};

convert.rgb.hex = function (args) {
  var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
  var string = integer.toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
  var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

  if (!match) {
    return [0, 0, 0];
  }

  var colorString = match[0];

  if (match[0].length === 3) {
    colorString = colorString.split('').map(function (char) {
      return char + char;
    }).join('');
  }

  var integer = parseInt(colorString, 16);
  var r = integer >> 16 & 0xFF;
  var g = integer >> 8 & 0xFF;
  var b = integer & 0xFF;
  return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var max = Math.max(Math.max(r, g), b);
  var min = Math.min(Math.min(r, g), b);
  var chroma = max - min;
  var grayscale;
  var hue;

  if (chroma < 1) {
    grayscale = min / (1 - chroma);
  } else {
    grayscale = 0;
  }

  if (chroma <= 0) {
    hue = 0;
  } else if (max === r) {
    hue = (g - b) / chroma % 6;
  } else if (max === g) {
    hue = 2 + (b - r) / chroma;
  } else {
    hue = 4 + (r - g) / chroma + 4;
  }

  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var c = 1;
  var f = 0;

  if (l < 0.5) {
    c = 2.0 * s * l;
  } else {
    c = 2.0 * s * (1.0 - l);
  }

  if (c < 1.0) {
    f = (l - 0.5 * c) / (1.0 - c);
  }

  return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var c = s * v;
  var f = 0;

  if (c < 1.0) {
    f = (v - c) / (1 - c);
  }

  return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
  var h = hcg[0] / 360;
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;

  if (c === 0.0) {
    return [g * 255, g * 255, g * 255];
  }

  var pure = [0, 0, 0];
  var hi = h % 1 * 6;
  var v = hi % 1;
  var w = 1 - v;
  var mg = 0;

  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1;
      pure[1] = v;
      pure[2] = 0;
      break;

    case 1:
      pure[0] = w;
      pure[1] = 1;
      pure[2] = 0;
      break;

    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v;
      break;

    case 3:
      pure[0] = 0;
      pure[1] = w;
      pure[2] = 1;
      break;

    case 4:
      pure[0] = v;
      pure[1] = 0;
      pure[2] = 1;
      break;

    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w;
  }

  mg = (1.0 - c) * g;
  return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
};

convert.hcg.hsv = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1.0 - c);
  var f = 0;

  if (v > 0.0) {
    f = c / v;
  }

  return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var l = g * (1.0 - c) + 0.5 * c;
  var s = 0;

  if (l > 0.0 && l < 0.5) {
    s = c / (2 * l);
  } else if (l >= 0.5 && l < 1.0) {
    s = c / (2 * (1 - l));
  }

  return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1.0 - c);
  return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
  var w = hwb[1] / 100;
  var b = hwb[2] / 100;
  var v = 1 - b;
  var c = v - w;
  var g = 0;

  if (c < 1) {
    g = (v - c) / (1 - c);
  }

  return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};

convert.rgb.apple = function (rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};

convert.gray.rgb = function (args) {
  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
  return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
  return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
  return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
  return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
  var val = Math.round(gray[0] / 100 * 255) & 0xFF;
  var integer = (val << 16) + (val << 8) + val;
  var string = integer.toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
  var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [val / 255 * 100];
};
});

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/


function buildGraph() {
  var graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3

  var models = Object.keys(conversions);

  for (var len = models.length, i = 0; i < len; i++) {
    graph[models[i]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  }

  return graph;
} // https://en.wikipedia.org/wiki/Breadth-first_search


function deriveBFS(fromModel) {
  var graph = buildGraph();
  var queue = [fromModel]; // unshift -> queue -> pop

  graph[fromModel].distance = 0;

  while (queue.length) {
    var current = queue.pop();
    var adjacents = Object.keys(conversions[current]);

    for (var len = adjacents.length, i = 0; i < len; i++) {
      var adjacent = adjacents[i];
      var node = graph[adjacent];

      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }

  return graph;
}

function link(from, to) {
  return function (args) {
    return to(from(args));
  };
}

function wrapConversion(toModel, graph) {
  var path = [graph[toModel].parent, toModel];
  var fn = conversions[graph[toModel].parent][toModel];
  var cur = graph[toModel].parent;

  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link(conversions[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }

  fn.conversion = path;
  return fn;
}

var route = function (fromModel) {
  var graph = deriveBFS(fromModel);
  var conversion = {};
  var models = Object.keys(graph);

  for (var len = models.length, i = 0; i < len; i++) {
    var toModel = models[i];
    var node = graph[toModel];

    if (node.parent === null) {
      // no possible conversion, or this node is the source model.
      continue;
    }

    conversion[toModel] = wrapConversion(toModel, graph);
  }

  return conversion;
};

var convert = {};
var models = Object.keys(conversions);

function wrapRaw(fn) {
  var wrappedFn = function (args) {
    if (args === undefined || args === null) {
      return args;
    }

    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }

    return fn(args);
  }; // preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

function wrapRounded(fn) {
  var wrappedFn = function (args) {
    if (args === undefined || args === null) {
      return args;
    }

    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }

    var result = fn(args); // we're assuming the result is an array here.
    // see notice in conversions.js; don't use box types
    // in conversion functions.

    if (typeof result === 'object') {
      for (var len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }

    return result;
  }; // preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

models.forEach(function (fromModel) {
  convert[fromModel] = {};
  Object.defineProperty(convert[fromModel], 'channels', {
    value: conversions[fromModel].channels
  });
  Object.defineProperty(convert[fromModel], 'labels', {
    value: conversions[fromModel].labels
  });
  var routes = route(fromModel);
  var routeModels = Object.keys(routes);
  routeModels.forEach(function (toModel) {
    var fn = routes[toModel];
    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});
var colorConvert = convert;

var ansiStyles = createCommonjsModule(function (module) {



const wrapAnsi16 = (fn, offset) => function () {
  const code = fn.apply(colorConvert, arguments);
  return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => function () {
  const code = fn.apply(colorConvert, arguments);
  return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => function () {
  const rgb = fn.apply(colorConvert, arguments);
  return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

function assembleStyles() {
  const codes = new Map();
  const styles = {
    modifier: {
      reset: [0, 0],
      // 21 isn't widely supported and 22 does the same thing
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      // Bright color
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      // Bright color
      bgBlackBright: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  }; // Fix humans

  styles.color.grey = styles.color.gray;

  for (const groupName of Object.keys(styles)) {
    const group = styles[groupName];

    for (const styleName of Object.keys(group)) {
      const style = group[styleName];
      styles[styleName] = {
        open: `\u001B[${style[0]}m`,
        close: `\u001B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }

    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
    Object.defineProperty(styles, 'codes', {
      value: codes,
      enumerable: false
    });
  }

  const ansi2ansi = n => n;

  const rgb2rgb = (r, g, b) => [r, g, b];

  styles.color.close = '\u001B[39m';
  styles.bgColor.close = '\u001B[49m';
  styles.color.ansi = {
    ansi: wrapAnsi16(ansi2ansi, 0)
  };
  styles.color.ansi256 = {
    ansi256: wrapAnsi256(ansi2ansi, 0)
  };
  styles.color.ansi16m = {
    rgb: wrapAnsi16m(rgb2rgb, 0)
  };
  styles.bgColor.ansi = {
    ansi: wrapAnsi16(ansi2ansi, 10)
  };
  styles.bgColor.ansi256 = {
    ansi256: wrapAnsi256(ansi2ansi, 10)
  };
  styles.bgColor.ansi16m = {
    rgb: wrapAnsi16m(rgb2rgb, 10)
  };

  for (let key of Object.keys(colorConvert)) {
    if (typeof colorConvert[key] !== 'object') {
      continue;
    }

    const suite = colorConvert[key];

    if (key === 'ansi16') {
      key = 'ansi';
    }

    if ('ansi16' in suite) {
      styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
      styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
    }

    if ('ansi256' in suite) {
      styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
      styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
    }

    if ('rgb' in suite) {
      styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
      styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
    }
  }

  return styles;
} // Make the export immutable


Object.defineProperty(module, 'exports', {
  enumerable: true,
  get: assembleStyles
});
});

const ESCAPES = new Set(['\u001B', '\u009B']);
const END_CODE = 39;

const wrapAnsi = code => `${ESCAPES.values().next().value}[${code}m`; // Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes


const wordLengths = string => string.split(' ').map(character => stringWidth(character)); // Wrap a long word across multiple rows
// Ansi escape codes do not count towards length


const wrapWord = (rows, word, columns) => {
  const characters = [...word];
  let insideEscape = false;
  let visible = stringWidth(stripAnsi(rows[rows.length - 1]));

  for (const [index, character] of characters.entries()) {
    const characterLength = stringWidth(character);

    if (visible + characterLength <= columns) {
      rows[rows.length - 1] += character;
    } else {
      rows.push(character);
      visible = 0;
    }

    if (ESCAPES.has(character)) {
      insideEscape = true;
    } else if (insideEscape && character === 'm') {
      insideEscape = false;
      continue;
    }

    if (insideEscape) {
      continue;
    }

    visible += characterLength;

    if (visible === columns && index < characters.length - 1) {
      rows.push('');
      visible = 0;
    }
  } // It's possible that the last row we copy over is only
  // ansi escape characters, handle this edge-case


  if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
    rows[rows.length - 2] += rows.pop();
  }
}; // Trims spaces from a string ignoring invisible sequences


const stringVisibleTrimSpacesRight = str => {
  const words = str.split(' ');
  let last = words.length;

  while (last > 0) {
    if (stringWidth(words[last - 1]) > 0) {
      break;
    }

    last--;
  }

  if (last === words.length) {
    return str;
  }

  return words.slice(0, last).join(' ') + words.slice(last).join('');
}; // The wrap-ansi module can be invoked
// in either 'hard' or 'soft' wrap mode
//
// 'hard' will never allow a string to take up more
// than columns characters
//
// 'soft' allows long words to expand past the column length


const exec = (string, columns, options = {}) => {
  if (options.trim !== false && string.trim() === '') {
    return '';
  }

  let pre = '';
  let ret = '';
  let escapeCode;
  const lengths = wordLengths(string);
  let rows = [''];

  for (const [index, word] of string.split(' ').entries()) {
    if (options.trim !== false) {
      rows[rows.length - 1] = rows[rows.length - 1].trimLeft();
    }

    let rowLength = stringWidth(rows[rows.length - 1]);

    if (index !== 0) {
      if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
        // If we start with a new word but the current row length equals the length of the columns, add a new row
        rows.push('');
        rowLength = 0;
      }

      if (rowLength > 0 || options.trim === false) {
        rows[rows.length - 1] += ' ';
        rowLength++;
      }
    } // In 'hard' wrap mode, the length of a line is
    // never allowed to extend past 'columns'


    if (options.hard && lengths[index] > columns) {
      const remainingColumns = columns - rowLength;
      const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
      const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);

      if (breaksStartingNextLine < breaksStartingThisLine) {
        rows.push('');
      }

      wrapWord(rows, word, columns);
      continue;
    }

    if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
      if (options.wordWrap === false && rowLength < columns) {
        wrapWord(rows, word, columns);
        continue;
      }

      rows.push('');
    }

    if (rowLength + lengths[index] > columns && options.wordWrap === false) {
      wrapWord(rows, word, columns);
      continue;
    }

    rows[rows.length - 1] += word;
  }

  if (options.trim !== false) {
    rows = rows.map(stringVisibleTrimSpacesRight);
  }

  pre = rows.join('\n');

  for (const [index, character] of [...pre].entries()) {
    ret += character;

    if (ESCAPES.has(character)) {
      const code = parseFloat(/\d[^m]*/.exec(pre.slice(index, index + 4)));
      escapeCode = code === END_CODE ? null : code;
    }

    const code = ansiStyles.codes.get(Number(escapeCode));

    if (escapeCode && code) {
      if (pre[index + 1] === '\n') {
        ret += wrapAnsi(code);
      } else if (character === '\n') {
        ret += wrapAnsi(escapeCode);
      }
    }
  }

  return ret;
}; // For each newline, invoke the method separately


var wrapAnsi_1 = (string, columns, options) => {
  return String(string).normalize().split('\n').map(line => exec(line, columns, options)).join('\n');
};

var logUpdate = createCommonjsModule(function (module) {







const getWidth = stream => {
  const {
    columns
  } = stream;

  if (!columns) {
    return 80;
  } // Windows appears to wrap a character early
  // I hate Windows so much


  if (process.platform === 'win32') {
    return columns - 1;
  }

  return columns;
};

const main = (stream, options) => {
  options = Object.assign({
    showCursor: false
  }, options);
  let prevLineCount = 0;

  const render = (...args) => {
    if (!options.showCursor) {
      cliCursor.hide();
    }

    let out = args.join(' ') + '\n';
    out = wrapAnsi_1(out, getWidth(stream), {
      trim: false,
      hard: true,
      wordWrap: false
    });
    stream.write(ansiEscapes.eraseLines(prevLineCount) + out);
    prevLineCount = out.split('\n').length;
  };

  render.clear = () => {
    stream.write(ansiEscapes.eraseLines(prevLineCount));
    prevLineCount = 0;
  };

  render.done = () => {
    prevLineCount = 0;

    if (!options.showCursor) {
      cliCursor.show();
    }
  };

  return render;
};

module.exports = main(process.stdout);
module.exports.default = module.exports;
module.exports.stderr = main(process.stderr);
module.exports.create = main;
});

var vendors = [{
  name: "AppVeyor",
  constant: "APPVEYOR",
  env: "APPVEYOR",
  pr: "APPVEYOR_PULL_REQUEST_NUMBER"
}, {
  name: "Azure Pipelines",
  constant: "AZURE_PIPELINES",
  env: "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI",
  pr: "SYSTEM_PULLREQUEST_PULLREQUESTID"
}, {
  name: "Bamboo",
  constant: "BAMBOO",
  env: "bamboo_planKey"
}, {
  name: "Bitbucket Pipelines",
  constant: "BITBUCKET",
  env: "BITBUCKET_COMMIT",
  pr: "BITBUCKET_PR_ID"
}, {
  name: "Bitrise",
  constant: "BITRISE",
  env: "BITRISE_IO",
  pr: "BITRISE_PULL_REQUEST"
}, {
  name: "Buddy",
  constant: "BUDDY",
  env: "BUDDY_WORKSPACE_ID",
  pr: "BUDDY_EXECUTION_PULL_REQUEST_ID"
}, {
  name: "Buildkite",
  constant: "BUILDKITE",
  env: "BUILDKITE",
  pr: {
    env: "BUILDKITE_PULL_REQUEST",
    ne: "false"
  }
}, {
  name: "CircleCI",
  constant: "CIRCLE",
  env: "CIRCLECI",
  pr: "CIRCLE_PULL_REQUEST"
}, {
  name: "Cirrus CI",
  constant: "CIRRUS",
  env: "CIRRUS_CI",
  pr: "CIRRUS_PR"
}, {
  name: "AWS CodeBuild",
  constant: "CODEBUILD",
  env: "CODEBUILD_BUILD_ARN"
}, {
  name: "Codeship",
  constant: "CODESHIP",
  env: {
    CI_NAME: "codeship"
  }
}, {
  name: "Drone",
  constant: "DRONE",
  env: "DRONE",
  pr: {
    DRONE_BUILD_EVENT: "pull_request"
  }
}, {
  name: "dsari",
  constant: "DSARI",
  env: "DSARI"
}, {
  name: "GitLab CI",
  constant: "GITLAB",
  env: "GITLAB_CI"
}, {
  name: "GoCD",
  constant: "GOCD",
  env: "GO_PIPELINE_LABEL"
}, {
  name: "Hudson",
  constant: "HUDSON",
  env: "HUDSON_URL"
}, {
  name: "Jenkins",
  constant: "JENKINS",
  env: ["JENKINS_URL", "BUILD_ID"],
  pr: {
    any: ["ghprbPullId", "CHANGE_ID"]
  }
}, {
  name: "Magnum CI",
  constant: "MAGNUM",
  env: "MAGNUM"
}, {
  name: "Netlify CI",
  constant: "NETLIFY",
  env: "NETLIFY_BUILD_BASE",
  pr: {
    env: "PULL_REQUEST",
    ne: "false"
  }
}, {
  name: "Sail CI",
  constant: "SAIL",
  env: "SAILCI",
  pr: "SAIL_PULL_REQUEST_NUMBER"
}, {
  name: "Semaphore",
  constant: "SEMAPHORE",
  env: "SEMAPHORE",
  pr: "PULL_REQUEST_NUMBER"
}, {
  name: "Shippable",
  constant: "SHIPPABLE",
  env: "SHIPPABLE",
  pr: {
    IS_PULL_REQUEST: "true"
  }
}, {
  name: "Solano CI",
  constant: "SOLANO",
  env: "TDDIUM",
  pr: "TDDIUM_PR_ID"
}, {
  name: "Strider CD",
  constant: "STRIDER",
  env: "STRIDER"
}, {
  name: "TaskCluster",
  constant: "TASKCLUSTER",
  env: ["TASK_ID", "RUN_ID"]
}, {
  name: "TeamCity",
  constant: "TEAMCITY",
  env: "TEAMCITY_VERSION"
}, {
  name: "Travis CI",
  constant: "TRAVIS",
  env: "TRAVIS",
  pr: {
    env: "TRAVIS_PULL_REQUEST",
    ne: "false"
  }
}];

var vendors$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	'default': vendors
});

var vendors$2 = getCjsExportFromNamespace(vendors$1);

var ciInfo = createCommonjsModule(function (module, exports) {



var env = process.env; // Used for testing only

Object.defineProperty(exports, '_vendors', {
  value: vendors$2.map(function (v) {
    return v.constant;
  })
});
exports.name = null;
exports.isPR = null;
vendors$2.forEach(function (vendor) {
  var envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env];
  var isCI = envs.every(function (obj) {
    return checkEnv(obj);
  });
  exports[vendor.constant] = isCI;

  if (isCI) {
    exports.name = vendor.name;

    switch (typeof vendor.pr) {
      case 'string':
        // "pr": "CIRRUS_PR"
        exports.isPR = !!env[vendor.pr];
        break;

      case 'object':
        if ('env' in vendor.pr) {
          // "pr": { "env": "BUILDKITE_PULL_REQUEST", "ne": "false" }
          exports.isPR = vendor.pr.env in env && env[vendor.pr.env] !== vendor.pr.ne;
        } else if ('any' in vendor.pr) {
          // "pr": { "any": ["ghprbPullId", "CHANGE_ID"] }
          exports.isPR = vendor.pr.any.some(function (key) {
            return !!env[key];
          });
        } else {
          // "pr": { "DRONE_BUILD_EVENT": "pull_request" }
          exports.isPR = checkEnv(vendor.pr);
        }

        break;

      default:
        // PR detection not supported for this vendor
        exports.isPR = null;
    }
  }
});
exports.isCI = !!(env.CI || // Travis CI, CircleCI, Cirrus CI, Gitlab CI, Appveyor, CodeShip, dsari
env.CONTINUOUS_INTEGRATION || // Travis CI, Cirrus CI
env.BUILD_NUMBER || // Jenkins, TeamCity
env.RUN_ID || // TaskCluster, dsari
exports.name || false);

function checkEnv(obj) {
  if (typeof obj === 'string') return !!env[obj];
  return Object.keys(obj).every(function (k) {
    return env[k] === obj[k];
  });
}
});

var isCi = ciInfo.isCI;

var ansiEscapes_1 = createCommonjsModule(function (module) {
const ansiEscapes = module.exports;
// TODO: remove this in the next major version
module.exports.default = ansiEscapes;

const ESC = '\u001B[';
const OSC = '\u001B]';
const BEL = '\u0007';
const SEP = ';';
const isTerminalApp = process.env.TERM_PROGRAM === 'Apple_Terminal';

ansiEscapes.cursorTo = (x, y) => {
	if (typeof x !== 'number') {
		throw new TypeError('The `x` argument is required');
	}

	if (typeof y !== 'number') {
		return ESC + (x + 1) + 'G';
	}

	return ESC + (y + 1) + ';' + (x + 1) + 'H';
};

ansiEscapes.cursorMove = (x, y) => {
	if (typeof x !== 'number') {
		throw new TypeError('The `x` argument is required');
	}

	let ret = '';

	if (x < 0) {
		ret += ESC + (-x) + 'D';
	} else if (x > 0) {
		ret += ESC + x + 'C';
	}

	if (y < 0) {
		ret += ESC + (-y) + 'A';
	} else if (y > 0) {
		ret += ESC + y + 'B';
	}

	return ret;
};

ansiEscapes.cursorUp = (count = 1) => ESC + count + 'A';
ansiEscapes.cursorDown = (count = 1) => ESC + count + 'B';
ansiEscapes.cursorForward = (count = 1) => ESC + count + 'C';
ansiEscapes.cursorBackward = (count = 1) => ESC + count + 'D';

ansiEscapes.cursorLeft = ESC + 'G';
ansiEscapes.cursorSavePosition = isTerminalApp ? '\u001B7' : ESC + 's';
ansiEscapes.cursorRestorePosition = isTerminalApp ? '\u001B8' : ESC + 'u';
ansiEscapes.cursorGetPosition = ESC + '6n';
ansiEscapes.cursorNextLine = ESC + 'E';
ansiEscapes.cursorPrevLine = ESC + 'F';
ansiEscapes.cursorHide = ESC + '?25l';
ansiEscapes.cursorShow = ESC + '?25h';

ansiEscapes.eraseLines = count => {
	let clear = '';

	for (let i = 0; i < count; i++) {
		clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : '');
	}

	if (count) {
		clear += ansiEscapes.cursorLeft;
	}

	return clear;
};

ansiEscapes.eraseEndLine = ESC + 'K';
ansiEscapes.eraseStartLine = ESC + '1K';
ansiEscapes.eraseLine = ESC + '2K';
ansiEscapes.eraseDown = ESC + 'J';
ansiEscapes.eraseUp = ESC + '1J';
ansiEscapes.eraseScreen = ESC + '2J';
ansiEscapes.scrollUp = ESC + 'S';
ansiEscapes.scrollDown = ESC + 'T';

ansiEscapes.clearScreen = '\u001Bc';

ansiEscapes.clearTerminal = process.platform === 'win32' ?
	`${ansiEscapes.eraseScreen}${ESC}0f` :
	// 1. Erases the screen (Only done in case `2` is not supported)
	// 2. Erases the whole screen including scrollback buffer
	// 3. Moves cursor to the top-left position
	// More info: https://www.real-world-systems.com/docs/ANSIcode.html
	`${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;

ansiEscapes.beep = BEL;

ansiEscapes.link = (text, url) => {
	return [
		OSC,
		'8',
		SEP,
		SEP,
		url,
		BEL,
		text,
		OSC,
		'8',
		SEP,
		SEP,
		BEL
	].join('');
};

ansiEscapes.image = (buffer, options = {}) => {
	let ret = `${OSC}1337;File=inline=1`;

	if (options.width) {
		ret += `;width=${options.width}`;
	}

	if (options.height) {
		ret += `;height=${options.height}`;
	}

	if (options.preserveAspectRatio === false) {
		ret += ';preserveAspectRatio=0';
	}

	return ret + ':' + buffer.toString('base64') + BEL;
};

ansiEscapes.iTerm = {
	setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,

	annotation: (message, options = {}) => {
		let ret = `${OSC}1337;`;

		const hasX = typeof options.x !== 'undefined';
		const hasY = typeof options.y !== 'undefined';
		if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== 'undefined')) {
			throw new Error('`x`, `y` and `length` must be defined when `x` or `y` is defined');
		}

		message = message.replace(/\|/g, '');

		ret += options.isHidden ? 'AddHiddenAnnotation=' : 'AddAnnotation=';

		if (options.length > 0) {
			ret +=
					(hasX ?
						[message, options.length, options.x, options.y] :
						[options.length, message]).join('|');
		} else {
			ret += message;
		}

		return ret + BEL;
	}
};
});

var scheduler_production_min = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: !0
});
var f, g, h, k, l;

if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
  var p = null,
      q = null,
      t = function () {
    if (null !== p) try {
      var a = exports.unstable_now();
      p(!0, a);
      p = null;
    } catch (b) {
      throw setTimeout(t, 0), b;
    }
  },
      u = Date.now();

  exports.unstable_now = function () {
    return Date.now() - u;
  };

  f = function (a) {
    null !== p ? setTimeout(f, 0, a) : (p = a, setTimeout(t, 0));
  };

  g = function (a, b) {
    q = setTimeout(a, b);
  };

  h = function () {
    clearTimeout(q);
  };

  k = function () {
    return !1;
  };

  l = exports.unstable_forceFrameRate = function () {};
} else {
  var w = window.performance,
      x = window.Date,
      y = window.setTimeout,
      z = window.clearTimeout;

  if ("undefined" !== typeof console) {
    var A = window.cancelAnimationFrame;
    "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
    "function" !== typeof A && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
  }

  if ("object" === typeof w && "function" === typeof w.now) exports.unstable_now = function () {
    return w.now();
  };else {
    var B = x.now();

    exports.unstable_now = function () {
      return x.now() - B;
    };
  }
  var C = !1,
      D = null,
      E = -1,
      F = 5,
      G = 0;

  k = function () {
    return exports.unstable_now() >= G;
  };

  l = function () {};

  exports.unstable_forceFrameRate = function (a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported") : F = 0 < a ? Math.floor(1E3 / a) : 5;
  };

  var H = new MessageChannel(),
      I = H.port2;

  H.port1.onmessage = function () {
    if (null !== D) {
      var a = exports.unstable_now();
      G = a + F;

      try {
        D(!0, a) ? I.postMessage(null) : (C = !1, D = null);
      } catch (b) {
        throw I.postMessage(null), b;
      }
    } else C = !1;
  };

  f = function (a) {
    D = a;
    C || (C = !0, I.postMessage(null));
  };

  g = function (a, b) {
    E = y(function () {
      a(exports.unstable_now());
    }, b);
  };

  h = function () {
    z(E);
    E = -1;
  };
}

function J(a, b) {
  var c = a.length;
  a.push(b);

  a: for (;;) {
    var d = Math.floor((c - 1) / 2),
        e = a[d];
    if (void 0 !== e && 0 < K(e, b)) a[d] = b, a[c] = e, c = d;else break a;
  }
}

function L(a) {
  a = a[0];
  return void 0 === a ? null : a;
}

function M(a) {
  var b = a[0];

  if (void 0 !== b) {
    var c = a.pop();

    if (c !== b) {
      a[0] = c;

      a: for (var d = 0, e = a.length; d < e;) {
        var m = 2 * (d + 1) - 1,
            n = a[m],
            v = m + 1,
            r = a[v];
        if (void 0 !== n && 0 > K(n, c)) void 0 !== r && 0 > K(r, n) ? (a[d] = r, a[v] = c, d = v) : (a[d] = n, a[m] = c, d = m);else if (void 0 !== r && 0 > K(r, c)) a[d] = r, a[v] = c, d = v;else break a;
      }
    }

    return b;
  }

  return null;
}

function K(a, b) {
  var c = a.sortIndex - b.sortIndex;
  return 0 !== c ? c : a.id - b.id;
}

var N = [],
    O = [],
    P = 1,
    Q = null,
    R = 3,
    S = !1,
    T = !1,
    U = !1;

function V(a) {
  for (var b = L(O); null !== b;) {
    if (null === b.callback) M(O);else if (b.startTime <= a) M(O), b.sortIndex = b.expirationTime, J(N, b);else break;
    b = L(O);
  }
}

function W(a) {
  U = !1;
  V(a);
  if (!T) if (null !== L(N)) T = !0, f(X);else {
    var b = L(O);
    null !== b && g(W, b.startTime - a);
  }
}

function X(a, b) {
  T = !1;
  U && (U = !1, h());
  S = !0;
  var c = R;

  try {
    V(b);

    for (Q = L(N); null !== Q && (!(Q.expirationTime > b) || a && !k());) {
      var d = Q.callback;

      if (null !== d) {
        Q.callback = null;
        R = Q.priorityLevel;
        var e = d(Q.expirationTime <= b);
        b = exports.unstable_now();
        "function" === typeof e ? Q.callback = e : Q === L(N) && M(N);
        V(b);
      } else M(N);

      Q = L(N);
    }

    if (null !== Q) var m = !0;else {
      var n = L(O);
      null !== n && g(W, n.startTime - b);
      m = !1;
    }
    return m;
  } finally {
    Q = null, R = c, S = !1;
  }
}

function Y(a) {
  switch (a) {
    case 1:
      return -1;

    case 2:
      return 250;

    case 5:
      return 1073741823;

    case 4:
      return 1E4;

    default:
      return 5E3;
  }
}

var Z = l;
exports.unstable_ImmediatePriority = 1;
exports.unstable_UserBlockingPriority = 2;
exports.unstable_NormalPriority = 3;
exports.unstable_IdlePriority = 5;
exports.unstable_LowPriority = 4;

exports.unstable_runWithPriority = function (a, b) {
  switch (a) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      break;

    default:
      a = 3;
  }

  var c = R;
  R = a;

  try {
    return b();
  } finally {
    R = c;
  }
};

exports.unstable_next = function (a) {
  switch (R) {
    case 1:
    case 2:
    case 3:
      var b = 3;
      break;

    default:
      b = R;
  }

  var c = R;
  R = b;

  try {
    return a();
  } finally {
    R = c;
  }
};

exports.unstable_scheduleCallback = function (a, b, c) {
  var d = exports.unstable_now();

  if ("object" === typeof c && null !== c) {
    var e = c.delay;
    e = "number" === typeof e && 0 < e ? d + e : d;
    c = "number" === typeof c.timeout ? c.timeout : Y(a);
  } else c = Y(a), e = d;

  c = e + c;
  a = {
    id: P++,
    callback: b,
    priorityLevel: a,
    startTime: e,
    expirationTime: c,
    sortIndex: -1
  };
  e > d ? (a.sortIndex = e, J(O, a), null === L(N) && a === L(O) && (U ? h() : U = !0, g(W, e - d))) : (a.sortIndex = c, J(N, a), T || S || (T = !0, f(X)));
  return a;
};

exports.unstable_cancelCallback = function (a) {
  a.callback = null;
};

exports.unstable_wrapCallback = function (a) {
  var b = R;
  return function () {
    var c = R;
    R = b;

    try {
      return a.apply(this, arguments);
    } finally {
      R = c;
    }
  };
};

exports.unstable_getCurrentPriorityLevel = function () {
  return R;
};

exports.unstable_shouldYield = function () {
  var a = exports.unstable_now();
  V(a);
  var b = L(N);
  return b !== Q && null !== Q && null !== b && null !== b.callback && b.startTime <= a && b.expirationTime < Q.expirationTime || k();
};

exports.unstable_requestPaint = Z;

exports.unstable_continueExecution = function () {
  T || S || (T = !0, f(X));
};

exports.unstable_pauseExecution = function () {};

exports.unstable_getFirstCallbackNode = function () {
  return L(N);
};

exports.unstable_Profiling = null;
});

var scheduler = createCommonjsModule(function (module) {

{
  module.exports = scheduler_production_min;
}
});

var reactReconciler_production_min = createCommonjsModule(function (module) {
/** @license React v0.24.0
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
module.exports = function $$$reconciler($$$hostConfig) {

  var aa = objectAssign,
      ba = react,
      m = scheduler;

  function n(a) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);

    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }

  var q = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  q.hasOwnProperty("ReactCurrentDispatcher") || (q.ReactCurrentDispatcher = {
    current: null
  });
  q.hasOwnProperty("ReactCurrentBatchConfig") || (q.ReactCurrentBatchConfig = {
    suspense: null
  });
  var u = "function" === typeof Symbol && Symbol.for,
      ca = u ? Symbol.for("react.element") : 60103,
      da = u ? Symbol.for("react.portal") : 60106,
      ea = u ? Symbol.for("react.fragment") : 60107,
      fa = u ? Symbol.for("react.strict_mode") : 60108,
      ha = u ? Symbol.for("react.profiler") : 60114,
      ia = u ? Symbol.for("react.provider") : 60109,
      ja = u ? Symbol.for("react.context") : 60110,
      ka = u ? Symbol.for("react.concurrent_mode") : 60111,
      la = u ? Symbol.for("react.forward_ref") : 60112,
      ma = u ? Symbol.for("react.suspense") : 60113,
      na = u ? Symbol.for("react.suspense_list") : 60120,
      oa = u ? Symbol.for("react.memo") : 60115,
      pa = u ? Symbol.for("react.lazy") : 60116;
  var qa = "function" === typeof Symbol && Symbol.iterator;

  function ra(a) {
    if (null === a || "object" !== typeof a) return null;
    a = qa && a[qa] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }

  function sa(a) {
    if (-1 === a._status) {
      a._status = 0;
      var b = a._ctor;
      b = b();
      a._result = b;
      b.then(function (b) {
        0 === a._status && (b = b.default, a._status = 1, a._result = b);
      }, function (b) {
        0 === a._status && (a._status = 2, a._result = b);
      });
    }
  }

  function ta(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;

    switch (a) {
      case ea:
        return "Fragment";

      case da:
        return "Portal";

      case ha:
        return "Profiler";

      case fa:
        return "StrictMode";

      case ma:
        return "Suspense";

      case na:
        return "SuspenseList";
    }

    if ("object" === typeof a) switch (a.$$typeof) {
      case ja:
        return "Context.Consumer";

      case ia:
        return "Context.Provider";

      case la:
        var b = a.render;
        b = b.displayName || b.name || "";
        return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");

      case oa:
        return ta(a.type);

      case pa:
        if (a = 1 === a._status ? a._result : null) return ta(a);
    }
    return null;
  }

  function ua(a) {
    var b = a,
        c = a;
    if (a.alternate) for (; b.return;) b = b.return;else {
      a = b;

      do b = a, 0 !== (b.effectTag & 1026) && (c = b.return), a = b.return; while (a);
    }
    return 3 === b.tag ? c : null;
  }

  function va(a) {
    if (ua(a) !== a) throw Error(n(188));
  }

  function wa(a) {
    var b = a.alternate;

    if (!b) {
      b = ua(a);
      if (null === b) throw Error(n(188));
      return b !== a ? null : a;
    }

    for (var c = a, d = b;;) {
      var e = c.return;
      if (null === e) break;
      var f = e.alternate;

      if (null === f) {
        d = e.return;

        if (null !== d) {
          c = d;
          continue;
        }

        break;
      }

      if (e.child === f.child) {
        for (f = e.child; f;) {
          if (f === c) return va(e), a;
          if (f === d) return va(e), b;
          f = f.sibling;
        }

        throw Error(n(188));
      }

      if (c.return !== d.return) c = e, d = f;else {
        for (var g = !1, l = e.child; l;) {
          if (l === c) {
            g = !0;
            c = e;
            d = f;
            break;
          }

          if (l === d) {
            g = !0;
            d = e;
            c = f;
            break;
          }

          l = l.sibling;
        }

        if (!g) {
          for (l = f.child; l;) {
            if (l === c) {
              g = !0;
              c = f;
              d = e;
              break;
            }

            if (l === d) {
              g = !0;
              d = f;
              c = e;
              break;
            }

            l = l.sibling;
          }

          if (!g) throw Error(n(189));
        }
      }
      if (c.alternate !== d) throw Error(n(190));
    }

    if (3 !== c.tag) throw Error(n(188));
    return c.stateNode.current === c ? a : b;
  }

  function xa(a) {
    a = wa(a);
    if (!a) return null;

    for (var b = a;;) {
      if (5 === b.tag || 6 === b.tag) return b;
      if (b.child) b.child.return = b, b = b.child;else {
        if (b === a) break;

        for (; !b.sibling;) {
          if (!b.return || b.return === a) return null;
          b = b.return;
        }

        b.sibling.return = b.return;
        b = b.sibling;
      }
    }

    return null;
  }

  function ya(a) {
    a = wa(a);
    if (!a) return null;

    for (var b = a;;) {
      if (5 === b.tag || 6 === b.tag) return b;
      if (b.child && 4 !== b.tag) b.child.return = b, b = b.child;else {
        if (b === a) break;

        for (; !b.sibling;) {
          if (!b.return || b.return === a) return null;
          b = b.return;
        }

        b.sibling.return = b.return;
        b = b.sibling;
      }
    }

    return null;
  }

  var za = $$$hostConfig.getPublicInstance,
      Aa = $$$hostConfig.getRootHostContext,
      Ba = $$$hostConfig.getChildHostContext,
      Ca = $$$hostConfig.prepareForCommit,
      Da = $$$hostConfig.resetAfterCommit,
      Ea = $$$hostConfig.createInstance,
      Fa = $$$hostConfig.appendInitialChild,
      Ga = $$$hostConfig.finalizeInitialChildren,
      Ia = $$$hostConfig.prepareUpdate,
      Ja = $$$hostConfig.shouldSetTextContent,
      Ka = $$$hostConfig.shouldDeprioritizeSubtree,
      La = $$$hostConfig.createTextInstance,
      Ma = $$$hostConfig.setTimeout,
      Na = $$$hostConfig.clearTimeout,
      Oa = $$$hostConfig.noTimeout,
      Pa = $$$hostConfig.isPrimaryRenderer,
      Qa = $$$hostConfig.supportsMutation,
      Ra = $$$hostConfig.supportsPersistence,
      Sa = $$$hostConfig.supportsHydration,
      Ta = $$$hostConfig.appendChild,
      Ua = $$$hostConfig.appendChildToContainer,
      Va = $$$hostConfig.commitTextUpdate,
      Wa = $$$hostConfig.commitMount,
      Xa = $$$hostConfig.commitUpdate,
      Ya = $$$hostConfig.insertBefore,
      Za = $$$hostConfig.insertInContainerBefore,
      $a = $$$hostConfig.removeChild,
      ab = $$$hostConfig.removeChildFromContainer,
      bb = $$$hostConfig.resetTextContent,
      cb = $$$hostConfig.hideInstance,
      db = $$$hostConfig.hideTextInstance,
      eb = $$$hostConfig.unhideInstance,
      fb = $$$hostConfig.unhideTextInstance,
      gb = $$$hostConfig.cloneInstance,
      hb = $$$hostConfig.createContainerChildSet,
      ib = $$$hostConfig.appendChildToContainerChildSet,
      kb = $$$hostConfig.finalizeContainerChildren,
      lb = $$$hostConfig.replaceContainerChildren,
      mb = $$$hostConfig.cloneHiddenInstance,
      nb = $$$hostConfig.cloneHiddenTextInstance,
      ob = $$$hostConfig.canHydrateInstance,
      pb = $$$hostConfig.canHydrateTextInstance,
      qb = $$$hostConfig.isSuspenseInstancePending,
      rb = $$$hostConfig.isSuspenseInstanceFallback,
      sb = $$$hostConfig.getNextHydratableSibling,
      tb = $$$hostConfig.getFirstHydratableChild,
      ub = $$$hostConfig.hydrateInstance,
      vb = $$$hostConfig.hydrateTextInstance,
      wb = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance,
      xb = $$$hostConfig.commitHydratedContainer,
      yb = $$$hostConfig.commitHydratedSuspenseInstance,
      zb = /^(.*)[\\\/]/;

  function Ab(a) {
    var b = "";

    do {
      a: switch (a.tag) {
        case 3:
        case 4:
        case 6:
        case 7:
        case 10:
        case 9:
          var c = "";
          break a;

        default:
          var d = a._debugOwner,
              e = a._debugSource,
              f = ta(a.type);
          c = null;
          d && (c = ta(d.type));
          d = f;
          f = "";
          e ? f = " (at " + e.fileName.replace(zb, "") + ":" + e.lineNumber + ")" : c && (f = " (created by " + c + ")");
          c = "\n    in " + (d || "Unknown") + f;
      }

      b += c;
      a = a.return;
    } while (a);

    return b;
  }
  var Bb = [],
      Cb = -1;

  function y(a) {
    0 > Cb || (a.current = Bb[Cb], Bb[Cb] = null, Cb--);
  }

  function z(a, b) {
    Cb++;
    Bb[Cb] = a.current;
    a.current = b;
  }

  var Db = {},
      A = {
    current: Db
  },
      B = {
    current: !1
  },
      Eb = Db;

  function Fb(a, b) {
    var c = a.type.contextTypes;
    if (!c) return Db;
    var d = a.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
    var e = {},
        f;

    for (f in c) e[f] = b[f];

    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
    return e;
  }

  function C(a) {
    a = a.childContextTypes;
    return null !== a && void 0 !== a;
  }

  function Gb(a) {
    y(B);
    y(A);
  }

  function Hb(a) {
    y(B);
    y(A);
  }

  function Ib(a, b, c) {
    if (A.current !== Db) throw Error(n(168));
    z(A, b);
    z(B, c);
  }

  function Jb(a, b, c) {
    var d = a.stateNode;
    a = b.childContextTypes;
    if ("function" !== typeof d.getChildContext) return c;
    d = d.getChildContext();

    for (var e in d) if (!(e in a)) throw Error(n(108, ta(b) || "Unknown", e));

    return aa({}, c, {}, d);
  }

  function Kb(a) {
    var b = a.stateNode;
    b = b && b.__reactInternalMemoizedMergedChildContext || Db;
    Eb = A.current;
    z(A, b);
    z(B, B.current);
    return !0;
  }

  function Lb(a, b, c) {
    var d = a.stateNode;
    if (!d) throw Error(n(169));
    c ? (b = Jb(a, b, Eb), d.__reactInternalMemoizedMergedChildContext = b, y(B), y(A), z(A, b)) : y(B);
    z(B, c);
  }

  var Mb = m.unstable_runWithPriority,
      Nb = m.unstable_scheduleCallback,
      Ob = m.unstable_cancelCallback,
      Pb = m.unstable_shouldYield,
      Qb = m.unstable_requestPaint,
      Rb = m.unstable_now,
      Ub = m.unstable_getCurrentPriorityLevel,
      Vb = m.unstable_ImmediatePriority,
      Wb = m.unstable_UserBlockingPriority,
      Xb = m.unstable_NormalPriority,
      Yb = m.unstable_LowPriority,
      Zb = m.unstable_IdlePriority,
      $b = {},
      ac = void 0 !== Qb ? Qb : function () {},
      bc = null,
      cc = null,
      dc = !1,
      ec = Rb(),
      E = 1E4 > ec ? Rb : function () {
    return Rb() - ec;
  };

  function fc() {
    switch (Ub()) {
      case Vb:
        return 99;

      case Wb:
        return 98;

      case Xb:
        return 97;

      case Yb:
        return 96;

      case Zb:
        return 95;

      default:
        throw Error(n(332));
    }
  }

  function gc(a) {
    switch (a) {
      case 99:
        return Vb;

      case 98:
        return Wb;

      case 97:
        return Xb;

      case 96:
        return Yb;

      case 95:
        return Zb;

      default:
        throw Error(n(332));
    }
  }

  function hc(a, b) {
    a = gc(a);
    return Mb(a, b);
  }

  function ic(a, b, c) {
    a = gc(a);
    return Nb(a, b, c);
  }

  function jc(a) {
    null === bc ? (bc = [a], cc = Nb(Vb, kc)) : bc.push(a);
    return $b;
  }

  function F() {
    if (null !== cc) {
      var a = cc;
      cc = null;
      Ob(a);
    }

    kc();
  }

  function kc() {
    if (!dc && null !== bc) {
      dc = !0;
      var a = 0;

      try {
        var b = bc;
        hc(99, function () {
          for (; a < b.length; a++) {
            var c = b[a];

            do c = c(!0); while (null !== c);
          }
        });
        bc = null;
      } catch (c) {
        throw null !== bc && (bc = bc.slice(a + 1)), Nb(Vb, F), c;
      } finally {
        dc = !1;
      }
    }
  }

  var lc = 3;

  function mc(a, b, c) {
    c /= 10;
    return 1073741821 - (((1073741821 - a + b / 10) / c | 0) + 1) * c;
  }

  function nc(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
  }

  var oc = "function" === typeof Object.is ? Object.is : nc,
      pc = Object.prototype.hasOwnProperty;

  function qc(a, b) {
    if (oc(a, b)) return !0;
    if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return !1;
    var c = Object.keys(a),
        d = Object.keys(b);
    if (c.length !== d.length) return !1;

    for (d = 0; d < c.length; d++) if (!pc.call(b, c[d]) || !oc(a[c[d]], b[c[d]])) return !1;

    return !0;
  }

  function rc(a, b) {
    if (a && a.defaultProps) {
      b = aa({}, b);
      a = a.defaultProps;

      for (var c in a) void 0 === b[c] && (b[c] = a[c]);
    }

    return b;
  }

  var sc = {
    current: null
  },
      tc = null,
      uc = null,
      vc = null;

  function wc() {
    vc = uc = tc = null;
  }

  function xc(a, b) {
    var c = a.type._context;
    Pa ? (z(sc, c._currentValue), c._currentValue = b) : (z(sc, c._currentValue2), c._currentValue2 = b);
  }

  function yc(a) {
    var b = sc.current;
    y(sc);
    a = a.type._context;
    Pa ? a._currentValue = b : a._currentValue2 = b;
  }

  function zc(a, b) {
    for (; null !== a;) {
      var c = a.alternate;
      if (a.childExpirationTime < b) a.childExpirationTime = b, null !== c && c.childExpirationTime < b && (c.childExpirationTime = b);else if (null !== c && c.childExpirationTime < b) c.childExpirationTime = b;else break;
      a = a.return;
    }
  }

  function Ac(a, b) {
    tc = a;
    vc = uc = null;
    a = a.dependencies;
    null !== a && null !== a.firstContext && (a.expirationTime >= b && (Bc = !0), a.firstContext = null);
  }

  function Cc(a, b) {
    if (vc !== a && !1 !== b && 0 !== b) {
      if ("number" !== typeof b || 1073741823 === b) vc = a, b = 1073741823;
      b = {
        context: a,
        observedBits: b,
        next: null
      };

      if (null === uc) {
        if (null === tc) throw Error(n(308));
        uc = b;
        tc.dependencies = {
          expirationTime: 0,
          firstContext: b,
          responders: null
        };
      } else uc = uc.next = b;
    }

    return Pa ? a._currentValue : a._currentValue2;
  }

  var Dc = !1;

  function Ec(a) {
    return {
      baseState: a,
      firstUpdate: null,
      lastUpdate: null,
      firstCapturedUpdate: null,
      lastCapturedUpdate: null,
      firstEffect: null,
      lastEffect: null,
      firstCapturedEffect: null,
      lastCapturedEffect: null
    };
  }

  function Fc(a) {
    return {
      baseState: a.baseState,
      firstUpdate: a.firstUpdate,
      lastUpdate: a.lastUpdate,
      firstCapturedUpdate: null,
      lastCapturedUpdate: null,
      firstEffect: null,
      lastEffect: null,
      firstCapturedEffect: null,
      lastCapturedEffect: null
    };
  }

  function Gc(a, b) {
    return {
      expirationTime: a,
      suspenseConfig: b,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
      nextEffect: null
    };
  }

  function Hc(a, b) {
    null === a.lastUpdate ? a.firstUpdate = a.lastUpdate = b : (a.lastUpdate.next = b, a.lastUpdate = b);
  }

  function Ic(a, b) {
    var c = a.alternate;

    if (null === c) {
      var d = a.updateQueue;
      var e = null;
      null === d && (d = a.updateQueue = Ec(a.memoizedState));
    } else d = a.updateQueue, e = c.updateQueue, null === d ? null === e ? (d = a.updateQueue = Ec(a.memoizedState), e = c.updateQueue = Ec(c.memoizedState)) : d = a.updateQueue = Fc(e) : null === e && (e = c.updateQueue = Fc(d));

    null === e || d === e ? Hc(d, b) : null === d.lastUpdate || null === e.lastUpdate ? (Hc(d, b), Hc(e, b)) : (Hc(d, b), e.lastUpdate = b);
  }

  function Jc(a, b) {
    var c = a.updateQueue;
    c = null === c ? a.updateQueue = Ec(a.memoizedState) : Kc(a, c);
    null === c.lastCapturedUpdate ? c.firstCapturedUpdate = c.lastCapturedUpdate = b : (c.lastCapturedUpdate.next = b, c.lastCapturedUpdate = b);
  }

  function Kc(a, b) {
    var c = a.alternate;
    null !== c && b === c.updateQueue && (b = a.updateQueue = Fc(b));
    return b;
  }

  function Lc(a, b, c, d, e, f) {
    switch (c.tag) {
      case 1:
        return a = c.payload, "function" === typeof a ? a.call(f, d, e) : a;

      case 3:
        a.effectTag = a.effectTag & -4097 | 64;

      case 0:
        a = c.payload;
        e = "function" === typeof a ? a.call(f, d, e) : a;
        if (null === e || void 0 === e) break;
        return aa({}, d, e);

      case 2:
        Dc = !0;
    }

    return d;
  }

  function Nc(a, b, c, d, e) {
    Dc = !1;
    b = Kc(a, b);

    for (var f = b.baseState, g = null, l = 0, h = b.firstUpdate, k = f; null !== h;) {
      var p = h.expirationTime;
      p < e ? (null === g && (g = h, f = k), l < p && (l = p)) : (Oc(p, h.suspenseConfig), k = Lc(a, b, h, k, c, d), null !== h.callback && (a.effectTag |= 32, h.nextEffect = null, null === b.lastEffect ? b.firstEffect = b.lastEffect = h : (b.lastEffect.nextEffect = h, b.lastEffect = h)));
      h = h.next;
    }

    p = null;

    for (h = b.firstCapturedUpdate; null !== h;) {
      var D = h.expirationTime;
      D < e ? (null === p && (p = h, null === g && (f = k)), l < D && (l = D)) : (k = Lc(a, b, h, k, c, d), null !== h.callback && (a.effectTag |= 32, h.nextEffect = null, null === b.lastCapturedEffect ? b.firstCapturedEffect = b.lastCapturedEffect = h : (b.lastCapturedEffect.nextEffect = h, b.lastCapturedEffect = h)));
      h = h.next;
    }

    null === g && (b.lastUpdate = null);
    null === p ? b.lastCapturedUpdate = null : a.effectTag |= 32;
    null === g && null === p && (f = k);
    b.baseState = f;
    b.firstUpdate = g;
    b.firstCapturedUpdate = p;
    Pc(l);
    a.expirationTime = l;
    a.memoizedState = k;
  }

  function Qc(a, b, c) {
    null !== b.firstCapturedUpdate && (null !== b.lastUpdate && (b.lastUpdate.next = b.firstCapturedUpdate, b.lastUpdate = b.lastCapturedUpdate), b.firstCapturedUpdate = b.lastCapturedUpdate = null);
    Rc(b.firstEffect, c);
    b.firstEffect = b.lastEffect = null;
    Rc(b.firstCapturedEffect, c);
    b.firstCapturedEffect = b.lastCapturedEffect = null;
  }

  function Rc(a, b) {
    for (; null !== a;) {
      var c = a.callback;

      if (null !== c) {
        a.callback = null;
        var d = b;
        if ("function" !== typeof c) throw Error(n(191, c));
        c.call(d);
      }

      a = a.nextEffect;
    }
  }

  var Sc = q.ReactCurrentBatchConfig,
      Tc = new ba.Component().refs;

  function Uc(a, b, c, d) {
    b = a.memoizedState;
    c = c(d, b);
    c = null === c || void 0 === c ? b : aa({}, b, c);
    a.memoizedState = c;
    d = a.updateQueue;
    null !== d && 0 === a.expirationTime && (d.baseState = c);
  }

  var Xc = {
    isMounted: function (a) {
      return (a = a._reactInternalFiber) ? ua(a) === a : !1;
    },
    enqueueSetState: function (a, b, c) {
      a = a._reactInternalFiber;
      var d = G(),
          e = Sc.suspense;
      d = Vc(d, a, e);
      e = Gc(d, e);
      e.payload = b;
      void 0 !== c && null !== c && (e.callback = c);
      Ic(a, e);
      Wc(a, d);
    },
    enqueueReplaceState: function (a, b, c) {
      a = a._reactInternalFiber;
      var d = G(),
          e = Sc.suspense;
      d = Vc(d, a, e);
      e = Gc(d, e);
      e.tag = 1;
      e.payload = b;
      void 0 !== c && null !== c && (e.callback = c);
      Ic(a, e);
      Wc(a, d);
    },
    enqueueForceUpdate: function (a, b) {
      a = a._reactInternalFiber;
      var c = G(),
          d = Sc.suspense;
      c = Vc(c, a, d);
      d = Gc(c, d);
      d.tag = 2;
      void 0 !== b && null !== b && (d.callback = b);
      Ic(a, d);
      Wc(a, c);
    }
  };

  function Yc(a, b, c, d, e, f, g) {
    a = a.stateNode;
    return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !qc(c, d) || !qc(e, f) : !0;
  }

  function Zc(a, b, c) {
    var d = !1,
        e = Db;
    var f = b.contextType;
    "object" === typeof f && null !== f ? f = Cc(f) : (e = C(b) ? Eb : A.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Fb(a, e) : Db);
    b = new b(c, f);
    a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
    b.updater = Xc;
    a.stateNode = b;
    b._reactInternalFiber = a;
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
    return b;
  }

  function $c(a, b, c, d) {
    a = b.state;
    "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
    "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
    b.state !== a && Xc.enqueueReplaceState(b, b.state, null);
  }

  function ad(a, b, c, d) {
    var e = a.stateNode;
    e.props = c;
    e.state = a.memoizedState;
    e.refs = Tc;
    var f = b.contextType;
    "object" === typeof f && null !== f ? e.context = Cc(f) : (f = C(b) ? Eb : A.current, e.context = Fb(a, f));
    f = a.updateQueue;
    null !== f && (Nc(a, f, c, e, d), e.state = a.memoizedState);
    f = b.getDerivedStateFromProps;
    "function" === typeof f && (Uc(a, b, f, c), e.state = a.memoizedState);
    "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Xc.enqueueReplaceState(e, e.state, null), f = a.updateQueue, null !== f && (Nc(a, f, c, e, d), e.state = a.memoizedState));
    "function" === typeof e.componentDidMount && (a.effectTag |= 4);
  }

  var bd = Array.isArray;

  function cd(a, b, c) {
    a = c.ref;

    if (null !== a && "function" !== typeof a && "object" !== typeof a) {
      if (c._owner) {
        c = c._owner;

        if (c) {
          if (1 !== c.tag) throw Error(n(309));
          var d = c.stateNode;
        }

        if (!d) throw Error(n(147, a));
        var e = "" + a;
        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e) return b.ref;

        b = function (b) {
          var a = d.refs;
          a === Tc && (a = d.refs = {});
          null === b ? delete a[e] : a[e] = b;
        };

        b._stringRef = e;
        return b;
      }

      if ("string" !== typeof a) throw Error(n(284));
      if (!c._owner) throw Error(n(290, a));
    }

    return a;
  }

  function dd(a, b) {
    if ("textarea" !== a.type) throw Error(n(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, ""));
  }

  function ed(a) {
    function b(b, c) {
      if (a) {
        var d = b.lastEffect;
        null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;
        c.nextEffect = null;
        c.effectTag = 8;
      }
    }

    function c(c, d) {
      if (!a) return null;

      for (; null !== d;) b(c, d), d = d.sibling;

      return null;
    }

    function d(b, a) {
      for (b = new Map(); null !== a;) null !== a.key ? b.set(a.key, a) : b.set(a.index, a), a = a.sibling;

      return b;
    }

    function e(b, a, c) {
      b = fd(b, a);
      b.index = 0;
      b.sibling = null;
      return b;
    }

    function f(b, c, d) {
      b.index = d;
      if (!a) return c;
      d = b.alternate;
      if (null !== d) return d = d.index, d < c ? (b.effectTag = 2, c) : d;
      b.effectTag = 2;
      return c;
    }

    function g(b) {
      a && null === b.alternate && (b.effectTag = 2);
      return b;
    }

    function l(b, a, c, d) {
      if (null === a || 6 !== a.tag) return a = gd(c, b.mode, d), a.return = b, a;
      a = e(a, c);
      a.return = b;
      return a;
    }

    function h(b, a, c, d) {
      if (null !== a && a.elementType === c.type) return d = e(a, c.props), d.ref = cd(b, a, c), d.return = b, d;
      d = hd(c.type, c.key, c.props, null, b.mode, d);
      d.ref = cd(b, a, c);
      d.return = b;
      return d;
    }

    function k(b, a, c, d) {
      if (null === a || 4 !== a.tag || a.stateNode.containerInfo !== c.containerInfo || a.stateNode.implementation !== c.implementation) return a = id(c, b.mode, d), a.return = b, a;
      a = e(a, c.children || []);
      a.return = b;
      return a;
    }

    function p(b, a, c, d, f) {
      if (null === a || 7 !== a.tag) return a = jd(c, b.mode, d, f), a.return = b, a;
      a = e(a, c);
      a.return = b;
      return a;
    }

    function D(b, a, c) {
      if ("string" === typeof a || "number" === typeof a) return a = gd("" + a, b.mode, c), a.return = b, a;

      if ("object" === typeof a && null !== a) {
        switch (a.$$typeof) {
          case ca:
            return c = hd(a.type, a.key, a.props, null, b.mode, c), c.ref = cd(b, null, a), c.return = b, c;

          case da:
            return a = id(a, b.mode, c), a.return = b, a;
        }

        if (bd(a) || ra(a)) return a = jd(a, b.mode, c, null), a.return = b, a;
        dd(b, a);
      }

      return null;
    }

    function x(b, a, c, d) {
      var e = null !== a ? a.key : null;
      if ("string" === typeof c || "number" === typeof c) return null !== e ? null : l(b, a, "" + c, d);

      if ("object" === typeof c && null !== c) {
        switch (c.$$typeof) {
          case ca:
            return c.key === e ? c.type === ea ? p(b, a, c.props.children, d, e) : h(b, a, c, d) : null;

          case da:
            return c.key === e ? k(b, a, c, d) : null;
        }

        if (bd(c) || ra(c)) return null !== e ? null : p(b, a, c, d, null);
        dd(b, c);
      }

      return null;
    }

    function K(b, a, c, d, e) {
      if ("string" === typeof d || "number" === typeof d) return b = b.get(c) || null, l(a, b, "" + d, e);

      if ("object" === typeof d && null !== d) {
        switch (d.$$typeof) {
          case ca:
            return b = b.get(null === d.key ? c : d.key) || null, d.type === ea ? p(a, b, d.props.children, e, d.key) : h(a, b, d, e);

          case da:
            return b = b.get(null === d.key ? c : d.key) || null, k(a, b, d, e);
        }

        if (bd(d) || ra(d)) return b = b.get(c) || null, p(a, b, d, e, null);
        dd(a, d);
      }

      return null;
    }

    function Ha(e, g, h, l) {
      for (var k = null, w = null, t = g, r = g = 0, p = null; null !== t && r < h.length; r++) {
        t.index > r ? (p = t, t = null) : p = t.sibling;
        var v = x(e, t, h[r], l);

        if (null === v) {
          null === t && (t = p);
          break;
        }

        a && t && null === v.alternate && b(e, t);
        g = f(v, g, r);
        null === w ? k = v : w.sibling = v;
        w = v;
        t = p;
      }

      if (r === h.length) return c(e, t), k;

      if (null === t) {
        for (; r < h.length; r++) t = D(e, h[r], l), null !== t && (g = f(t, g, r), null === w ? k = t : w.sibling = t, w = t);

        return k;
      }

      for (t = d(e, t); r < h.length; r++) p = K(t, e, r, h[r], l), null !== p && (a && null !== p.alternate && t.delete(null === p.key ? r : p.key), g = f(p, g, r), null === w ? k = p : w.sibling = p, w = p);

      a && t.forEach(function (a) {
        return b(e, a);
      });
      return k;
    }

    function O(e, g, h, l) {
      var k = ra(h);
      if ("function" !== typeof k) throw Error(n(150));
      h = k.call(h);
      if (null == h) throw Error(n(151));

      for (var t = k = null, r = g, w = g = 0, p = null, v = h.next(); null !== r && !v.done; w++, v = h.next()) {
        r.index > w ? (p = r, r = null) : p = r.sibling;
        var N = x(e, r, v.value, l);

        if (null === N) {
          null === r && (r = p);
          break;
        }

        a && r && null === N.alternate && b(e, r);
        g = f(N, g, w);
        null === t ? k = N : t.sibling = N;
        t = N;
        r = p;
      }

      if (v.done) return c(e, r), k;

      if (null === r) {
        for (; !v.done; w++, v = h.next()) v = D(e, v.value, l), null !== v && (g = f(v, g, w), null === t ? k = v : t.sibling = v, t = v);

        return k;
      }

      for (r = d(e, r); !v.done; w++, v = h.next()) v = K(r, e, w, v.value, l), null !== v && (a && null !== v.alternate && r.delete(null === v.key ? w : v.key), g = f(v, g, w), null === t ? k = v : t.sibling = v, t = v);

      a && r.forEach(function (a) {
        return b(e, a);
      });
      return k;
    }

    return function (a, d, f, h) {
      var k = "object" === typeof f && null !== f && f.type === ea && null === f.key;
      k && (f = f.props.children);
      var l = "object" === typeof f && null !== f;
      if (l) switch (f.$$typeof) {
        case ca:
          a: {
            l = f.key;

            for (k = d; null !== k;) {
              if (k.key === l) {
                if (7 === k.tag ? f.type === ea : k.elementType === f.type) {
                  c(a, k.sibling);
                  d = e(k, f.type === ea ? f.props.children : f.props);
                  d.ref = cd(a, k, f);
                  d.return = a;
                  a = d;
                  break a;
                } else {
                  c(a, k);
                  break;
                }
              } else b(a, k);
              k = k.sibling;
            }

            f.type === ea ? (d = jd(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = hd(f.type, f.key, f.props, null, a.mode, h), h.ref = cd(a, d, f), h.return = a, a = h);
          }

          return g(a);

        case da:
          a: {
            for (k = f.key; null !== d;) {
              if (d.key === k) {
                if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                  c(a, d.sibling);
                  d = e(d, f.children || []);
                  d.return = a;
                  a = d;
                  break a;
                } else {
                  c(a, d);
                  break;
                }
              } else b(a, d);
              d = d.sibling;
            }

            d = id(f, a.mode, h);
            d.return = a;
            a = d;
          }

          return g(a);
      }
      if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = gd(f, a.mode, h), d.return = a, a = d), g(a);
      if (bd(f)) return Ha(a, d, f, h);
      if (ra(f)) return O(a, d, f, h);
      l && dd(a, f);
      if ("undefined" === typeof f && !k) switch (a.tag) {
        case 1:
        case 0:
          throw a = a.type, Error(n(152, a.displayName || a.name || "Component"));
      }
      return c(a, d);
    };
  }

  var kd = ed(!0),
      ld = ed(!1),
      md = {},
      H = {
    current: md
  },
      nd = {
    current: md
  },
      od = {
    current: md
  };

  function pd(a) {
    if (a === md) throw Error(n(174));
    return a;
  }

  function qd(a, b) {
    z(od, b);
    z(nd, a);
    z(H, md);
    b = Aa(b);
    y(H);
    z(H, b);
  }

  function rd(a) {
    y(H);
    y(nd);
    y(od);
  }

  function sd(a) {
    var b = pd(od.current),
        c = pd(H.current);
    b = Ba(c, a.type, b);
    c !== b && (z(nd, a), z(H, b));
  }

  function td(a) {
    nd.current === a && (y(H), y(nd));
  }

  var I = {
    current: 0
  };

  function ud(a) {
    for (var b = a; null !== b;) {
      if (13 === b.tag) {
        var c = b.memoizedState;
        if (null !== c && (c = c.dehydrated, null === c || qb(c) || rb(c))) return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (0 !== (b.effectTag & 64)) return b;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }

      if (b === a) break;

      for (; null === b.sibling;) {
        if (null === b.return || b.return === a) return null;
        b = b.return;
      }

      b.sibling.return = b.return;
      b = b.sibling;
    }

    return null;
  }

  function vd(a, b) {
    return {
      responder: a,
      props: b
    };
  }

  var wd = q.ReactCurrentDispatcher,
      J = q.ReactCurrentBatchConfig,
      xd = 0,
      yd = null,
      L = null,
      zd = null,
      Ad = null,
      M = null,
      Bd = null,
      Cd = 0,
      Dd = null,
      Ed = 0,
      Fd = !1,
      Gd = null,
      Hd = 0;

  function P() {
    throw Error(n(321));
  }

  function Id(a, b) {
    if (null === b) return !1;

    for (var c = 0; c < b.length && c < a.length; c++) if (!oc(a[c], b[c])) return !1;

    return !0;
  }

  function Jd(a, b, c, d, e, f) {
    xd = f;
    yd = b;
    zd = null !== a ? a.memoizedState : null;
    wd.current = null === zd ? Kd : Ld;
    b = c(d, e);

    if (Fd) {
      do Fd = !1, Hd += 1, zd = null !== a ? a.memoizedState : null, Bd = Ad, Dd = M = L = null, wd.current = Ld, b = c(d, e); while (Fd);

      Gd = null;
      Hd = 0;
    }

    wd.current = Md;
    a = yd;
    a.memoizedState = Ad;
    a.expirationTime = Cd;
    a.updateQueue = Dd;
    a.effectTag |= Ed;
    a = null !== L && null !== L.next;
    xd = 0;
    Bd = M = Ad = zd = L = yd = null;
    Cd = 0;
    Dd = null;
    Ed = 0;
    if (a) throw Error(n(300));
    return b;
  }

  function Nd() {
    wd.current = Md;
    xd = 0;
    Bd = M = Ad = zd = L = yd = null;
    Cd = 0;
    Dd = null;
    Ed = 0;
    Fd = !1;
    Gd = null;
    Hd = 0;
  }

  function Od() {
    var a = {
      memoizedState: null,
      baseState: null,
      queue: null,
      baseUpdate: null,
      next: null
    };
    null === M ? Ad = M = a : M = M.next = a;
    return M;
  }

  function Pd() {
    if (null !== Bd) M = Bd, Bd = M.next, L = zd, zd = null !== L ? L.next : null;else {
      if (null === zd) throw Error(n(310));
      L = zd;
      var a = {
        memoizedState: L.memoizedState,
        baseState: L.baseState,
        queue: L.queue,
        baseUpdate: L.baseUpdate,
        next: null
      };
      M = null === M ? Ad = a : M.next = a;
      zd = L.next;
    }
    return M;
  }

  function Qd(a, b) {
    return "function" === typeof b ? b(a) : b;
  }

  function Rd(a) {
    var b = Pd(),
        c = b.queue;
    if (null === c) throw Error(n(311));
    c.lastRenderedReducer = a;

    if (0 < Hd) {
      var d = c.dispatch;

      if (null !== Gd) {
        var e = Gd.get(c);

        if (void 0 !== e) {
          Gd.delete(c);
          var f = b.memoizedState;

          do f = a(f, e.action), e = e.next; while (null !== e);

          oc(f, b.memoizedState) || (Bc = !0);
          b.memoizedState = f;
          b.baseUpdate === c.last && (b.baseState = f);
          c.lastRenderedState = f;
          return [f, d];
        }
      }

      return [b.memoizedState, d];
    }

    d = c.last;
    var g = b.baseUpdate;
    f = b.baseState;
    null !== g ? (null !== d && (d.next = null), d = g.next) : d = null !== d ? d.next : null;

    if (null !== d) {
      var l = e = null,
          h = d,
          k = !1;

      do {
        var p = h.expirationTime;
        p < xd ? (k || (k = !0, l = g, e = f), p > Cd && (Cd = p, Pc(Cd))) : (Oc(p, h.suspenseConfig), f = h.eagerReducer === a ? h.eagerState : a(f, h.action));
        g = h;
        h = h.next;
      } while (null !== h && h !== d);

      k || (l = g, e = f);
      oc(f, b.memoizedState) || (Bc = !0);
      b.memoizedState = f;
      b.baseUpdate = l;
      b.baseState = e;
      c.lastRenderedState = f;
    }

    return [b.memoizedState, c.dispatch];
  }

  function Sd(a) {
    var b = Od();
    "function" === typeof a && (a = a());
    b.memoizedState = b.baseState = a;
    a = b.queue = {
      last: null,
      dispatch: null,
      lastRenderedReducer: Qd,
      lastRenderedState: a
    };
    a = a.dispatch = Td.bind(null, yd, a);
    return [b.memoizedState, a];
  }

  function Ud(a) {
    return Rd(Qd);
  }

  function Vd(a, b, c, d) {
    a = {
      tag: a,
      create: b,
      destroy: c,
      deps: d,
      next: null
    };
    null === Dd ? (Dd = {
      lastEffect: null
    }, Dd.lastEffect = a.next = a) : (b = Dd.lastEffect, null === b ? Dd.lastEffect = a.next = a : (c = b.next, b.next = a, a.next = c, Dd.lastEffect = a));
    return a;
  }

  function Wd(a, b, c, d) {
    var e = Od();
    Ed |= a;
    e.memoizedState = Vd(b, c, void 0, void 0 === d ? null : d);
  }

  function Xd(a, b, c, d) {
    var e = Pd();
    d = void 0 === d ? null : d;
    var f = void 0;

    if (null !== L) {
      var g = L.memoizedState;
      f = g.destroy;

      if (null !== d && Id(d, g.deps)) {
        Vd(0, c, f, d);
        return;
      }
    }

    Ed |= a;
    e.memoizedState = Vd(b, c, f, d);
  }

  function Yd(a, b) {
    return Wd(516, 192, a, b);
  }

  function Zd(a, b) {
    return Xd(516, 192, a, b);
  }

  function $d(a, b) {
    if ("function" === typeof b) return a = a(), b(a), function () {
      b(null);
    };
    if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {
      b.current = null;
    };
  }

  function ae() {}

  function be(a, b) {
    Od().memoizedState = [a, void 0 === b ? null : b];
    return a;
  }

  function ce(a, b) {
    var c = Pd();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Id(b, d[1])) return d[0];
    c.memoizedState = [a, b];
    return a;
  }

  function Td(a, b, c) {
    if (!(25 > Hd)) throw Error(n(301));
    var d = a.alternate;
    if (a === yd || null !== d && d === yd) {
      if (Fd = !0, a = {
        expirationTime: xd,
        suspenseConfig: null,
        action: c,
        eagerReducer: null,
        eagerState: null,
        next: null
      }, null === Gd && (Gd = new Map()), c = Gd.get(b), void 0 === c) Gd.set(b, a);else {
        for (b = c; null !== b.next;) b = b.next;

        b.next = a;
      }
    } else {
      var e = G(),
          f = Sc.suspense;
      e = Vc(e, a, f);
      f = {
        expirationTime: e,
        suspenseConfig: f,
        action: c,
        eagerReducer: null,
        eagerState: null,
        next: null
      };
      var g = b.last;
      if (null === g) f.next = f;else {
        var l = g.next;
        null !== l && (f.next = l);
        g.next = f;
      }
      b.last = f;
      if (0 === a.expirationTime && (null === d || 0 === d.expirationTime) && (d = b.lastRenderedReducer, null !== d)) try {
        var h = b.lastRenderedState,
            k = d(h, c);
        f.eagerReducer = d;
        f.eagerState = k;
        if (oc(k, h)) return;
      } catch (p) {} finally {}
      Wc(a, e);
    }
  }

  var Md = {
    readContext: Cc,
    useCallback: P,
    useContext: P,
    useEffect: P,
    useImperativeHandle: P,
    useLayoutEffect: P,
    useMemo: P,
    useReducer: P,
    useRef: P,
    useState: P,
    useDebugValue: P,
    useResponder: P,
    useDeferredValue: P,
    useTransition: P
  },
      Kd = {
    readContext: Cc,
    useCallback: be,
    useContext: Cc,
    useEffect: Yd,
    useImperativeHandle: function (a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return Wd(4, 36, $d.bind(null, b, a), c);
    },
    useLayoutEffect: function (a, b) {
      return Wd(4, 36, a, b);
    },
    useMemo: function (a, b) {
      var c = Od();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [a, b];
      return a;
    },
    useReducer: function (a, b, c) {
      var d = Od();
      b = void 0 !== c ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a = d.queue = {
        last: null,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: b
      };
      a = a.dispatch = Td.bind(null, yd, a);
      return [d.memoizedState, a];
    },
    useRef: function (a) {
      var b = Od();
      a = {
        current: a
      };
      return b.memoizedState = a;
    },
    useState: Sd,
    useDebugValue: ae,
    useResponder: vd,
    useDeferredValue: function (a, b) {
      var c = Sd(a),
          d = c[0],
          e = c[1];
      Yd(function () {
        m.unstable_next(function () {
          var c = J.suspense;
          J.suspense = void 0 === b ? null : b;

          try {
            e(a);
          } finally {
            J.suspense = c;
          }
        });
      }, [a, b]);
      return d;
    },
    useTransition: function (a) {
      var b = Sd(!1),
          c = b[0],
          d = b[1];
      return [be(function (b) {
        d(!0);
        m.unstable_next(function () {
          var c = J.suspense;
          J.suspense = void 0 === a ? null : a;

          try {
            d(!1), b();
          } finally {
            J.suspense = c;
          }
        });
      }, [a, c]), c];
    }
  },
      Ld = {
    readContext: Cc,
    useCallback: ce,
    useContext: Cc,
    useEffect: Zd,
    useImperativeHandle: function (a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return Xd(4, 36, $d.bind(null, b, a), c);
    },
    useLayoutEffect: function (a, b) {
      return Xd(4, 36, a, b);
    },
    useMemo: function (a, b) {
      var c = Pd();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Id(b, d[1])) return d[0];
      a = a();
      c.memoizedState = [a, b];
      return a;
    },
    useReducer: Rd,
    useRef: function () {
      return Pd().memoizedState;
    },
    useState: Ud,
    useDebugValue: ae,
    useResponder: vd,
    useDeferredValue: function (a, b) {
      var c = Ud(),
          d = c[0],
          e = c[1];
      Zd(function () {
        m.unstable_next(function () {
          var c = J.suspense;
          J.suspense = void 0 === b ? null : b;

          try {
            e(a);
          } finally {
            J.suspense = c;
          }
        });
      }, [a, b]);
      return d;
    },
    useTransition: function (a) {
      var b = Ud(),
          c = b[0],
          d = b[1];
      return [ce(function (b) {
        d(!0);
        m.unstable_next(function () {
          var c = J.suspense;
          J.suspense = void 0 === a ? null : a;

          try {
            d(!1), b();
          } finally {
            J.suspense = c;
          }
        });
      }, [a, c]), c];
    }
  },
      de = null,
      ee = null,
      fe = !1;

  function ge(a, b) {
    var c = he(5, null, null, 0);
    c.elementType = "DELETED";
    c.type = "DELETED";
    c.stateNode = b;
    c.return = a;
    c.effectTag = 8;
    null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
  }

  function ie(a, b) {
    switch (a.tag) {
      case 5:
        return b = ob(b, a.type, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;

      case 6:
        return b = pb(b, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;

      case 13:
        return !1;

      default:
        return !1;
    }
  }

  function je(a) {
    if (fe) {
      var b = ee;

      if (b) {
        var c = b;

        if (!ie(a, b)) {
          b = sb(c);

          if (!b || !ie(a, b)) {
            a.effectTag = a.effectTag & -1025 | 2;
            fe = !1;
            de = a;
            return;
          }

          ge(de, c);
        }

        de = a;
        ee = tb(b);
      } else a.effectTag = a.effectTag & -1025 | 2, fe = !1, de = a;
    }
  }

  function ke(a) {
    for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) a = a.return;

    de = a;
  }

  function ne(a) {
    if (!Sa || a !== de) return !1;
    if (!fe) return ke(a), fe = !0, !1;
    var b = a.type;
    if (5 !== a.tag || "head" !== b && "body" !== b && !Ja(b, a.memoizedProps)) for (b = ee; b;) ge(a, b), b = sb(b);
    ke(a);

    if (13 === a.tag) {
      if (!Sa) throw Error(n(316));
      a = a.memoizedState;
      a = null !== a ? a.dehydrated : null;
      if (!a) throw Error(n(317));
      ee = wb(a);
    } else ee = de ? sb(a.stateNode) : null;

    return !0;
  }

  function oe() {
    Sa && (ee = de = null, fe = !1);
  }

  var pe = q.ReactCurrentOwner,
      Bc = !1;

  function Q(a, b, c, d) {
    b.child = null === a ? ld(b, null, c, d) : kd(b, a.child, c, d);
  }

  function qe(a, b, c, d, e) {
    c = c.render;
    var f = b.ref;
    Ac(b, e);
    d = Jd(a, b, c, d, f, e);
    if (null !== a && !Bc) return b.updateQueue = a.updateQueue, b.effectTag &= -517, a.expirationTime <= e && (a.expirationTime = 0), re(a, b, e);
    b.effectTag |= 1;
    Q(a, b, d, e);
    return b.child;
  }

  function se(a, b, c, d, e, f) {
    if (null === a) {
      var g = c.type;
      if ("function" === typeof g && !te(g) && void 0 === g.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = g, ue(a, b, g, d, e, f);
      a = hd(c.type, null, d, null, b.mode, f);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }

    g = a.child;
    if (e < f && (e = g.memoizedProps, c = c.compare, c = null !== c ? c : qc, c(e, d) && a.ref === b.ref)) return re(a, b, f);
    b.effectTag |= 1;
    a = fd(g, d);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }

  function ue(a, b, c, d, e, f) {
    return null !== a && qc(a.memoizedProps, d) && a.ref === b.ref && (Bc = !1, e < f) ? re(a, b, f) : ve(a, b, c, d, f);
  }

  function we(a, b) {
    var c = b.ref;
    if (null === a && null !== c || null !== a && a.ref !== c) b.effectTag |= 128;
  }

  function ve(a, b, c, d, e) {
    var f = C(c) ? Eb : A.current;
    f = Fb(b, f);
    Ac(b, e);
    c = Jd(a, b, c, d, f, e);
    if (null !== a && !Bc) return b.updateQueue = a.updateQueue, b.effectTag &= -517, a.expirationTime <= e && (a.expirationTime = 0), re(a, b, e);
    b.effectTag |= 1;
    Q(a, b, c, e);
    return b.child;
  }

  function xe(a, b, c, d, e) {
    if (C(c)) {
      var f = !0;
      Kb(b);
    } else f = !1;

    Ac(b, e);
    if (null === b.stateNode) null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2), Zc(b, c, d), ad(b, c, d, e), d = !0;else if (null === a) {
      var g = b.stateNode,
          l = b.memoizedProps;
      g.props = l;
      var h = g.context,
          k = c.contextType;
      "object" === typeof k && null !== k ? k = Cc(k) : (k = C(c) ? Eb : A.current, k = Fb(b, k));
      var p = c.getDerivedStateFromProps,
          D = "function" === typeof p || "function" === typeof g.getSnapshotBeforeUpdate;
      D || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (l !== d || h !== k) && $c(b, g, d, k);
      Dc = !1;
      var x = b.memoizedState;
      h = g.state = x;
      var K = b.updateQueue;
      null !== K && (Nc(b, K, d, g, e), h = b.memoizedState);
      l !== d || x !== h || B.current || Dc ? ("function" === typeof p && (Uc(b, c, p, d), h = b.memoizedState), (l = Dc || Yc(b, c, l, d, x, h, k)) ? (D || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.effectTag |= 4)) : ("function" === typeof g.componentDidMount && (b.effectTag |= 4), b.memoizedProps = d, b.memoizedState = h), g.props = d, g.state = h, g.context = k, d = l) : ("function" === typeof g.componentDidMount && (b.effectTag |= 4), d = !1);
    } else g = b.stateNode, l = b.memoizedProps, g.props = b.type === b.elementType ? l : rc(b.type, l), h = g.context, k = c.contextType, "object" === typeof k && null !== k ? k = Cc(k) : (k = C(c) ? Eb : A.current, k = Fb(b, k)), p = c.getDerivedStateFromProps, (D = "function" === typeof p || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (l !== d || h !== k) && $c(b, g, d, k), Dc = !1, h = b.memoizedState, x = g.state = h, K = b.updateQueue, null !== K && (Nc(b, K, d, g, e), x = b.memoizedState), l !== d || h !== x || B.current || Dc ? ("function" === typeof p && (Uc(b, c, p, d), x = b.memoizedState), (p = Dc || Yc(b, c, l, d, h, x, k)) ? (D || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, x, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, x, k)), "function" === typeof g.componentDidUpdate && (b.effectTag |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.effectTag |= 256)) : ("function" !== typeof g.componentDidUpdate || l === a.memoizedProps && h === a.memoizedState || (b.effectTag |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || l === a.memoizedProps && h === a.memoizedState || (b.effectTag |= 256), b.memoizedProps = d, b.memoizedState = x), g.props = d, g.state = x, g.context = k, d = p) : ("function" !== typeof g.componentDidUpdate || l === a.memoizedProps && h === a.memoizedState || (b.effectTag |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || l === a.memoizedProps && h === a.memoizedState || (b.effectTag |= 256), d = !1);
    return ye(a, b, c, d, f, e);
  }

  function ye(a, b, c, d, e, f) {
    we(a, b);
    var g = 0 !== (b.effectTag & 64);
    if (!d && !g) return e && Lb(b, c, !1), re(a, b, f);
    d = b.stateNode;
    pe.current = b;
    var l = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
    b.effectTag |= 1;
    null !== a && g ? (b.child = kd(b, a.child, null, f), b.child = kd(b, null, l, f)) : Q(a, b, l, f);
    b.memoizedState = d.state;
    e && Lb(b, c, !0);
    return b.child;
  }

  function ze(a) {
    var b = a.stateNode;
    b.pendingContext ? Ib(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Ib(a, b.context, !1);
    qd(a, b.containerInfo);
  }

  var Ae = {
    dehydrated: null,
    retryTime: 0
  };

  function Be(a, b, c) {
    var d = b.mode,
        e = b.pendingProps,
        f = I.current,
        g = !1,
        l;
    (l = 0 !== (b.effectTag & 64)) || (l = 0 !== (f & 2) && (null === a || null !== a.memoizedState));
    l ? (g = !0, b.effectTag &= -65) : null !== a && null === a.memoizedState || void 0 === e.fallback || !0 === e.unstable_avoidThisFallback || (f |= 1);
    z(I, f & 1);

    if (null === a) {
      void 0 !== e.fallback && je(b);

      if (g) {
        g = e.fallback;
        e = jd(null, d, 0, null);
        e.return = b;
        if (0 === (b.mode & 2)) for (a = null !== b.memoizedState ? b.child.child : b.child, e.child = a; null !== a;) a.return = e, a = a.sibling;
        c = jd(g, d, c, null);
        c.return = b;
        e.sibling = c;
        b.memoizedState = Ae;
        b.child = e;
        return c;
      }

      d = e.children;
      b.memoizedState = null;
      return b.child = ld(b, null, d, c);
    }

    if (null !== a.memoizedState) {
      a = a.child;
      d = a.sibling;

      if (g) {
        e = e.fallback;
        c = fd(a, a.pendingProps);
        c.return = b;
        if (0 === (b.mode & 2) && (g = null !== b.memoizedState ? b.child.child : b.child, g !== a.child)) for (c.child = g; null !== g;) g.return = c, g = g.sibling;
        d = fd(d, e, d.expirationTime);
        d.return = b;
        c.sibling = d;
        c.childExpirationTime = 0;
        b.memoizedState = Ae;
        b.child = c;
        return d;
      }

      c = kd(b, a.child, e.children, c);
      b.memoizedState = null;
      return b.child = c;
    }

    a = a.child;

    if (g) {
      g = e.fallback;
      e = jd(null, d, 0, null);
      e.return = b;
      e.child = a;
      null !== a && (a.return = e);
      if (0 === (b.mode & 2)) for (a = null !== b.memoizedState ? b.child.child : b.child, e.child = a; null !== a;) a.return = e, a = a.sibling;
      c = jd(g, d, c, null);
      c.return = b;
      e.sibling = c;
      c.effectTag |= 2;
      e.childExpirationTime = 0;
      b.memoizedState = Ae;
      b.child = e;
      return c;
    }

    b.memoizedState = null;
    return b.child = kd(b, a, e.children, c);
  }

  function Ce(a, b) {
    a.expirationTime < b && (a.expirationTime = b);
    var c = a.alternate;
    null !== c && c.expirationTime < b && (c.expirationTime = b);
    zc(a.return, b);
  }

  function De(a, b, c, d, e, f) {
    var g = a.memoizedState;
    null === g ? a.memoizedState = {
      isBackwards: b,
      rendering: null,
      last: d,
      tail: c,
      tailExpiration: 0,
      tailMode: e,
      lastEffect: f
    } : (g.isBackwards = b, g.rendering = null, g.last = d, g.tail = c, g.tailExpiration = 0, g.tailMode = e, g.lastEffect = f);
  }

  function Ee(a, b, c) {
    var d = b.pendingProps,
        e = d.revealOrder,
        f = d.tail;
    Q(a, b, d.children, c);
    d = I.current;
    if (0 !== (d & 2)) d = d & 1 | 2, b.effectTag |= 64;else {
      if (null !== a && 0 !== (a.effectTag & 64)) a: for (a = b.child; null !== a;) {
        if (13 === a.tag) null !== a.memoizedState && Ce(a, c);else if (19 === a.tag) Ce(a, c);else if (null !== a.child) {
          a.child.return = a;
          a = a.child;
          continue;
        }
        if (a === b) break a;

        for (; null === a.sibling;) {
          if (null === a.return || a.return === b) break a;
          a = a.return;
        }

        a.sibling.return = a.return;
        a = a.sibling;
      }
      d &= 1;
    }
    z(I, d);
    if (0 === (b.mode & 2)) b.memoizedState = null;else switch (e) {
      case "forwards":
        c = b.child;

        for (e = null; null !== c;) a = c.alternate, null !== a && null === ud(a) && (e = c), c = c.sibling;

        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        De(b, !1, e, c, f, b.lastEffect);
        break;

      case "backwards":
        c = null;
        e = b.child;

        for (b.child = null; null !== e;) {
          a = e.alternate;

          if (null !== a && null === ud(a)) {
            b.child = e;
            break;
          }

          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }

        De(b, !0, c, null, f, b.lastEffect);
        break;

      case "together":
        De(b, !1, null, null, void 0, b.lastEffect);
        break;

      default:
        b.memoizedState = null;
    }
    return b.child;
  }

  function re(a, b, c) {
    null !== a && (b.dependencies = a.dependencies);
    var d = b.expirationTime;
    0 !== d && Pc(d);
    if (b.childExpirationTime < c) return null;
    if (null !== a && b.child !== a.child) throw Error(n(153));

    if (null !== b.child) {
      a = b.child;
      c = fd(a, a.pendingProps, a.expirationTime);
      b.child = c;

      for (c.return = b; null !== a.sibling;) a = a.sibling, c = c.sibling = fd(a, a.pendingProps, a.expirationTime), c.return = b;

      c.sibling = null;
    }

    return b.child;
  }

  function Fe(a) {
    a.effectTag |= 4;
  }

  var Ge, He, Ie, Je;
  if (Qa) Ge = function (a, b) {
    for (var c = b.child; null !== c;) {
      if (5 === c.tag || 6 === c.tag) Fa(a, c.stateNode);else if (4 !== c.tag && null !== c.child) {
        c.child.return = c;
        c = c.child;
        continue;
      }
      if (c === b) break;

      for (; null === c.sibling;) {
        if (null === c.return || c.return === b) return;
        c = c.return;
      }

      c.sibling.return = c.return;
      c = c.sibling;
    }
  }, He = function () {}, Ie = function (a, b, c, d, e) {
    a = a.memoizedProps;

    if (a !== d) {
      var f = b.stateNode,
          g = pd(H.current);
      c = Ia(f, c, a, d, e, g);
      (b.updateQueue = c) && Fe(b);
    }
  }, Je = function (a, b, c, d) {
    c !== d && Fe(b);
  };else if (Ra) {
    Ge = function (a, b, c, d) {
      for (var e = b.child; null !== e;) {
        if (5 === e.tag) {
          var f = e.stateNode;
          c && d && (f = mb(f, e.type, e.memoizedProps, e));
          Fa(a, f);
        } else if (6 === e.tag) f = e.stateNode, c && d && (f = nb(f, e.memoizedProps, e)), Fa(a, f);else if (4 !== e.tag) {
          if (13 === e.tag && 0 !== (e.effectTag & 4) && (f = null !== e.memoizedState)) {
            var g = e.child;

            if (null !== g && (null !== g.child && (g.child.return = g, Ge(a, g, !0, f)), f = g.sibling, null !== f)) {
              f.return = e;
              e = f;
              continue;
            }
          }

          if (null !== e.child) {
            e.child.return = e;
            e = e.child;
            continue;
          }
        }

        if (e === b) break;

        for (; null === e.sibling;) {
          if (null === e.return || e.return === b) return;
          e = e.return;
        }

        e.sibling.return = e.return;
        e = e.sibling;
      }
    };

    var Ke = function (a, b, c, d) {
      for (var e = b.child; null !== e;) {
        if (5 === e.tag) {
          var f = e.stateNode;
          c && d && (f = mb(f, e.type, e.memoizedProps, e));
          ib(a, f);
        } else if (6 === e.tag) f = e.stateNode, c && d && (f = nb(f, e.memoizedProps, e)), ib(a, f);else if (4 !== e.tag) {
          if (13 === e.tag && 0 !== (e.effectTag & 4) && (f = null !== e.memoizedState)) {
            var g = e.child;

            if (null !== g && (null !== g.child && (g.child.return = g, Ke(a, g, !0, f)), f = g.sibling, null !== f)) {
              f.return = e;
              e = f;
              continue;
            }
          }

          if (null !== e.child) {
            e.child.return = e;
            e = e.child;
            continue;
          }
        }

        if (e === b) break;

        for (; null === e.sibling;) {
          if (null === e.return || e.return === b) return;
          e = e.return;
        }

        e.sibling.return = e.return;
        e = e.sibling;
      }
    };

    He = function (a) {
      var b = a.stateNode;

      if (null !== a.firstEffect) {
        var c = b.containerInfo,
            d = hb(c);
        Ke(d, a, !1, !1);
        b.pendingChildren = d;
        Fe(a);
        kb(c, d);
      }
    };

    Ie = function (a, b, c, d, e) {
      var f = a.stateNode,
          g = a.memoizedProps;
      if ((a = null === b.firstEffect) && g === d) b.stateNode = f;else {
        var l = b.stateNode,
            h = pd(H.current),
            k = null;
        g !== d && (k = Ia(l, c, g, d, e, h));
        a && null === k ? b.stateNode = f : (f = gb(f, k, c, g, d, b, a, l), Ga(f, c, d, e, h) && Fe(b), b.stateNode = f, a ? Fe(b) : Ge(f, b, !1, !1));
      }
    };

    Je = function (a, b, c, d) {
      c !== d && (a = pd(od.current), c = pd(H.current), b.stateNode = La(d, a, c, b), Fe(b));
    };
  } else He = function () {}, Ie = function () {}, Je = function () {};

  function Le(a, b) {
    switch (a.tailMode) {
      case "hidden":
        b = a.tail;

        for (var c = null; null !== b;) null !== b.alternate && (c = b), b = b.sibling;

        null === c ? a.tail = null : c.sibling = null;
        break;

      case "collapsed":
        c = a.tail;

        for (var d = null; null !== c;) null !== c.alternate && (d = c), c = c.sibling;

        null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
  }

  function Me(a) {
    switch (a.tag) {
      case 1:
        C(a.type) && Gb();
        var b = a.effectTag;
        return b & 4096 ? (a.effectTag = b & -4097 | 64, a) : null;

      case 3:
        rd();
        Hb();
        b = a.effectTag;
        if (0 !== (b & 64)) throw Error(n(285));
        a.effectTag = b & -4097 | 64;
        return a;

      case 5:
        return td(a), null;

      case 13:
        return y(I), b = a.effectTag, b & 4096 ? (a.effectTag = b & -4097 | 64, a) : null;

      case 19:
        return y(I), null;

      case 4:
        return rd(), null;

      case 10:
        return yc(a), null;

      default:
        return null;
    }
  }

  function Ne(a, b) {
    return {
      value: a,
      source: b,
      stack: Ab(b)
    };
  }

  var Oe = "function" === typeof WeakSet ? WeakSet : Set;

  function Pe(a, b) {
    var c = b.source,
        d = b.stack;
    null === d && null !== c && (d = Ab(c));
    null !== c && ta(c.type);
    b = b.value;
    null !== a && 1 === a.tag && ta(a.type);

    try {
      console.error(b);
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }

  function Qe(a, b) {
    try {
      b.props = a.memoizedProps, b.state = a.memoizedState, b.componentWillUnmount();
    } catch (c) {
      Re(a, c);
    }
  }

  function Se(a) {
    var b = a.ref;
    if (null !== b) if ("function" === typeof b) try {
      b(null);
    } catch (c) {
      Re(a, c);
    } else b.current = null;
  }

  function Te(a, b) {
    switch (b.tag) {
      case 0:
      case 11:
      case 15:
        Ue(2, 0, b);
        break;

      case 1:
        if (b.effectTag & 256 && null !== a) {
          var c = a.memoizedProps,
              d = a.memoizedState;
          a = b.stateNode;
          b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : rc(b.type, c), d);
          a.__reactInternalSnapshotBeforeUpdate = b;
        }

        break;

      case 3:
      case 5:
      case 6:
      case 4:
      case 17:
        break;

      default:
        throw Error(n(163));
    }
  }

  function Ue(a, b, c) {
    c = c.updateQueue;
    c = null !== c ? c.lastEffect : null;

    if (null !== c) {
      var d = c = c.next;

      do {
        if (0 !== (d.tag & a)) {
          var e = d.destroy;
          d.destroy = void 0;
          void 0 !== e && e();
        }

        0 !== (d.tag & b) && (e = d.create, d.destroy = e());
        d = d.next;
      } while (d !== c);
    }
  }

  function Ve(a, b, c) {
    "function" === typeof We && We(b);

    switch (b.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        a = b.updateQueue;

        if (null !== a && (a = a.lastEffect, null !== a)) {
          var d = a.next;
          hc(97 < c ? 97 : c, function () {
            var a = d;

            do {
              var c = a.destroy;

              if (void 0 !== c) {
                var g = b;

                try {
                  c();
                } catch (l) {
                  Re(g, l);
                }
              }

              a = a.next;
            } while (a !== d);
          });
        }

        break;

      case 1:
        Se(b);
        c = b.stateNode;
        "function" === typeof c.componentWillUnmount && Qe(b, c);
        break;

      case 5:
        Se(b);
        break;

      case 4:
        Qa ? Xe(a, b, c) : Ra && Ye(b);
    }
  }

  function Ze(a, b, c) {
    for (var d = b;;) if (Ve(a, d, c), null === d.child || Qa && 4 === d.tag) {
      if (d === b) break;

      for (; null === d.sibling;) {
        if (null === d.return || d.return === b) return;
        d = d.return;
      }

      d.sibling.return = d.return;
      d = d.sibling;
    } else d.child.return = d, d = d.child;
  }

  function $e(a) {
    var b = a.alternate;
    a.return = null;
    a.child = null;
    a.memoizedState = null;
    a.updateQueue = null;
    a.dependencies = null;
    a.alternate = null;
    a.firstEffect = null;
    a.lastEffect = null;
    a.pendingProps = null;
    a.memoizedProps = null;
    null !== b && $e(b);
  }

  function Ye(a) {
    if (Ra) {
      a = a.stateNode.containerInfo;
      var b = hb(a);
      lb(a, b);
    }
  }

  function af(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }

  function bf(a) {
    if (Qa) {
      a: {
        for (var b = a.return; null !== b;) {
          if (af(b)) {
            var c = b;
            break a;
          }

          b = b.return;
        }

        throw Error(n(160));
      }

      b = c.stateNode;

      switch (c.tag) {
        case 5:
          var d = !1;
          break;

        case 3:
          b = b.containerInfo;
          d = !0;
          break;

        case 4:
          b = b.containerInfo;
          d = !0;
          break;

        default:
          throw Error(n(161));
      }

      c.effectTag & 16 && (bb(b), c.effectTag &= -17);

      a: b: for (c = a;;) {
        for (; null === c.sibling;) {
          if (null === c.return || af(c.return)) {
            c = null;
            break a;
          }

          c = c.return;
        }

        c.sibling.return = c.return;

        for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag;) {
          if (c.effectTag & 2) continue b;
          if (null === c.child || 4 === c.tag) continue b;else c.child.return = c, c = c.child;
        }

        if (!(c.effectTag & 2)) {
          c = c.stateNode;
          break a;
        }
      }

      for (var e = a;;) {
        var f = 5 === e.tag || 6 === e.tag;
        if (f) f = f ? e.stateNode : e.stateNode.instance, c ? d ? Za(b, f, c) : Ya(b, f, c) : d ? Ua(b, f) : Ta(b, f);else if (4 !== e.tag && null !== e.child) {
          e.child.return = e;
          e = e.child;
          continue;
        }
        if (e === a) break;

        for (; null === e.sibling;) {
          if (null === e.return || e.return === a) return;
          e = e.return;
        }

        e.sibling.return = e.return;
        e = e.sibling;
      }
    }
  }

  function Xe(a, b, c) {
    for (var d = b, e = !1, f, g;;) {
      if (!e) {
        e = d.return;

        a: for (;;) {
          if (null === e) throw Error(n(160));
          f = e.stateNode;

          switch (e.tag) {
            case 5:
              g = !1;
              break a;

            case 3:
              f = f.containerInfo;
              g = !0;
              break a;

            case 4:
              f = f.containerInfo;
              g = !0;
              break a;
          }

          e = e.return;
        }

        e = !0;
      }

      if (5 === d.tag || 6 === d.tag) Ze(a, d, c), g ? ab(f, d.stateNode) : $a(f, d.stateNode);else if (4 === d.tag) {
        if (null !== d.child) {
          f = d.stateNode.containerInfo;
          g = !0;
          d.child.return = d;
          d = d.child;
          continue;
        }
      } else if (Ve(a, d, c), null !== d.child) {
        d.child.return = d;
        d = d.child;
        continue;
      }
      if (d === b) break;

      for (; null === d.sibling;) {
        if (null === d.return || d.return === b) return;
        d = d.return;
        4 === d.tag && (e = !1);
      }

      d.sibling.return = d.return;
      d = d.sibling;
    }
  }

  function cf(a, b) {
    if (Qa) switch (b.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Ue(4, 8, b);
        break;

      case 1:
        break;

      case 5:
        var c = b.stateNode;

        if (null != c) {
          var d = b.memoizedProps;
          a = null !== a ? a.memoizedProps : d;
          var e = b.type,
              f = b.updateQueue;
          b.updateQueue = null;
          null !== f && Xa(c, f, e, a, d, b);
        }

        break;

      case 6:
        if (null === b.stateNode) throw Error(n(162));
        c = b.memoizedProps;
        Va(b.stateNode, null !== a ? a.memoizedProps : c, c);
        break;

      case 3:
        Sa && (b = b.stateNode, b.hydrate && (b.hydrate = !1, xb(b.containerInfo)));
        break;

      case 12:
        break;

      case 13:
        df(b);
        ef(b);
        break;

      case 19:
        ef(b);
        break;

      case 17:
        break;

      case 20:
        break;

      case 21:
        break;

      default:
        throw Error(n(163));
    } else {
      switch (b.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ue(4, 8, b);
          return;

        case 12:
          return;

        case 13:
          df(b);
          ef(b);
          return;

        case 19:
          ef(b);
          return;

        case 3:
          Sa && (c = b.stateNode, c.hydrate && (c.hydrate = !1, xb(c.containerInfo)));
      }

      a: if (Ra) switch (b.tag) {
        case 1:
        case 5:
        case 6:
        case 20:
          break a;

        case 3:
        case 4:
          b = b.stateNode;
          lb(b.containerInfo, b.pendingChildren);
          break a;

        default:
          throw Error(n(163));
      }
    }
  }

  function df(a) {
    var b = a;
    if (null === a.memoizedState) var c = !1;else c = !0, b = a.child, ff = E();
    if (Qa && null !== b) a: if (a = b, Qa) for (b = a;;) {
      if (5 === b.tag) {
        var d = b.stateNode;
        c ? cb(d) : eb(b.stateNode, b.memoizedProps);
      } else if (6 === b.tag) d = b.stateNode, c ? db(d) : fb(d, b.memoizedProps);else if (13 === b.tag && null !== b.memoizedState && null === b.memoizedState.dehydrated) {
        d = b.child.sibling;
        d.return = b;
        b = d;
        continue;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }

      if (b === a) break a;

      for (; null === b.sibling;) {
        if (null === b.return || b.return === a) break a;
        b = b.return;
      }

      b.sibling.return = b.return;
      b = b.sibling;
    }
  }

  function ef(a) {
    var b = a.updateQueue;

    if (null !== b) {
      a.updateQueue = null;
      var c = a.stateNode;
      null === c && (c = a.stateNode = new Oe());
      b.forEach(function (b) {
        var d = gf.bind(null, a, b);
        c.has(b) || (c.add(b), b.then(d, d));
      });
    }
  }

  var hf = "function" === typeof WeakMap ? WeakMap : Map;

  function jf(a, b, c) {
    c = Gc(c, null);
    c.tag = 3;
    c.payload = {
      element: null
    };
    var d = b.value;

    c.callback = function () {
      kf || (kf = !0, lf = d);
      Pe(a, b);
    };

    return c;
  }

  function mf(a, b, c) {
    c = Gc(c, null);
    c.tag = 3;
    var d = a.type.getDerivedStateFromError;

    if ("function" === typeof d) {
      var e = b.value;

      c.payload = function () {
        Pe(a, b);
        return d(e);
      };
    }

    var f = a.stateNode;
    null !== f && "function" === typeof f.componentDidCatch && (c.callback = function () {
      "function" !== typeof d && (null === nf ? nf = new Set([this]) : nf.add(this), Pe(a, b));
      var c = b.stack;
      this.componentDidCatch(b.value, {
        componentStack: null !== c ? c : ""
      });
    });
    return c;
  }

  var of = Math.ceil,
      pf = q.ReactCurrentDispatcher,
      qf = q.ReactCurrentOwner,
      R = 0,
      rf = 8,
      S = 16,
      sf = 32,
      tf = 0,
      uf = 1,
      vf = 2,
      wf = 3,
      xf = 4,
      yf = 5,
      T = R,
      U = null,
      V = null,
      W = 0,
      X = tf,
      zf = null,
      Af = 1073741823,
      Bf = 1073741823,
      Cf = null,
      Df = 0,
      Ef = !1,
      ff = 0,
      Ff = 500,
      Y = null,
      kf = !1,
      lf = null,
      nf = null,
      Gf = !1,
      Hf = null,
      If = 90,
      Jf = null,
      Kf = 0,
      Lf = null,
      Mf = 0;

  function G() {
    return (T & (S | sf)) !== R ? 1073741821 - (E() / 10 | 0) : 0 !== Mf ? Mf : Mf = 1073741821 - (E() / 10 | 0);
  }

  function Vc(a, b, c) {
    b = b.mode;
    if (0 === (b & 2)) return 1073741823;
    var d = fc();
    if (0 === (b & 4)) return 99 === d ? 1073741823 : 1073741822;
    if ((T & S) !== R) return W;
    if (null !== c) a = mc(a, c.timeoutMs | 0 || 5E3, 250);else switch (d) {
      case 99:
        a = 1073741823;
        break;

      case 98:
        a = mc(a, 150, 100);
        break;

      case 97:
      case 96:
        a = mc(a, 5E3, 250);
        break;

      case 95:
        a = 2;
        break;

      default:
        throw Error(n(326));
    }
    null !== U && a === W && --a;
    return a;
  }

  function Wc(a, b) {
    if (50 < Kf) throw Kf = 0, Lf = null, Error(n(185));
    a = Nf(a, b);

    if (null !== a) {
      var c = fc();
      1073741823 === b ? (T & rf) !== R && (T & (S | sf)) === R ? Of(a) : (Z(a), T === R && F()) : Z(a);
      (T & 4) === R || 98 !== c && 99 !== c || (null === Jf ? Jf = new Map([[a, b]]) : (c = Jf.get(a), (void 0 === c || c > b) && Jf.set(a, b)));
    }
  }

  function Nf(a, b) {
    a.expirationTime < b && (a.expirationTime = b);
    var c = a.alternate;
    null !== c && c.expirationTime < b && (c.expirationTime = b);
    var d = a.return,
        e = null;
    if (null === d && 3 === a.tag) e = a.stateNode;else for (; null !== d;) {
      c = d.alternate;
      d.childExpirationTime < b && (d.childExpirationTime = b);
      null !== c && c.childExpirationTime < b && (c.childExpirationTime = b);

      if (null === d.return && 3 === d.tag) {
        e = d.stateNode;
        break;
      }

      d = d.return;
    }
    null !== e && (U === e && (Pc(b), X === xf && Pf(e, W)), Qf(e, b));
    return e;
  }

  function Rf(a) {
    var b = a.lastExpiredTime;
    if (0 !== b) return b;
    b = a.firstPendingTime;
    if (!Sf(a, b)) return b;
    b = a.lastPingedTime;
    a = a.nextKnownPendingLevel;
    return b > a ? b : a;
  }

  function Z(a) {
    if (0 !== a.lastExpiredTime) a.callbackExpirationTime = 1073741823, a.callbackPriority = 99, a.callbackNode = jc(Of.bind(null, a));else {
      var b = Rf(a),
          c = a.callbackNode;
      if (0 === b) null !== c && (a.callbackNode = null, a.callbackExpirationTime = 0, a.callbackPriority = 90);else {
        var d = G();
        1073741823 === b ? d = 99 : 1 === b || 2 === b ? d = 95 : (d = 10 * (1073741821 - b) - 10 * (1073741821 - d), d = 0 >= d ? 99 : 250 >= d ? 98 : 5250 >= d ? 97 : 95);

        if (null !== c) {
          var e = a.callbackPriority;
          if (a.callbackExpirationTime === b && e >= d) return;
          c !== $b && Ob(c);
        }

        a.callbackExpirationTime = b;
        a.callbackPriority = d;
        b = 1073741823 === b ? jc(Of.bind(null, a)) : ic(d, Tf.bind(null, a), {
          timeout: 10 * (1073741821 - b) - E()
        });
        a.callbackNode = b;
      }
    }
  }

  function Tf(a, b) {
    Mf = 0;
    if (b) return b = G(), Uf(a, b), Z(a), null;
    var c = Rf(a);

    if (0 !== c) {
      b = a.callbackNode;
      if ((T & (S | sf)) !== R) throw Error(n(327));
      Vf();
      a === U && c === W || Wf(a, c);

      if (null !== V) {
        var d = T;
        T |= S;
        var e = Xf();

        do try {
          Yf();
          break;
        } catch (l) {
          Zf(a, l);
        } while (1);

        wc();
        T = d;
        pf.current = e;
        if (X === uf) throw b = zf, Wf(a, c), Pf(a, c), Z(a), b;
        if (null === V) switch (e = a.finishedWork = a.current.alternate, a.finishedExpirationTime = c, d = X, U = null, d) {
          case tf:
          case uf:
            throw Error(n(345));

          case vf:
            Uf(a, 2 < c ? 2 : c);
            break;

          case wf:
            Pf(a, c);
            d = a.lastSuspendedTime;
            c === d && (a.nextKnownPendingLevel = $f(e));

            if (1073741823 === Af && (e = ff + Ff - E(), 10 < e)) {
              if (Ef) {
                var f = a.lastPingedTime;

                if (0 === f || f >= c) {
                  a.lastPingedTime = c;
                  Wf(a, c);
                  break;
                }
              }

              f = Rf(a);
              if (0 !== f && f !== c) break;

              if (0 !== d && d !== c) {
                a.lastPingedTime = d;
                break;
              }

              a.timeoutHandle = Ma(ag.bind(null, a), e);
              break;
            }

            ag(a);
            break;

          case xf:
            Pf(a, c);
            d = a.lastSuspendedTime;
            c === d && (a.nextKnownPendingLevel = $f(e));

            if (Ef && (e = a.lastPingedTime, 0 === e || e >= c)) {
              a.lastPingedTime = c;
              Wf(a, c);
              break;
            }

            e = Rf(a);
            if (0 !== e && e !== c) break;

            if (0 !== d && d !== c) {
              a.lastPingedTime = d;
              break;
            }

            1073741823 !== Bf ? d = 10 * (1073741821 - Bf) - E() : 1073741823 === Af ? d = 0 : (d = 10 * (1073741821 - Af) - 5E3, e = E(), c = 10 * (1073741821 - c) - e, d = e - d, 0 > d && (d = 0), d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3E3 > d ? 3E3 : 4320 > d ? 4320 : 1960 * of(d / 1960)) - d, c < d && (d = c));

            if (10 < d) {
              a.timeoutHandle = Ma(ag.bind(null, a), d);
              break;
            }

            ag(a);
            break;

          case yf:
            if (1073741823 !== Af && null !== Cf) {
              f = Af;
              var g = Cf;
              d = g.busyMinDurationMs | 0;
              0 >= d ? d = 0 : (e = g.busyDelayMs | 0, f = E() - (10 * (1073741821 - f) - (g.timeoutMs | 0 || 5E3)), d = f <= e ? 0 : e + d - f);

              if (10 < d) {
                Pf(a, c);
                a.timeoutHandle = Ma(ag.bind(null, a), d);
                break;
              }
            }

            ag(a);
            break;

          default:
            throw Error(n(329));
        }
        Z(a);
        if (a.callbackNode === b) return Tf.bind(null, a);
      }
    }

    return null;
  }

  function Of(a) {
    var b = a.lastExpiredTime;
    b = 0 !== b ? b : 1073741823;
    if (a.finishedExpirationTime === b) ag(a);else {
      if ((T & (S | sf)) !== R) throw Error(n(327));
      Vf();
      a === U && b === W || Wf(a, b);

      if (null !== V) {
        var c = T;
        T |= S;
        var d = Xf();

        do try {
          bg();
          break;
        } catch (e) {
          Zf(a, e);
        } while (1);

        wc();
        T = c;
        pf.current = d;
        if (X === uf) throw c = zf, Wf(a, b), Pf(a, b), Z(a), c;
        if (null !== V) throw Error(n(261));
        a.finishedWork = a.current.alternate;
        a.finishedExpirationTime = b;
        U = null;
        ag(a);
        Z(a);
      }
    }
    return null;
  }

  function cg(a, b) {
    Uf(a, b);
    Z(a);
    (T & (S | sf)) === R && F();
  }

  function dg() {
    if (null !== Jf) {
      var a = Jf;
      Jf = null;
      a.forEach(function (a, c) {
        Uf(c, a);
        Z(c);
      });
      F();
    }
  }

  function eg(a, b) {
    if ((T & (S | sf)) !== R) throw Error(n(187));
    var c = T;
    T |= 1;

    try {
      return hc(99, a.bind(null, b));
    } finally {
      T = c, F();
    }
  }

  function Wf(a, b) {
    a.finishedWork = null;
    a.finishedExpirationTime = 0;
    var c = a.timeoutHandle;
    c !== Oa && (a.timeoutHandle = Oa, Na(c));
    if (null !== V) for (c = V.return; null !== c;) {
      var d = c;

      switch (d.tag) {
        case 1:
          var e = d.type.childContextTypes;
          null !== e && void 0 !== e && Gb();
          break;

        case 3:
          rd();
          Hb();
          break;

        case 5:
          td(d);
          break;

        case 4:
          rd();
          break;

        case 13:
          y(I);
          break;

        case 19:
          y(I);
          break;

        case 10:
          yc(d);
      }

      c = c.return;
    }
    U = a;
    V = fd(a.current, null);
    W = b;
    X = tf;
    zf = null;
    Bf = Af = 1073741823;
    Cf = null;
    Df = 0;
    Ef = !1;
  }

  function Zf(a, b) {
    do {
      try {
        wc();
        Nd();
        if (null === V || null === V.return) return X = uf, zf = b, null;

        a: {
          var c = a,
              d = V.return,
              e = V,
              f = b;
          b = W;
          e.effectTag |= 2048;
          e.firstEffect = e.lastEffect = null;

          if (null !== f && "object" === typeof f && "function" === typeof f.then) {
            var g = f,
                l = 0 !== (I.current & 1),
                h = d;

            do {
              var k;

              if (k = 13 === h.tag) {
                var p = h.memoizedState;
                if (null !== p) k = null !== p.dehydrated ? !0 : !1;else {
                  var D = h.memoizedProps;
                  k = void 0 === D.fallback ? !1 : !0 !== D.unstable_avoidThisFallback ? !0 : l ? !1 : !0;
                }
              }

              if (k) {
                var x = h.updateQueue;

                if (null === x) {
                  var K = new Set();
                  K.add(g);
                  h.updateQueue = K;
                } else x.add(g);

                if (0 === (h.mode & 2)) {
                  h.effectTag |= 64;
                  e.effectTag &= -2981;
                  if (1 === e.tag) if (null === e.alternate) e.tag = 17;else {
                    var Ha = Gc(1073741823, null);
                    Ha.tag = 2;
                    Ic(e, Ha);
                  }
                  e.expirationTime = 1073741823;
                  break a;
                }

                f = void 0;
                e = b;
                var O = c.pingCache;
                null === O ? (O = c.pingCache = new hf(), f = new Set(), O.set(g, f)) : (f = O.get(g), void 0 === f && (f = new Set(), O.set(g, f)));

                if (!f.has(e)) {
                  f.add(e);
                  var w = fg.bind(null, c, g, e);
                  g.then(w, w);
                }

                h.effectTag |= 4096;
                h.expirationTime = b;
                break a;
              }

              h = h.return;
            } while (null !== h);

            f = Error((ta(e.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + Ab(e));
          }

          X !== yf && (X = vf);
          f = Ne(f, e);
          h = d;

          do {
            switch (h.tag) {
              case 3:
                g = f;
                h.effectTag |= 4096;
                h.expirationTime = b;
                var r = jf(h, g, b);
                Jc(h, r);
                break a;

              case 1:
                g = f;
                var t = h.type,
                    N = h.stateNode;

                if (0 === (h.effectTag & 64) && ("function" === typeof t.getDerivedStateFromError || null !== N && "function" === typeof N.componentDidCatch && (null === nf || !nf.has(N)))) {
                  h.effectTag |= 4096;
                  h.expirationTime = b;
                  var Mc = mf(h, g, b);
                  Jc(h, Mc);
                  break a;
                }

            }

            h = h.return;
          } while (null !== h);
        }

        V = gg(V);
      } catch (Sb) {
        b = Sb;
        continue;
      }

      break;
    } while (1);
  }

  function Xf() {
    var a = pf.current;
    pf.current = Md;
    return null === a ? Md : a;
  }

  function Oc(a, b) {
    a < Af && 2 < a && (Af = a);
    null !== b && a < Bf && 2 < a && (Bf = a, Cf = b);
  }

  function Pc(a) {
    a > Df && (Df = a);
  }

  function bg() {
    for (; null !== V;) V = hg(V);
  }

  function Yf() {
    for (; null !== V && !Pb();) V = hg(V);
  }

  function hg(a) {
    var b = ig(a.alternate, a, W);
    a.memoizedProps = a.pendingProps;
    null === b && (b = gg(a));
    qf.current = null;
    return b;
  }

  function gg(a) {
    V = a;

    do {
      var b = V.alternate;
      a = V.return;

      if (0 === (V.effectTag & 2048)) {
        a: {
          var c = b;
          b = V;
          var d = W,
              e = b.pendingProps;

          switch (b.tag) {
            case 2:
              break;

            case 16:
              break;

            case 15:
            case 0:
              break;

            case 1:
              C(b.type) && Gb();
              break;

            case 3:
              rd();
              Hb();
              e = b.stateNode;
              e.pendingContext && (e.context = e.pendingContext, e.pendingContext = null);
              (null === c || null === c.child) && ne(b) && Fe(b);
              He(b);
              break;

            case 5:
              td(b);
              var f = pd(od.current);
              d = b.type;
              if (null !== c && null != b.stateNode) Ie(c, b, d, e, f), c.ref !== b.ref && (b.effectTag |= 128);else if (e) {
                c = pd(H.current);

                if (ne(b)) {
                  e = b;
                  if (!Sa) throw Error(n(175));
                  c = ub(e.stateNode, e.type, e.memoizedProps, f, c, e);
                  e.updateQueue = c;
                  c = null !== c ? !0 : !1;
                  c && Fe(b);
                } else {
                  var g = Ea(d, e, f, c, b);
                  Ge(g, b, !1, !1);
                  b.stateNode = g;
                  Ga(g, d, e, f, c) && Fe(b);
                }

                null !== b.ref && (b.effectTag |= 128);
              } else if (null === b.stateNode) throw Error(n(166));
              break;

            case 6:
              if (c && null != b.stateNode) Je(c, b, c.memoizedProps, e);else {
                if ("string" !== typeof e && null === b.stateNode) throw Error(n(166));
                c = pd(od.current);
                f = pd(H.current);

                if (ne(b)) {
                  c = b;
                  if (!Sa) throw Error(n(176));
                  (c = vb(c.stateNode, c.memoizedProps, c)) && Fe(b);
                } else b.stateNode = La(e, c, f, b);
              }
              break;

            case 11:
              break;

            case 13:
              y(I);
              e = b.memoizedState;

              if (0 !== (b.effectTag & 64)) {
                b.expirationTime = d;
                break a;
              }

              e = null !== e;
              f = !1;
              null === c ? void 0 !== b.memoizedProps.fallback && ne(b) : (d = c.memoizedState, f = null !== d, e || null === d || (d = c.child.sibling, null !== d && (g = b.firstEffect, null !== g ? (b.firstEffect = d, d.nextEffect = g) : (b.firstEffect = b.lastEffect = d, d.nextEffect = null), d.effectTag = 8)));
              if (e && !f && 0 !== (b.mode & 2)) if (null === c && !0 !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (I.current & 1)) X === tf && (X = wf);else {
                if (X === tf || X === wf) X = xf;
                0 !== Df && null !== U && (Pf(U, W), Qf(U, Df));
              }
              Ra && e && (b.effectTag |= 4);
              Qa && (e || f) && (b.effectTag |= 4);
              break;

            case 7:
              break;

            case 8:
              break;

            case 12:
              break;

            case 4:
              rd();
              He(b);
              break;

            case 10:
              yc(b);
              break;

            case 9:
              break;

            case 14:
              break;

            case 17:
              C(b.type) && Gb();
              break;

            case 19:
              y(I);
              e = b.memoizedState;
              if (null === e) break;
              f = 0 !== (b.effectTag & 64);
              g = e.rendering;
              if (null === g) {
                if (f) Le(e, !1);else {
                  if (X !== tf || null !== c && 0 !== (c.effectTag & 64)) for (c = b.child; null !== c;) {
                    g = ud(c);

                    if (null !== g) {
                      b.effectTag |= 64;
                      Le(e, !1);
                      c = g.updateQueue;
                      null !== c && (b.updateQueue = c, b.effectTag |= 4);
                      null === e.lastEffect && (b.firstEffect = null);
                      b.lastEffect = e.lastEffect;
                      c = d;

                      for (e = b.child; null !== e;) f = e, d = c, f.effectTag &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, null === g ? (f.childExpirationTime = 0, f.expirationTime = d, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null) : (f.childExpirationTime = g.childExpirationTime, f.expirationTime = g.expirationTime, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, d = g.dependencies, f.dependencies = null === d ? null : {
                        expirationTime: d.expirationTime,
                        firstContext: d.firstContext,
                        responders: d.responders
                      }), e = e.sibling;

                      z(I, I.current & 1 | 2);
                      b = b.child;
                      break a;
                    }

                    c = c.sibling;
                  }
                }
              } else {
                if (!f) if (c = ud(g), null !== c) {
                  if (b.effectTag |= 64, f = !0, c = c.updateQueue, null !== c && (b.updateQueue = c, b.effectTag |= 4), Le(e, !0), null === e.tail && "hidden" === e.tailMode && !g.alternate) {
                    b = b.lastEffect = e.lastEffect;
                    null !== b && (b.nextEffect = null);
                    break;
                  }
                } else E() > e.tailExpiration && 1 < d && (b.effectTag |= 64, f = !0, Le(e, !1), b.expirationTime = b.childExpirationTime = d - 1);
                e.isBackwards ? (g.sibling = b.child, b.child = g) : (c = e.last, null !== c ? c.sibling = g : b.child = g, e.last = g);
              }

              if (null !== e.tail) {
                0 === e.tailExpiration && (e.tailExpiration = E() + 500);
                c = e.tail;
                e.rendering = c;
                e.tail = c.sibling;
                e.lastEffect = b.lastEffect;
                c.sibling = null;
                e = I.current;
                e = f ? e & 1 | 2 : e & 1;
                z(I, e);
                b = c;
                break a;
              }

              break;

            case 20:
              break;

            case 21:
              break;

            default:
              throw Error(n(156, b.tag));
          }

          b = null;
        }

        c = V;

        if (1 === W || 1 !== c.childExpirationTime) {
          e = 0;

          for (f = c.child; null !== f;) d = f.expirationTime, g = f.childExpirationTime, d > e && (e = d), g > e && (e = g), f = f.sibling;

          c.childExpirationTime = e;
        }

        if (null !== b) return b;
        null !== a && 0 === (a.effectTag & 2048) && (null === a.firstEffect && (a.firstEffect = V.firstEffect), null !== V.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = V.firstEffect), a.lastEffect = V.lastEffect), 1 < V.effectTag && (null !== a.lastEffect ? a.lastEffect.nextEffect = V : a.firstEffect = V, a.lastEffect = V));
      } else {
        b = Me(V);
        if (null !== b) return b.effectTag &= 2047, b;
        null !== a && (a.firstEffect = a.lastEffect = null, a.effectTag |= 2048);
      }

      b = V.sibling;
      if (null !== b) return b;
      V = a;
    } while (null !== V);

    X === tf && (X = yf);
    return null;
  }

  function $f(a) {
    var b = a.expirationTime;
    a = a.childExpirationTime;
    return b > a ? b : a;
  }

  function ag(a) {
    var b = fc();
    hc(99, jg.bind(null, a, b));
    return null;
  }

  function jg(a, b) {
    do Vf(); while (null !== Hf);

    if ((T & (S | sf)) !== R) throw Error(n(327));
    var c = a.finishedWork,
        d = a.finishedExpirationTime;
    if (null === c) return null;
    a.finishedWork = null;
    a.finishedExpirationTime = 0;
    if (c === a.current) throw Error(n(177));
    a.callbackNode = null;
    a.callbackExpirationTime = 0;
    a.callbackPriority = 90;
    a.nextKnownPendingLevel = 0;
    var e = $f(c);
    a.firstPendingTime = e;
    d <= a.lastSuspendedTime ? a.firstSuspendedTime = a.lastSuspendedTime = a.nextKnownPendingLevel = 0 : d <= a.firstSuspendedTime && (a.firstSuspendedTime = d - 1);
    d <= a.lastPingedTime && (a.lastPingedTime = 0);
    d <= a.lastExpiredTime && (a.lastExpiredTime = 0);
    a === U && (V = U = null, W = 0);
    1 < c.effectTag ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, e = c.firstEffect) : e = c : e = c.firstEffect;

    if (null !== e) {
      var f = T;
      T |= sf;
      qf.current = null;
      Ca(a.containerInfo);
      Y = e;

      do try {
        kg();
      } catch (jb) {
        if (null === Y) throw Error(n(330));
        Re(Y, jb);
        Y = Y.nextEffect;
      } while (null !== Y);

      Y = e;

      do try {
        for (var g = a, l = b; null !== Y;) {
          var h = Y.effectTag;
          h & 16 && Qa && bb(Y.stateNode);

          if (h & 128) {
            var k = Y.alternate;

            if (null !== k) {
              var p = k.ref;
              null !== p && ("function" === typeof p ? p(null) : p.current = null);
            }
          }

          switch (h & 1038) {
            case 2:
              bf(Y);
              Y.effectTag &= -3;
              break;

            case 6:
              bf(Y);
              Y.effectTag &= -3;
              cf(Y.alternate, Y);
              break;

            case 1024:
              Y.effectTag &= -1025;
              break;

            case 1028:
              Y.effectTag &= -1025;
              cf(Y.alternate, Y);
              break;

            case 4:
              cf(Y.alternate, Y);
              break;

            case 8:
              var D = g,
                  x = Y,
                  K = l;
              Qa ? Xe(D, x, K) : Ze(D, x, K);
              $e(x);
          }

          Y = Y.nextEffect;
        }
      } catch (jb) {
        if (null === Y) throw Error(n(330));
        Re(Y, jb);
        Y = Y.nextEffect;
      } while (null !== Y);

      Da(a.containerInfo);
      a.current = c;
      Y = e;

      do try {
        for (h = d; null !== Y;) {
          var Ha = Y.effectTag;

          if (Ha & 36) {
            var O = Y.alternate;
            k = Y;
            p = h;

            switch (k.tag) {
              case 0:
              case 11:
              case 15:
                Ue(16, 32, k);
                break;

              case 1:
                var w = k.stateNode;
                if (k.effectTag & 4) if (null === O) w.componentDidMount();else {
                  var r = k.elementType === k.type ? O.memoizedProps : rc(k.type, O.memoizedProps);
                  w.componentDidUpdate(r, O.memoizedState, w.__reactInternalSnapshotBeforeUpdate);
                }
                var t = k.updateQueue;
                null !== t && Qc(k, t, w, p);
                break;

              case 3:
                var N = k.updateQueue;

                if (null !== N) {
                  g = null;
                  if (null !== k.child) switch (k.child.tag) {
                    case 5:
                      g = za(k.child.stateNode);
                      break;

                    case 1:
                      g = k.child.stateNode;
                  }
                  Qc(k, N, g, p);
                }

                break;

              case 5:
                var Mc = k.stateNode;
                null === O && k.effectTag & 4 && Wa(Mc, k.type, k.memoizedProps, k);
                break;

              case 6:
                break;

              case 4:
                break;

              case 12:
                break;

              case 13:
                if (Sa && null === k.memoizedState) {
                  var Sb = k.alternate;

                  if (null !== Sb) {
                    var le = Sb.memoizedState;

                    if (null !== le) {
                      var me = le.dehydrated;
                      null !== me && yb(me);
                    }
                  }
                }

                break;

              case 19:
              case 17:
              case 20:
              case 21:
                break;

              default:
                throw Error(n(163));
            }
          }

          if (Ha & 128) {
            k = void 0;
            var Tb = Y.ref;

            if (null !== Tb) {
              var v = Y.stateNode;

              switch (Y.tag) {
                case 5:
                  k = za(v);
                  break;

                default:
                  k = v;
              }

              "function" === typeof Tb ? Tb(k) : Tb.current = k;
            }
          }

          Y = Y.nextEffect;
        }
      } catch (jb) {
        if (null === Y) throw Error(n(330));
        Re(Y, jb);
        Y = Y.nextEffect;
      } while (null !== Y);

      Y = null;
      ac();
      T = f;
    } else a.current = c;

    if (Gf) Gf = !1, Hf = a, If = b;else for (Y = e; null !== Y;) b = Y.nextEffect, Y.nextEffect = null, Y = b;
    b = a.firstPendingTime;
    0 === b && (nf = null);
    1073741823 === b ? a === Lf ? Kf++ : (Kf = 0, Lf = a) : Kf = 0;
    "function" === typeof lg && lg(c.stateNode, d);
    Z(a);
    if (kf) throw kf = !1, a = lf, lf = null, a;
    if ((T & rf) !== R) return null;
    F();
    return null;
  }

  function kg() {
    for (; null !== Y;) {
      var a = Y.effectTag;
      0 !== (a & 256) && Te(Y.alternate, Y);
      0 === (a & 512) || Gf || (Gf = !0, ic(97, function () {
        Vf();
        return null;
      }));
      Y = Y.nextEffect;
    }
  }

  function Vf() {
    if (90 !== If) {
      var a = 97 < If ? 97 : If;
      If = 90;
      return hc(a, mg);
    }
  }

  function mg() {
    if (null === Hf) return !1;
    var a = Hf;
    Hf = null;
    if ((T & (S | sf)) !== R) throw Error(n(331));
    var b = T;
    T |= sf;

    for (a = a.current.firstEffect; null !== a;) {
      try {
        var c = a;
        if (0 !== (c.effectTag & 512)) switch (c.tag) {
          case 0:
          case 11:
          case 15:
            Ue(128, 0, c), Ue(0, 64, c);
        }
      } catch (d) {
        if (null === a) throw Error(n(330));
        Re(a, d);
      }

      c = a.nextEffect;
      a.nextEffect = null;
      a = c;
    }

    T = b;
    F();
    return !0;
  }

  function ng(a, b, c) {
    b = Ne(c, b);
    b = jf(a, b, 1073741823);
    Ic(a, b);
    a = Nf(a, 1073741823);
    null !== a && Z(a);
  }

  function Re(a, b) {
    if (3 === a.tag) ng(a, a, b);else for (var c = a.return; null !== c;) {
      if (3 === c.tag) {
        ng(c, a, b);
        break;
      } else if (1 === c.tag) {
        var d = c.stateNode;

        if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === nf || !nf.has(d))) {
          a = Ne(b, a);
          a = mf(c, a, 1073741823);
          Ic(c, a);
          c = Nf(c, 1073741823);
          null !== c && Z(c);
          break;
        }
      }

      c = c.return;
    }
  }

  function fg(a, b, c) {
    var d = a.pingCache;
    null !== d && d.delete(b);
    U === a && W === c ? X === xf || X === wf && 1073741823 === Af && E() - ff < Ff ? Wf(a, W) : Ef = !0 : Sf(a, c) && (b = a.lastPingedTime, 0 !== b && b < c || (a.lastPingedTime = c, a.finishedExpirationTime === c && (a.finishedExpirationTime = 0, a.finishedWork = null), Z(a)));
  }

  function gf(a, b) {
    var c = a.stateNode;
    null !== c && c.delete(b);
    b = 0;
    0 === b && (b = G(), b = Vc(b, a, null));
    a = Nf(a, b);
    null !== a && Z(a);
  }

  var ig;

  ig = function (a, b, c) {
    var d = b.expirationTime;

    if (null !== a) {
      var e = b.pendingProps;
      if (a.memoizedProps !== e || B.current) Bc = !0;else {
        if (d < c) {
          Bc = !1;

          switch (b.tag) {
            case 3:
              ze(b);
              oe();
              break;

            case 5:
              sd(b);
              if (b.mode & 4 && 1 !== c && Ka(b.type, e)) return b.expirationTime = b.childExpirationTime = 1, null;
              break;

            case 1:
              C(b.type) && Kb(b);
              break;

            case 4:
              qd(b, b.stateNode.containerInfo);
              break;

            case 10:
              xc(b, b.memoizedProps.value);
              break;

            case 13:
              if (null !== b.memoizedState) {
                d = b.child.childExpirationTime;
                if (0 !== d && d >= c) return Be(a, b, c);
                z(I, I.current & 1);
                b = re(a, b, c);
                return null !== b ? b.sibling : null;
              }

              z(I, I.current & 1);
              break;

            case 19:
              d = b.childExpirationTime >= c;

              if (0 !== (a.effectTag & 64)) {
                if (d) return Ee(a, b, c);
                b.effectTag |= 64;
              }

              e = b.memoizedState;
              null !== e && (e.rendering = null, e.tail = null);
              z(I, I.current);
              if (!d) return null;
          }

          return re(a, b, c);
        }

        Bc = !1;
      }
    } else Bc = !1;

    b.expirationTime = 0;

    switch (b.tag) {
      case 2:
        d = b.type;
        null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2);
        a = b.pendingProps;
        e = Fb(b, A.current);
        Ac(b, c);
        e = Jd(null, b, d, a, e, c);
        b.effectTag |= 1;

        if ("object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
          b.tag = 1;
          Nd();

          if (C(d)) {
            var f = !0;
            Kb(b);
          } else f = !1;

          b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
          var g = d.getDerivedStateFromProps;
          "function" === typeof g && Uc(b, d, g, a);
          e.updater = Xc;
          b.stateNode = e;
          e._reactInternalFiber = b;
          ad(b, d, a, c);
          b = ye(null, b, d, !0, f, c);
        } else b.tag = 0, Q(null, b, e, c), b = b.child;

        return b;

      case 16:
        e = b.elementType;
        null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2);
        a = b.pendingProps;
        sa(e);
        if (1 !== e._status) throw e._result;
        e = e._result;
        b.type = e;
        f = b.tag = og(e);
        a = rc(e, a);

        switch (f) {
          case 0:
            b = ve(null, b, e, a, c);
            break;

          case 1:
            b = xe(null, b, e, a, c);
            break;

          case 11:
            b = qe(null, b, e, a, c);
            break;

          case 14:
            b = se(null, b, e, rc(e.type, a), d, c);
            break;

          default:
            throw Error(n(306, e, ""));
        }

        return b;

      case 0:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), ve(a, b, d, e, c);

      case 1:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), xe(a, b, d, e, c);

      case 3:
        ze(b);
        d = b.updateQueue;
        if (null === d) throw Error(n(282));
        e = b.memoizedState;
        e = null !== e ? e.element : null;
        Nc(b, d, b.pendingProps, null, c);
        d = b.memoizedState.element;
        if (d === e) oe(), b = re(a, b, c);else {
          if (e = b.stateNode.hydrate) Sa ? (ee = tb(b.stateNode.containerInfo), de = b, e = fe = !0) : e = !1;
          if (e) for (c = ld(b, null, d, c), b.child = c; c;) c.effectTag = c.effectTag & -3 | 1024, c = c.sibling;else Q(a, b, d, c), oe();
          b = b.child;
        }
        return b;

      case 5:
        return sd(b), null === a && je(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ja(d, e) ? g = null : null !== f && Ja(d, f) && (b.effectTag |= 16), we(a, b), b.mode & 4 && 1 !== c && Ka(d, e) ? (b.expirationTime = b.childExpirationTime = 1, b = null) : (Q(a, b, g, c), b = b.child), b;

      case 6:
        return null === a && je(b), null;

      case 13:
        return Be(a, b, c);

      case 4:
        return qd(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = kd(b, null, d, c) : Q(a, b, d, c), b.child;

      case 11:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), qe(a, b, d, e, c);

      case 7:
        return Q(a, b, b.pendingProps, c), b.child;

      case 8:
        return Q(a, b, b.pendingProps.children, c), b.child;

      case 12:
        return Q(a, b, b.pendingProps.children, c), b.child;

      case 10:
        a: {
          d = b.type._context;
          e = b.pendingProps;
          g = b.memoizedProps;
          f = e.value;
          xc(b, f);

          if (null !== g) {
            var l = g.value;
            f = oc(l, f) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(l, f) : 1073741823) | 0;

            if (0 === f) {
              if (g.children === e.children && !B.current) {
                b = re(a, b, c);
                break a;
              }
            } else for (l = b.child, null !== l && (l.return = b); null !== l;) {
              var h = l.dependencies;

              if (null !== h) {
                g = l.child;

                for (var k = h.firstContext; null !== k;) {
                  if (k.context === d && 0 !== (k.observedBits & f)) {
                    1 === l.tag && (k = Gc(c, null), k.tag = 2, Ic(l, k));
                    l.expirationTime < c && (l.expirationTime = c);
                    k = l.alternate;
                    null !== k && k.expirationTime < c && (k.expirationTime = c);
                    zc(l.return, c);
                    h.expirationTime < c && (h.expirationTime = c);
                    break;
                  }

                  k = k.next;
                }
              } else g = 10 === l.tag ? l.type === b.type ? null : l.child : l.child;

              if (null !== g) g.return = l;else for (g = l; null !== g;) {
                if (g === b) {
                  g = null;
                  break;
                }

                l = g.sibling;

                if (null !== l) {
                  l.return = g.return;
                  g = l;
                  break;
                }

                g = g.return;
              }
              l = g;
            }
          }

          Q(a, b, e.children, c);
          b = b.child;
        }

        return b;

      case 9:
        return e = b.type, f = b.pendingProps, d = f.children, Ac(b, c), e = Cc(e, f.unstable_observedBits), d = d(e), b.effectTag |= 1, Q(a, b, d, c), b.child;

      case 14:
        return e = b.type, f = rc(e, b.pendingProps), f = rc(e.type, f), se(a, b, e, f, d, c);

      case 15:
        return ue(a, b, b.type, b.pendingProps, d, c);

      case 17:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2), b.tag = 1, C(d) ? (a = !0, Kb(b)) : a = !1, Ac(b, c), Zc(b, d, e), ad(b, d, e, c), ye(null, b, d, !0, a, c);

      case 19:
        return Ee(a, b, c);
    }

    throw Error(n(156, b.tag));
  };

  var lg = null,
      We = null;

  function pg(a) {
    if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
    var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (b.isDisabled || !b.supportsFiber) return !0;

    try {
      var c = b.inject(a);

      lg = function (a) {
        try {
          b.onCommitFiberRoot(c, a, void 0, 64 === (a.current.effectTag & 64));
        } catch (e) {}
      };

      We = function (a) {
        try {
          b.onCommitFiberUnmount(c, a);
        } catch (e) {}
      };
    } catch (d) {}

    return !0;
  }

  function qg(a, b, c, d) {
    this.tag = a;
    this.key = c;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d;
    this.effectTag = 0;
    this.lastEffect = this.firstEffect = this.nextEffect = null;
    this.childExpirationTime = this.expirationTime = 0;
    this.alternate = null;
  }

  function he(a, b, c, d) {
    return new qg(a, b, c, d);
  }

  function te(a) {
    a = a.prototype;
    return !(!a || !a.isReactComponent);
  }

  function og(a) {
    if ("function" === typeof a) return te(a) ? 1 : 0;

    if (void 0 !== a && null !== a) {
      a = a.$$typeof;
      if (a === la) return 11;
      if (a === oa) return 14;
    }

    return 2;
  }

  function fd(a, b) {
    var c = a.alternate;
    null === c ? (c = he(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.effectTag = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
    c.childExpirationTime = a.childExpirationTime;
    c.expirationTime = a.expirationTime;
    c.child = a.child;
    c.memoizedProps = a.memoizedProps;
    c.memoizedState = a.memoizedState;
    c.updateQueue = a.updateQueue;
    b = a.dependencies;
    c.dependencies = null === b ? null : {
      expirationTime: b.expirationTime,
      firstContext: b.firstContext,
      responders: b.responders
    };
    c.sibling = a.sibling;
    c.index = a.index;
    c.ref = a.ref;
    return c;
  }

  function hd(a, b, c, d, e, f) {
    var g = 2;
    d = a;
    if ("function" === typeof a) te(a) && (g = 1);else if ("string" === typeof a) g = 5;else a: switch (a) {
      case ea:
        return jd(c.children, e, f, b);

      case ka:
        g = 8;
        e |= 7;
        break;

      case fa:
        g = 8;
        e |= 1;
        break;

      case ha:
        return a = he(12, c, b, e | 8), a.elementType = ha, a.type = ha, a.expirationTime = f, a;

      case ma:
        return a = he(13, c, b, e), a.type = ma, a.elementType = ma, a.expirationTime = f, a;

      case na:
        return a = he(19, c, b, e), a.elementType = na, a.expirationTime = f, a;

      default:
        if ("object" === typeof a && null !== a) switch (a.$$typeof) {
          case ia:
            g = 10;
            break a;

          case ja:
            g = 9;
            break a;

          case la:
            g = 11;
            break a;

          case oa:
            g = 14;
            break a;

          case pa:
            g = 16;
            d = null;
            break a;
        }
        throw Error(n(130, null == a ? a : typeof a, ""));
    }
    b = he(g, c, b, e);
    b.elementType = a;
    b.type = d;
    b.expirationTime = f;
    return b;
  }

  function jd(a, b, c, d) {
    a = he(7, a, d, b);
    a.expirationTime = c;
    return a;
  }

  function gd(a, b, c) {
    a = he(6, a, null, b);
    a.expirationTime = c;
    return a;
  }

  function id(a, b, c) {
    b = he(4, null !== a.children ? a.children : [], a.key, b);
    b.expirationTime = c;
    b.stateNode = {
      containerInfo: a.containerInfo,
      pendingChildren: null,
      implementation: a.implementation
    };
    return b;
  }

  function rg(a, b, c) {
    this.tag = b;
    this.current = null;
    this.containerInfo = a;
    this.pingCache = this.pendingChildren = null;
    this.finishedExpirationTime = 0;
    this.finishedWork = null;
    this.timeoutHandle = Oa;
    this.pendingContext = this.context = null;
    this.hydrate = c;
    this.callbackNode = null;
    this.callbackPriority = 90;
    this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;
  }

  function Sf(a, b) {
    var c = a.firstSuspendedTime;
    a = a.lastSuspendedTime;
    return 0 !== c && c >= b && a <= b;
  }

  function Pf(a, b) {
    var c = a.firstSuspendedTime,
        d = a.lastSuspendedTime;
    c < b && (a.firstSuspendedTime = b);
    if (d > b || 0 === c) a.lastSuspendedTime = b;
    b <= a.lastPingedTime && (a.lastPingedTime = 0);
    b <= a.lastExpiredTime && (a.lastExpiredTime = 0);
  }

  function Qf(a, b) {
    b > a.firstPendingTime && (a.firstPendingTime = b);
    var c = a.firstSuspendedTime;
    0 !== c && (b >= c ? a.firstSuspendedTime = a.lastSuspendedTime = a.nextKnownPendingLevel = 0 : b >= a.lastSuspendedTime && (a.lastSuspendedTime = b + 1), b > a.nextKnownPendingLevel && (a.nextKnownPendingLevel = b));
  }

  function Uf(a, b) {
    var c = a.lastExpiredTime;
    if (0 === c || c > b) a.lastExpiredTime = b;
  }

  function sg(a) {
    var b = a._reactInternalFiber;

    if (void 0 === b) {
      if ("function" === typeof a.render) throw Error(n(188));
      throw Error(n(268, Object.keys(a)));
    }

    a = xa(b);
    return null === a ? null : a.stateNode;
  }

  function tg(a, b) {
    a = a.memoizedState;
    null !== a && null !== a.dehydrated && a.retryTime < b && (a.retryTime = b);
  }

  function ug(a, b) {
    tg(a, b);
    (a = a.alternate) && tg(a, b);
  }

  var vg = {
    createContainer: function (a, b, c) {
      a = new rg(a, b, c);
      b = he(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
      a.current = b;
      return b.stateNode = a;
    },
    updateContainer: function (a, b, c, d) {
      var e = b.current,
          f = G(),
          g = Sc.suspense;
      f = Vc(f, e, g);

      a: if (c) {
        c = c._reactInternalFiber;

        b: {
          if (ua(c) !== c || 1 !== c.tag) throw Error(n(170));
          var l = c;

          do {
            switch (l.tag) {
              case 3:
                l = l.stateNode.context;
                break b;

              case 1:
                if (C(l.type)) {
                  l = l.stateNode.__reactInternalMemoizedMergedChildContext;
                  break b;
                }

            }

            l = l.return;
          } while (null !== l);

          throw Error(n(171));
        }

        if (1 === c.tag) {
          var h = c.type;

          if (C(h)) {
            c = Jb(c, h, l);
            break a;
          }
        }

        c = l;
      } else c = Db;

      null === b.context ? b.context = c : b.pendingContext = c;
      b = Gc(f, g);
      b.payload = {
        element: a
      };
      d = void 0 === d ? null : d;
      null !== d && (b.callback = d);
      Ic(e, b);
      Wc(e, f);
      return f;
    },
    batchedEventUpdates: function (a, b) {
      var c = T;
      T |= 2;

      try {
        return a(b);
      } finally {
        T = c, T === R && F();
      }
    },
    batchedUpdates: function (a, b) {
      var c = T;
      T |= 1;

      try {
        return a(b);
      } finally {
        T = c, T === R && F();
      }
    },
    unbatchedUpdates: function (a, b) {
      var c = T;
      T &= -2;
      T |= rf;

      try {
        return a(b);
      } finally {
        T = c, T === R && F();
      }
    },
    deferredUpdates: function (a) {
      return hc(97, a);
    },
    syncUpdates: function (a, b, c, d) {
      return hc(99, a.bind(null, b, c, d));
    },
    discreteUpdates: function (a, b, c, d) {
      var e = T;
      T |= 4;

      try {
        return hc(98, a.bind(null, b, c, d));
      } finally {
        T = e, T === R && F();
      }
    },
    flushDiscreteUpdates: function () {
      (T & (1 | S | sf)) === R && (dg(), Vf());
    },
    flushControlled: function (a) {
      var b = T;
      T |= 1;

      try {
        hc(99, a);
      } finally {
        T = b, T === R && F();
      }
    },
    flushSync: eg,
    flushPassiveEffects: Vf,
    IsThisRendererActing: {
      current: !1
    },
    getPublicRootInstance: function (a) {
      a = a.current;
      if (!a.child) return null;

      switch (a.child.tag) {
        case 5:
          return za(a.child.stateNode);

        default:
          return a.child.stateNode;
      }
    },
    attemptSynchronousHydration: function (a) {
      switch (a.tag) {
        case 3:
          var b = a.stateNode;
          b.hydrate && cg(b, b.firstPendingTime);
          break;

        case 13:
          eg(function () {
            return Wc(a, 1073741823);
          }), b = mc(G(), 150, 100), ug(a, b);
      }
    },
    attemptUserBlockingHydration: function (a) {
      if (13 === a.tag) {
        var b = mc(G(), 150, 100);
        Wc(a, b);
        ug(a, b);
      }
    },
    attemptContinuousHydration: function (a) {
      if (13 === a.tag) {
        G();
        var b = lc++;
        Wc(a, b);
        ug(a, b);
      }
    },
    attemptHydrationAtCurrentPriority: function (a) {
      if (13 === a.tag) {
        var b = G();
        b = Vc(b, a, null);
        Wc(a, b);
        ug(a, b);
      }
    },
    findHostInstance: sg,
    findHostInstanceWithWarning: function (a) {
      return sg(a);
    },
    findHostInstanceWithNoPortals: function (a) {
      a = ya(a);
      return null === a ? null : 20 === a.tag ? a.stateNode.instance : a.stateNode;
    },
    shouldSuspend: function () {
      return !1;
    },
    injectIntoDevTools: function (a) {
      var b = a.findFiberByHostInstance;
      return pg(aa({}, a, {
        overrideHookState: null,
        overrideProps: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: q.ReactCurrentDispatcher,
        findHostInstanceByFiber: function (a) {
          a = xa(a);
          return null === a ? null : a.stateNode;
        },
        findFiberByHostInstance: function (a) {
          return b ? b(a) : null;
        },
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null
      }));
    }
  };
  module.exports = vg.default || vg;
  var $$$renderer = module.exports;
  module.exports = $$$reconciler;
  return $$$renderer;
};
});

var reactReconciler = createCommonjsModule(function (module) {

{
  module.exports = reactReconciler_production_min;
}
});

var dom = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTextNode = exports.setAttribute = exports.removeChildNode = exports.insertBeforeNode = exports.appendStaticNode = exports.appendChildNode = exports.createNode = void 0;

// Helper utilities implementing some common DOM methods to simplify reconciliation code
const createNode = tagName => ({
  nodeName: tagName.toUpperCase(),
  style: {},
  attributes: {},
  childNodes: [],
  parentNode: null
});

exports.createNode = createNode;

const appendChildNode = (node, childNode) => {
  if (childNode.parentNode) {
    removeChildNode(childNode.parentNode, childNode);
  }

  childNode.parentNode = node;
  node.childNodes.push(childNode);
}; // Same as `appendChildNode`, but without removing child node from parent node


exports.appendChildNode = appendChildNode;

const appendStaticNode = (node, childNode) => {
  node.childNodes.push(childNode);
};

exports.appendStaticNode = appendStaticNode;

const insertBeforeNode = (node, newChildNode, beforeChildNode) => {
  if (newChildNode.parentNode) {
    removeChildNode(newChildNode.parentNode, newChildNode);
  }

  newChildNode.parentNode = node;
  const index = node.childNodes.indexOf(beforeChildNode);

  if (index >= 0) {
    node.childNodes.splice(index, 0, newChildNode);
    return;
  }

  node.childNodes.push(newChildNode);
};

exports.insertBeforeNode = insertBeforeNode;

const removeChildNode = (node, removeNode) => {
  removeNode.parentNode = null;
  const index = node.childNodes.indexOf(removeNode);

  if (index >= 0) {
    node.childNodes.splice(index, 1);
  }
};

exports.removeChildNode = removeChildNode;

const setAttribute = (node, key, value) => {
  node.attributes[key] = value;
};

exports.setAttribute = setAttribute;

const createTextNode = text => ({
  nodeName: '#text',
  nodeValue: text
});

exports.createTextNode = createTextNode;
});

var reconciler = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;



var _reactReconciler = _interopRequireDefault(reactReconciler);



function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NO_CONTEXT = true;
const hostConfig = {
  schedulePassiveEffects: scheduler.unstable_scheduleCallback,
  cancelPassiveEffects: scheduler.unstable_cancelCallback,
  now: Date.now,
  getRootHostContext: () => NO_CONTEXT,
  prepareForCommit: () => {},
  resetAfterCommit: rootNode => {
    rootNode.onRender();
  },
  getChildHostContext: () => NO_CONTEXT,
  shouldSetTextContent: (type, props) => {
    return typeof props.children === 'string' || typeof props.children === 'number';
  },
  createInstance: (type, newProps) => {
    const node = (0, dom.createNode)(type);

    for (const [key, value] of Object.entries(newProps)) {
      if (key === 'children') {
        if (typeof value === 'string' || typeof value === 'number') {
          if (type === 'div') {
            // Text node must be wrapped in another node, so that text can be aligned within container
            const textElement = (0, dom.createNode)('div');
            textElement.textContent = String(value);
            (0, dom.appendChildNode)(node, textElement);
          }

          if (type === 'span') {
            node.textContent = String(value);
          }
        }
      } else if (key === 'style') {
        node.style = value;
      } else if (key === 'unstable__transformChildren') {
        node.unstable__transformChildren = value; // eslint-disable-line camelcase
      } else if (key === 'unstable__static') {
        node.unstable__static = true; // eslint-disable-line camelcase
      } else {
        (0, dom.setAttribute)(node, key, value);
      }
    }

    return node;
  },
  createTextInstance: dom.createTextNode,
  resetTextContent: node => {
    if (node.textContent) {
      node.textContent = '';
    }

    if (node.childNodes.length > 0) {
      for (const childNode of node.childNodes) {
        childNode.yogaNode.free();
        (0, dom.removeChildNode)(node, childNode);
      }
    }
  },
  getPublicInstance: instance => instance,
  appendInitialChild: dom.appendChildNode,
  appendChild: dom.appendChildNode,
  insertBefore: dom.insertBeforeNode,
  finalizeInitialChildren: () => {},
  supportsMutation: true,
  appendChildToContainer: dom.appendChildNode,
  insertInContainerBefore: dom.insertBeforeNode,
  removeChildFromContainer: dom.removeChildNode,
  prepareUpdate: () => true,
  commitUpdate: (node, updatePayload, type, oldProps, newProps) => {
    for (const [key, value] of Object.entries(newProps)) {
      if (key === 'children') {
        if (typeof value === 'string' || typeof value === 'number') {
          if (type === 'div') {
            // Text node must be wrapped in another node, so that text can be aligned within container
            // If there's no such node, a new one must be created
            if (node.childNodes.length === 0) {
              const textElement = (0, dom.createNode)('div');
              textElement.textContent = String(value);
              (0, dom.appendChildNode)(node, textElement);
            } else {
              node.childNodes[0].textContent = String(value);
            }
          }

          if (type === 'span') {
            node.textContent = String(value);
          }
        }
      } else if (key === 'style') {
        node.style = value;
      } else if (key === 'unstable__transformChildren') {
        node.unstable__transformChildren = value; // eslint-disable-line camelcase
      } else if (key === 'unstable__static') {
        node.unstable__static = true; // eslint-disable-line camelcase
      } else {
        (0, dom.setAttribute)(node, key, value);
      }
    }
  },
  commitTextUpdate: (node, oldText, newText) => {
    if (node.nodeName === '#text') {
      node.nodeValue = newText;
    } else {
      node.textContent = newText;
    }
  },
  removeChild: dom.removeChildNode
};

var _default = (0, _reactReconciler.default)(hostConfig); // eslint-disable-line new-cap


exports.default = _default;
});

/* eslint-disable yoda */

const isFullwidthCodePoint$1 = codePoint => {
  if (Number.isNaN(codePoint)) {
    return false;
  } // Code points are derived from:
  // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt


  if (codePoint >= 0x1100 && (codePoint <= 0x115F || // Hangul Jamo
  codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
  codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  0x3250 <= codePoint && codePoint <= 0x4DBF || // CJK Unified Ideographs .. Yi Radicals
  0x4E00 <= codePoint && codePoint <= 0xA4C6 || // Hangul Jamo Extended-A
  0xA960 <= codePoint && codePoint <= 0xA97C || // Hangul Syllables
  0xAC00 <= codePoint && codePoint <= 0xD7A3 || // CJK Compatibility Ideographs
  0xF900 <= codePoint && codePoint <= 0xFAFF || // Vertical Forms
  0xFE10 <= codePoint && codePoint <= 0xFE19 || // CJK Compatibility Forms .. Small Form Variants
  0xFE30 <= codePoint && codePoint <= 0xFE6B || // Halfwidth and Fullwidth Forms
  0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || // Kana Supplement
  0x1B000 <= codePoint && codePoint <= 0x1B001 || // Enclosed Ideographic Supplement
  0x1F200 <= codePoint && codePoint <= 0x1F251 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  0x20000 <= codePoint && codePoint <= 0x3FFFD)) {
    return true;
  }

  return false;
};

var isFullwidthCodePoint_1 = isFullwidthCodePoint$1;
var _default = isFullwidthCodePoint$1;
isFullwidthCodePoint_1.default = _default;

var emojiRegex$2 = function () {
  // https://mths.be/emoji
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};

const stringWidth$1 = string => {
  string = string.replace(emojiRegex$2(), '  ');

  if (typeof string !== 'string' || string.length === 0) {
    return 0;
  }

  string = stripAnsi(string);
  let width = 0;

  for (let i = 0; i < string.length; i++) {
    const code = string.codePointAt(i); // Ignore control characters

    if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {
      continue;
    } // Ignore combining characters


    if (code >= 0x300 && code <= 0x36F) {
      continue;
    } // Surrogates


    if (code > 0xFFFF) {
      i++;
    }

    width += isFullwidthCodePoint_1(code) ? 2 : 1;
  }

  return width;
};

var stringWidth_1 = stringWidth$1; // TODO: remove this in the next major version

var _default$1 = stringWidth$1;
stringWidth_1.default = _default$1;

const widestLine = input => {
  let max = 0;

  for (const line of input.split('\n')) {
    max = Math.max(max, stringWidth_1(line));
  }

  return max;
};

var widestLine_1 = widestLine; // TODO: remove this in the next major version

var _default$2 = widestLine;
widestLine_1.default = _default$2;

var measureText = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _widestLine = _interopRequireDefault(widestLine_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = text => {
  const width = (0, _widestLine.default)(text);
  const height = text.split('\n').length;
  return {
    width,
    height
  };
};

exports.default = _default;
});

var applyStyle = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _yogaLayoutPrebuilt = _interopRequireDefault(yogaLayoutPrebuilt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const applyPositionStyles = (node, style) => {
  if (!style.position) {
    node.setPositionType(NaN);
  }

  if (style.position === 'absolute') {
    node.setPositionType(_yogaLayoutPrebuilt.default.POSITION_TYPE_ABSOLUTE);
  }
};

const applyMarginStyles = (node, style) => {
  node.setMargin(_yogaLayoutPrebuilt.default.EDGE_START, style.marginLeft || style.marginX || style.margin || 0);
  node.setMargin(_yogaLayoutPrebuilt.default.EDGE_END, style.marginRight || style.marginX || style.margin || 0);
  node.setMargin(_yogaLayoutPrebuilt.default.EDGE_TOP, style.marginTop || style.marginY || style.margin || 0);
  node.setMargin(_yogaLayoutPrebuilt.default.EDGE_BOTTOM, style.marginBottom || style.marginY || style.margin || 0);
};

const applyPaddingStyles = (node, style) => {
  node.setPadding(_yogaLayoutPrebuilt.default.EDGE_LEFT, style.paddingLeft || style.paddingX || style.padding || 0);
  node.setPadding(_yogaLayoutPrebuilt.default.EDGE_RIGHT, style.paddingRight || style.paddingX || style.padding || 0);
  node.setPadding(_yogaLayoutPrebuilt.default.EDGE_TOP, style.paddingTop || style.paddingY || style.padding || 0);
  node.setPadding(_yogaLayoutPrebuilt.default.EDGE_BOTTOM, style.paddingBottom || style.paddingY || style.padding || 0);
};

const applyFlexStyles = (node, style) => {
  node.setFlexGrow(style.flexGrow || 0);
  node.setFlexShrink(typeof style.flexShrink === 'number' ? style.flexShrink : 1);

  if (style.flexDirection === 'row') {
    node.setFlexDirection(_yogaLayoutPrebuilt.default.FLEX_DIRECTION_ROW);
  }

  if (style.flexDirection === 'row-reverse') {
    node.setFlexDirection(_yogaLayoutPrebuilt.default.FLEX_DIRECTION_ROW_REVERSE);
  }

  if (style.flexDirection === 'column') {
    node.setFlexDirection(_yogaLayoutPrebuilt.default.FLEX_DIRECTION_COLUMN);
  }

  if (style.flexDirection === 'column-reverse') {
    node.setFlexDirection(_yogaLayoutPrebuilt.default.FLEX_DIRECTION_COLUMN_REVERSE);
  }

  if (typeof style.flexBasis === 'number') {
    node.setFlexBasis(style.flexBasis);
  } else if (typeof style.flexBasis === 'string') {
    node.setFlexBasisPercent(parseInt(style.flexBasis, 10));
  } else {
    // This should be replaced with node.setFlexBasisAuto() when new Yoga release is out
    node.setFlexBasis(NaN);
  }

  if (style.alignItems === 'stretch' || !style.alignItems) {
    node.setAlignItems(_yogaLayoutPrebuilt.default.ALIGN_STRETCH);
  }

  if (style.alignItems === 'flex-start') {
    node.setAlignItems(_yogaLayoutPrebuilt.default.ALIGN_FLEX_START);
  }

  if (style.alignItems === 'center') {
    node.setAlignItems(_yogaLayoutPrebuilt.default.ALIGN_CENTER);
  }

  if (style.alignItems === 'flex-end') {
    node.setAlignItems(_yogaLayoutPrebuilt.default.ALIGN_FLEX_END);
  }

  if (style.justifyContent === 'flex-start' || !style.justifyContent) {
    node.setJustifyContent(_yogaLayoutPrebuilt.default.JUSTIFY_FLEX_START);
  }

  if (style.justifyContent === 'center') {
    node.setJustifyContent(_yogaLayoutPrebuilt.default.JUSTIFY_CENTER);
  }

  if (style.justifyContent === 'flex-end') {
    node.setJustifyContent(_yogaLayoutPrebuilt.default.JUSTIFY_FLEX_END);
  }

  if (style.justifyContent === 'space-between') {
    node.setJustifyContent(_yogaLayoutPrebuilt.default.JUSTIFY_SPACE_BETWEEN);
  }

  if (style.justifyContent === 'space-around') {
    node.setJustifyContent(_yogaLayoutPrebuilt.default.JUSTIFY_SPACE_AROUND);
  }
};

const applyDimensionStyles = (node, style) => {
  if (typeof style.width === 'number') {
    node.setWidth(style.width);
  } else if (typeof style.width === 'string') {
    node.setWidthPercent(parseInt(style.width, 10));
  } else {
    node.setWidthAuto();
  }

  if (typeof style.height === 'number') {
    node.setHeight(style.height);
  } else if (typeof style.height === 'string') {
    node.setHeightPercent(parseInt(style.height, 10));
  } else {
    node.setHeightAuto();
  }

  if (typeof style.minWidth === 'string') {
    node.setMinWidthPercent(parseInt(style.minWidth, 10));
  } else {
    node.setMinWidth(style.minWidth || 0);
  }

  if (typeof style.minHeight === 'string') {
    node.setMinHeightPercent(parseInt(style.minHeight, 10));
  } else {
    node.setMinHeight(style.minHeight || 0);
  }
};

var _default = (node, style = {}) => {
  applyPositionStyles(node, style);
  applyMarginStyles(node, style);
  applyPaddingStyles(node, style);
  applyFlexStyles(node, style);
  applyDimensionStyles(node, style);
};

exports.default = _default;
});

var dom$1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setTextContent = exports.createTextNode = exports.setAttribute = exports.setStyle = exports.removeChildNode = exports.insertBeforeNode = exports.appendChildNode = exports.createNode = void 0;

var _yogaLayoutPrebuilt = _interopRequireDefault(yogaLayoutPrebuilt);

var _measureText = _interopRequireDefault(measureText);

var _applyStyle = _interopRequireDefault(applyStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Helper utilities implementing some common DOM methods to simplify reconciliation code
const createNode = tagName => ({
  nodeName: tagName.toUpperCase(),
  style: {},
  attributes: {},
  childNodes: [],
  parentNode: null,
  textContent: null,
  yogaNode: _yogaLayoutPrebuilt.default.Node.create()
});

exports.createNode = createNode;

const appendChildNode = (node, childNode) => {
  if (childNode.parentNode) {
    removeChildNode(childNode.parentNode, childNode);
  }

  childNode.parentNode = node;
  node.childNodes.push(childNode);
  node.yogaNode.insertChild(childNode.yogaNode, node.yogaNode.getChildCount());
};

exports.appendChildNode = appendChildNode;

const insertBeforeNode = (node, newChildNode, beforeChildNode) => {
  if (newChildNode.parentNode) {
    removeChildNode(newChildNode.parentNode, newChildNode);
  }

  newChildNode.parentNode = node;
  const index = node.childNodes.indexOf(beforeChildNode);

  if (index >= 0) {
    node.childNodes.splice(index, 0, newChildNode);
    node.yogaNode.insertChild(newChildNode.yogaNode, index);
    return;
  }

  node.childNodes.push(newChildNode);
  node.yogaNode.insertChild(newChildNode.yogaNode, node.yogaNode.getChildCount());
};

exports.insertBeforeNode = insertBeforeNode;

const removeChildNode = (node, removeNode) => {
  removeNode.parentNode.yogaNode.removeChild(removeNode.yogaNode);
  removeNode.parentNode = null;
  const index = node.childNodes.indexOf(removeNode);

  if (index >= 0) {
    node.childNodes.splice(index, 1);
  }
};

exports.removeChildNode = removeChildNode;

const setStyle = (node, style) => {
  node.style = style;
  (0, _applyStyle.default)(node.yogaNode, style);
};

exports.setStyle = setStyle;

const setAttribute = (node, key, value) => {
  node.attributes[key] = value;
};

exports.setAttribute = setAttribute;

const createTextNode = text => {
  const node = {
    nodeName: '#text',
    nodeValue: text,
    yogaNode: _yogaLayoutPrebuilt.default.Node.create()
  };
  setTextContent(node, text);
  return node;
};

exports.createTextNode = createTextNode;

const setTextContent = (node, text) => {
  if (typeof text !== 'string') {
    text = String(text);
  }

  let width = 0;
  let height = 0;

  if (text.length > 0) {
    const dimensions = (0, _measureText.default)(text);
    width = dimensions.width;
    height = dimensions.height;
  }

  if (node.nodeName === '#text') {
    node.nodeValue = text;
    node.yogaNode.setWidth(width);
    node.yogaNode.setHeight(height);
  } else {
    node.textContent = text;
    node.yogaNode.setWidth(node.style.width || width);
    node.yogaNode.setHeight(node.style.height || height);
  }
};

exports.setTextContent = setTextContent;
});

var reconciler$1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;



var _reactReconciler = _interopRequireDefault(reactReconciler);



function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NO_CONTEXT = true;
const hostConfig = {
  schedulePassiveEffects: scheduler.unstable_scheduleCallback,
  cancelPassiveEffects: scheduler.unstable_cancelCallback,
  now: Date.now,
  getRootHostContext: () => NO_CONTEXT,
  prepareForCommit: () => {},
  resetAfterCommit: rootNode => {
    // Since renders are throttled at the instance level and <Static> component children
    // are rendered only once and then get deleted, we need an escape hatch to
    // trigger an immediate render to ensure <Static> children are written to output before they get erased
    if (rootNode.isStaticDirty) {
      rootNode.isStaticDirty = false;
      rootNode.onImmediateRender();
      return;
    }

    rootNode.onRender();
  },
  getChildHostContext: () => NO_CONTEXT,
  shouldSetTextContent: (type, props) => {
    return typeof props.children === 'string' || typeof props.children === 'number';
  },
  createInstance: (type, newProps) => {
    const node = (0, dom$1.createNode)(type);

    for (const [key, value] of Object.entries(newProps)) {
      if (key === 'children') {
        if (typeof value === 'string' || typeof value === 'number') {
          if (type === 'div') {
            // Text node must be wrapped in another node, so that text can be aligned within container
            const textNode = (0, dom$1.createNode)('div');
            (0, dom$1.setTextContent)(textNode, value);
            (0, dom$1.appendChildNode)(node, textNode);
          }

          if (type === 'span') {
            (0, dom$1.setTextContent)(node, value);
          }
        }
      } else if (key === 'style') {
        (0, dom$1.setStyle)(node, value);
      } else if (key === 'unstable__transformChildren') {
        node.unstable__transformChildren = value; // eslint-disable-line camelcase
      } else if (key === 'unstable__static') {
        node.unstable__static = true; // eslint-disable-line camelcase
      } else {
        (0, dom$1.setAttribute)(node, key, value);
      }
    }

    return node;
  },
  createTextInstance: dom$1.createTextNode,
  resetTextContent: node => {
    if (node.textContent) {
      node.textContent = '';
    }

    if (node.childNodes.length > 0) {
      for (const childNode of node.childNodes) {
        (0, dom$1.removeChildNode)(node, childNode);
      }
    }
  },
  getPublicInstance: instance => instance,
  appendInitialChild: dom$1.appendChildNode,
  appendChild: dom$1.appendChildNode,
  insertBefore: dom$1.insertBeforeNode,
  finalizeInitialChildren: (node, type, props, rootNode) => {
    if (node.unstable__static) {
      rootNode.isStaticDirty = true;
    }
  },
  supportsMutation: true,
  appendChildToContainer: dom$1.appendChildNode,
  insertInContainerBefore: dom$1.insertBeforeNode,
  removeChildFromContainer: dom$1.removeChildNode,
  prepareUpdate: (node, type, oldProps, newProps, rootNode) => {
    if (node.unstable__static) {
      rootNode.isStaticDirty = true;
    }

    return true;
  },
  commitUpdate: (node, updatePayload, type, oldProps, newProps) => {
    for (const [key, value] of Object.entries(newProps)) {
      if (key === 'children') {
        if (typeof value === 'string' || typeof value === 'number') {
          if (type === 'div') {
            // Text node must be wrapped in another node, so that text can be aligned within container
            // If there's no such node, a new one must be created
            if (node.childNodes.length === 0) {
              const textNode = (0, dom$1.createNode)('div');
              (0, dom$1.setTextContent)(textNode, value);
              (0, dom$1.appendChildNode)(node, textNode);
            } else {
              (0, dom$1.setTextContent)(node.childNodes[0], value);
            }
          }

          if (type === 'span') {
            (0, dom$1.setTextContent)(node, value);
          }
        }
      } else if (key === 'style') {
        (0, dom$1.setStyle)(node, value);
      } else if (key === 'unstable__transformChildren') {
        node.unstable__transformChildren = value; // eslint-disable-line camelcase
      } else if (key === 'unstable__static') {
        node.unstable__static = true; // eslint-disable-line camelcase
      } else {
        (0, dom$1.setAttribute)(node, key, value);
      }
    }
  },
  commitTextUpdate: (node, oldText, newText) => {
    (0, dom$1.setTextContent)(node, newText);
  },
  removeChild: dom$1.removeChildNode
};

var _default = (0, _reactReconciler.default)(hostConfig); // eslint-disable-line new-cap


exports.default = _default;
});

const regex = '[\uD800-\uDBFF][\uDC00-\uDFFF]';

var astralRegex = opts => opts && opts.exact ? new RegExp(`^${regex}$`) : new RegExp(regex, 'g');

const stringLength = string => stripAnsi(string).replace(astralRegex(), ' ').length;

var stringLength_1 = stringLength;
// TODO: Remove this for the next major release
var _default$3 = stringLength;
stringLength_1.default = _default$3;

/* eslint-disable yoda */

const isFullwidthCodePoint$2 = codePoint => {
  if (Number.isNaN(codePoint)) {
    return false;
  } // Code points are derived from:
  // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt


  if (codePoint >= 0x1100 && (codePoint <= 0x115F || // Hangul Jamo
  codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
  codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  0x3250 <= codePoint && codePoint <= 0x4DBF || // CJK Unified Ideographs .. Yi Radicals
  0x4E00 <= codePoint && codePoint <= 0xA4C6 || // Hangul Jamo Extended-A
  0xA960 <= codePoint && codePoint <= 0xA97C || // Hangul Syllables
  0xAC00 <= codePoint && codePoint <= 0xD7A3 || // CJK Compatibility Ideographs
  0xF900 <= codePoint && codePoint <= 0xFAFF || // Vertical Forms
  0xFE10 <= codePoint && codePoint <= 0xFE19 || // CJK Compatibility Forms .. Small Form Variants
  0xFE30 <= codePoint && codePoint <= 0xFE6B || // Halfwidth and Fullwidth Forms
  0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || // Kana Supplement
  0x1B000 <= codePoint && codePoint <= 0x1B001 || // Enclosed Ideographic Supplement
  0x1F200 <= codePoint && codePoint <= 0x1F251 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  0x20000 <= codePoint && codePoint <= 0x3FFFD)) {
    return true;
  }

  return false;
};

var isFullwidthCodePoint_1$1 = isFullwidthCodePoint$2;
var _default$4 = isFullwidthCodePoint$2;
isFullwidthCodePoint_1$1.default = _default$4;

const regex$1 = '[\uD800-\uDBFF][\uDC00-\uDFFF]';

const astralRegex$1 = options => options && options.exact ? new RegExp(`^${regex$1}$`) : new RegExp(regex$1, 'g');

var astralRegex_1 = astralRegex$1;

var colorName$1 = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};

/* MIT license */

/* eslint-disable no-mixed-operators */
 // NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)


const reverseKeywords = {};

for (const key of Object.keys(colorName$1)) {
  reverseKeywords[colorName$1[key]] = key;
}

const convert$1 = {
  rgb: {
    channels: 3,
    labels: 'rgb'
  },
  hsl: {
    channels: 3,
    labels: 'hsl'
  },
  hsv: {
    channels: 3,
    labels: 'hsv'
  },
  hwb: {
    channels: 3,
    labels: 'hwb'
  },
  cmyk: {
    channels: 4,
    labels: 'cmyk'
  },
  xyz: {
    channels: 3,
    labels: 'xyz'
  },
  lab: {
    channels: 3,
    labels: 'lab'
  },
  lch: {
    channels: 3,
    labels: 'lch'
  },
  hex: {
    channels: 1,
    labels: ['hex']
  },
  keyword: {
    channels: 1,
    labels: ['keyword']
  },
  ansi16: {
    channels: 1,
    labels: ['ansi16']
  },
  ansi256: {
    channels: 1,
    labels: ['ansi256']
  },
  hcg: {
    channels: 3,
    labels: ['h', 'c', 'g']
  },
  apple: {
    channels: 3,
    labels: ['r16', 'g16', 'b16']
  },
  gray: {
    channels: 1,
    labels: ['gray']
  }
};
var conversions$1 = convert$1; // Hide .channels and .labels properties

for (const model of Object.keys(convert$1)) {
  if (!('channels' in convert$1[model])) {
    throw new Error('missing channels property: ' + model);
  }

  if (!('labels' in convert$1[model])) {
    throw new Error('missing channel labels property: ' + model);
  }

  if (convert$1[model].labels.length !== convert$1[model].channels) {
    throw new Error('channel and label counts mismatch: ' + model);
  }

  const {
    channels,
    labels
  } = convert$1[model];
  delete convert$1[model].channels;
  delete convert$1[model].labels;
  Object.defineProperty(convert$1[model], 'channels', {
    value: channels
  });
  Object.defineProperty(convert$1[model], 'labels', {
    value: labels
  });
}

convert$1.rgb.hsl = function (rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const min = Math.min(r, g, b);
  const max = Math.max(r, g, b);
  const delta = max - min;
  let h;
  let s;

  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }

  h = Math.min(h * 60, 360);

  if (h < 0) {
    h += 360;
  }

  const l = (min + max) / 2;

  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }

  return [h, s * 100, l * 100];
};

convert$1.rgb.hsv = function (rgb) {
  let rdif;
  let gdif;
  let bdif;
  let h;
  let s;
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const v = Math.max(r, g, b);
  const diff = v - Math.min(r, g, b);

  const diffc = function (c) {
    return (v - c) / 6 / diff + 1 / 2;
  };

  if (diff === 0) {
    h = 0;
    s = 0;
  } else {
    s = diff / v;
    rdif = diffc(r);
    gdif = diffc(g);
    bdif = diffc(b);

    if (r === v) {
      h = bdif - gdif;
    } else if (g === v) {
      h = 1 / 3 + rdif - bdif;
    } else if (b === v) {
      h = 2 / 3 + gdif - rdif;
    }

    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }

  return [h * 360, s * 100, v * 100];
};

convert$1.rgb.hwb = function (rgb) {
  const r = rgb[0];
  const g = rgb[1];
  let b = rgb[2];
  const h = convert$1.rgb.hsl(rgb)[0];
  const w = 1 / 255 * Math.min(r, Math.min(g, b));
  b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
  return [h, w * 100, b * 100];
};

convert$1.rgb.cmyk = function (rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const k = Math.min(1 - r, 1 - g, 1 - b);
  const c = (1 - r - k) / (1 - k) || 0;
  const m = (1 - g - k) / (1 - k) || 0;
  const y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
  /*
  	See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
  */
  return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
}

convert$1.rgb.keyword = function (rgb) {
  const reversed = reverseKeywords[rgb];

  if (reversed) {
    return reversed;
  }

  let currentClosestDistance = Infinity;
  let currentClosestKeyword;

  for (const keyword of Object.keys(colorName$1)) {
    const value = colorName$1[keyword]; // Compute comparative distance

    const distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest

    if (distance < currentClosestDistance) {
      currentClosestDistance = distance;
      currentClosestKeyword = keyword;
    }
  }

  return currentClosestKeyword;
};

convert$1.keyword.rgb = function (keyword) {
  return colorName$1[keyword];
};

convert$1.rgb.xyz = function (rgb) {
  let r = rgb[0] / 255;
  let g = rgb[1] / 255;
  let b = rgb[2] / 255; // Assume sRGB

  r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
  g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
  b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
  const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
  const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x * 100, y * 100, z * 100];
};

convert$1.rgb.lab = function (rgb) {
  const xyz = convert$1.rgb.xyz(rgb);
  let x = xyz[0];
  let y = xyz[1];
  let z = xyz[2];
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
  const l = 116 * y - 16;
  const a = 500 * (x - y);
  const b = 200 * (y - z);
  return [l, a, b];
};

convert$1.hsl.rgb = function (hsl) {
  const h = hsl[0] / 360;
  const s = hsl[1] / 100;
  const l = hsl[2] / 100;
  let t2;
  let t3;
  let val;

  if (s === 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }

  const t1 = 2 * l - t2;
  const rgb = [0, 0, 0];

  for (let i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1);

    if (t3 < 0) {
      t3++;
    }

    if (t3 > 1) {
      t3--;
    }

    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }

    rgb[i] = val * 255;
  }

  return rgb;
};

convert$1.hsl.hsv = function (hsl) {
  const h = hsl[0];
  let s = hsl[1] / 100;
  let l = hsl[2] / 100;
  let smin = s;
  const lmin = Math.max(l, 0.01);
  l *= 2;
  s *= l <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  const v = (l + s) / 2;
  const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
  return [h, sv * 100, v * 100];
};

convert$1.hsv.rgb = function (hsv) {
  const h = hsv[0] / 60;
  const s = hsv[1] / 100;
  let v = hsv[2] / 100;
  const hi = Math.floor(h) % 6;
  const f = h - Math.floor(h);
  const p = 255 * v * (1 - s);
  const q = 255 * v * (1 - s * f);
  const t = 255 * v * (1 - s * (1 - f));
  v *= 255;

  switch (hi) {
    case 0:
      return [v, t, p];

    case 1:
      return [q, v, p];

    case 2:
      return [p, v, t];

    case 3:
      return [p, q, v];

    case 4:
      return [t, p, v];

    case 5:
      return [v, p, q];
  }
};

convert$1.hsv.hsl = function (hsv) {
  const h = hsv[0];
  const s = hsv[1] / 100;
  const v = hsv[2] / 100;
  const vmin = Math.max(v, 0.01);
  let sl;
  let l;
  l = (2 - s) * v;
  const lmin = (2 - s) * vmin;
  sl = s * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


convert$1.hwb.rgb = function (hwb) {
  const h = hwb[0] / 360;
  let wh = hwb[1] / 100;
  let bl = hwb[2] / 100;
  const ratio = wh + bl;
  let f; // Wh + bl cant be > 1

  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  const i = Math.floor(6 * h);
  const v = 1 - bl;
  f = 6 * h - i;

  if ((i & 0x01) !== 0) {
    f = 1 - f;
  }

  const n = wh + f * (v - wh); // Linear interpolation

  let r;
  let g;
  let b;
  /* eslint-disable max-statements-per-line,no-multi-spaces */

  switch (i) {
    default:
    case 6:
    case 0:
      r = v;
      g = n;
      b = wh;
      break;

    case 1:
      r = n;
      g = v;
      b = wh;
      break;

    case 2:
      r = wh;
      g = v;
      b = n;
      break;

    case 3:
      r = wh;
      g = n;
      b = v;
      break;

    case 4:
      r = n;
      g = wh;
      b = v;
      break;

    case 5:
      r = v;
      g = wh;
      b = n;
      break;
  }
  /* eslint-enable max-statements-per-line,no-multi-spaces */


  return [r * 255, g * 255, b * 255];
};

convert$1.cmyk.rgb = function (cmyk) {
  const c = cmyk[0] / 100;
  const m = cmyk[1] / 100;
  const y = cmyk[2] / 100;
  const k = cmyk[3] / 100;
  const r = 1 - Math.min(1, c * (1 - k) + k);
  const g = 1 - Math.min(1, m * (1 - k) + k);
  const b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
};

convert$1.xyz.rgb = function (xyz) {
  const x = xyz[0] / 100;
  const y = xyz[1] / 100;
  const z = xyz[2] / 100;
  let r;
  let g;
  let b;
  r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  b = x * 0.0557 + y * -0.2040 + z * 1.0570; // Assume sRGB

  r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
  g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
  b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
};

convert$1.xyz.lab = function (xyz) {
  let x = xyz[0];
  let y = xyz[1];
  let z = xyz[2];
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
  const l = 116 * y - 16;
  const a = 500 * (x - y);
  const b = 200 * (y - z);
  return [l, a, b];
};

convert$1.lab.xyz = function (lab) {
  const l = lab[0];
  const a = lab[1];
  const b = lab[2];
  let x;
  let y;
  let z;
  y = (l + 16) / 116;
  x = a / 500 + y;
  z = y - b / 200;
  const y2 = y ** 3;
  const x2 = x ** 3;
  const z2 = z ** 3;
  y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
  z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
  x *= 95.047;
  y *= 100;
  z *= 108.883;
  return [x, y, z];
};

convert$1.lab.lch = function (lab) {
  const l = lab[0];
  const a = lab[1];
  const b = lab[2];
  let h;
  const hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;

  if (h < 0) {
    h += 360;
  }

  const c = Math.sqrt(a * a + b * b);
  return [l, c, h];
};

convert$1.lch.lab = function (lch) {
  const l = lch[0];
  const c = lch[1];
  const h = lch[2];
  const hr = h / 360 * 2 * Math.PI;
  const a = c * Math.cos(hr);
  const b = c * Math.sin(hr);
  return [l, a, b];
};

convert$1.rgb.ansi16 = function (args, saturation = null) {
  const [r, g, b] = args;
  let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

  value = Math.round(value / 50);

  if (value === 0) {
    return 30;
  }

  let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

  if (value === 2) {
    ansi += 60;
  }

  return ansi;
};

convert$1.hsv.ansi16 = function (args) {
  // Optimization here; we already know the value and don't need to get
  // it converted for us.
  return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
};

convert$1.rgb.ansi256 = function (args) {
  const r = args[0];
  const g = args[1];
  const b = args[2]; // We use the extended greyscale palette here, with the exception of
  // black and white. normal palette only has 4 greyscale shades.

  if (r === g && g === b) {
    if (r < 8) {
      return 16;
    }

    if (r > 248) {
      return 231;
    }

    return Math.round((r - 8) / 247 * 24) + 232;
  }

  const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
};

convert$1.ansi16.rgb = function (args) {
  let color = args % 10; // Handle greyscale

  if (color === 0 || color === 7) {
    if (args > 50) {
      color += 3.5;
    }

    color = color / 10.5 * 255;
    return [color, color, color];
  }

  const mult = (~~(args > 50) + 1) * 0.5;
  const r = (color & 1) * mult * 255;
  const g = (color >> 1 & 1) * mult * 255;
  const b = (color >> 2 & 1) * mult * 255;
  return [r, g, b];
};

convert$1.ansi256.rgb = function (args) {
  // Handle greyscale
  if (args >= 232) {
    const c = (args - 232) * 10 + 8;
    return [c, c, c];
  }

  args -= 16;
  let rem;
  const r = Math.floor(args / 36) / 5 * 255;
  const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
  const b = rem % 6 / 5 * 255;
  return [r, g, b];
};

convert$1.rgb.hex = function (args) {
  const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
  const string = integer.toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};

convert$1.hex.rgb = function (args) {
  const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

  if (!match) {
    return [0, 0, 0];
  }

  let colorString = match[0];

  if (match[0].length === 3) {
    colorString = colorString.split('').map(char => {
      return char + char;
    }).join('');
  }

  const integer = parseInt(colorString, 16);
  const r = integer >> 16 & 0xFF;
  const g = integer >> 8 & 0xFF;
  const b = integer & 0xFF;
  return [r, g, b];
};

convert$1.rgb.hcg = function (rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const max = Math.max(Math.max(r, g), b);
  const min = Math.min(Math.min(r, g), b);
  const chroma = max - min;
  let grayscale;
  let hue;

  if (chroma < 1) {
    grayscale = min / (1 - chroma);
  } else {
    grayscale = 0;
  }

  if (chroma <= 0) {
    hue = 0;
  } else if (max === r) {
    hue = (g - b) / chroma % 6;
  } else if (max === g) {
    hue = 2 + (b - r) / chroma;
  } else {
    hue = 4 + (r - g) / chroma;
  }

  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};

convert$1.hsl.hcg = function (hsl) {
  const s = hsl[1] / 100;
  const l = hsl[2] / 100;
  const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
  let f = 0;

  if (c < 1.0) {
    f = (l - 0.5 * c) / (1.0 - c);
  }

  return [hsl[0], c * 100, f * 100];
};

convert$1.hsv.hcg = function (hsv) {
  const s = hsv[1] / 100;
  const v = hsv[2] / 100;
  const c = s * v;
  let f = 0;

  if (c < 1.0) {
    f = (v - c) / (1 - c);
  }

  return [hsv[0], c * 100, f * 100];
};

convert$1.hcg.rgb = function (hcg) {
  const h = hcg[0] / 360;
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;

  if (c === 0.0) {
    return [g * 255, g * 255, g * 255];
  }

  const pure = [0, 0, 0];
  const hi = h % 1 * 6;
  const v = hi % 1;
  const w = 1 - v;
  let mg = 0;
  /* eslint-disable max-statements-per-line */

  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1;
      pure[1] = v;
      pure[2] = 0;
      break;

    case 1:
      pure[0] = w;
      pure[1] = 1;
      pure[2] = 0;
      break;

    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v;
      break;

    case 3:
      pure[0] = 0;
      pure[1] = w;
      pure[2] = 1;
      break;

    case 4:
      pure[0] = v;
      pure[1] = 0;
      pure[2] = 1;
      break;

    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w;
  }
  /* eslint-enable max-statements-per-line */


  mg = (1.0 - c) * g;
  return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
};

convert$1.hcg.hsv = function (hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const v = c + g * (1.0 - c);
  let f = 0;

  if (v > 0.0) {
    f = c / v;
  }

  return [hcg[0], f * 100, v * 100];
};

convert$1.hcg.hsl = function (hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const l = g * (1.0 - c) + 0.5 * c;
  let s = 0;

  if (l > 0.0 && l < 0.5) {
    s = c / (2 * l);
  } else if (l >= 0.5 && l < 1.0) {
    s = c / (2 * (1 - l));
  }

  return [hcg[0], s * 100, l * 100];
};

convert$1.hcg.hwb = function (hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const v = c + g * (1.0 - c);
  return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert$1.hwb.hcg = function (hwb) {
  const w = hwb[1] / 100;
  const b = hwb[2] / 100;
  const v = 1 - b;
  const c = v - w;
  let g = 0;

  if (c < 1) {
    g = (v - c) / (1 - c);
  }

  return [hwb[0], c * 100, g * 100];
};

convert$1.apple.rgb = function (apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};

convert$1.rgb.apple = function (rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};

convert$1.gray.rgb = function (args) {
  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert$1.gray.hsl = function (args) {
  return [0, 0, args[0]];
};

convert$1.gray.hsv = convert$1.gray.hsl;

convert$1.gray.hwb = function (gray) {
  return [0, 100, gray[0]];
};

convert$1.gray.cmyk = function (gray) {
  return [0, 0, 0, gray[0]];
};

convert$1.gray.lab = function (gray) {
  return [gray[0], 0, 0];
};

convert$1.gray.hex = function (gray) {
  const val = Math.round(gray[0] / 100 * 255) & 0xFF;
  const integer = (val << 16) + (val << 8) + val;
  const string = integer.toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};

convert$1.rgb.gray = function (rgb) {
  const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [val / 255 * 100];
};

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/


function buildGraph$1() {
  const graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3

  const models = Object.keys(conversions$1);

  for (let len = models.length, i = 0; i < len; i++) {
    graph[models[i]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  }

  return graph;
} // https://en.wikipedia.org/wiki/Breadth-first_search


function deriveBFS$1(fromModel) {
  const graph = buildGraph$1();
  const queue = [fromModel]; // Unshift -> queue -> pop

  graph[fromModel].distance = 0;

  while (queue.length) {
    const current = queue.pop();
    const adjacents = Object.keys(conversions$1[current]);

    for (let len = adjacents.length, i = 0; i < len; i++) {
      const adjacent = adjacents[i];
      const node = graph[adjacent];

      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }

  return graph;
}

function link$1(from, to) {
  return function (args) {
    return to(from(args));
  };
}

function wrapConversion$1(toModel, graph) {
  const path = [graph[toModel].parent, toModel];
  let fn = conversions$1[graph[toModel].parent][toModel];
  let cur = graph[toModel].parent;

  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link$1(conversions$1[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }

  fn.conversion = path;
  return fn;
}

var route$1 = function (fromModel) {
  const graph = deriveBFS$1(fromModel);
  const conversion = {};
  const models = Object.keys(graph);

  for (let len = models.length, i = 0; i < len; i++) {
    const toModel = models[i];
    const node = graph[toModel];

    if (node.parent === null) {
      // No possible conversion, or this node is the source model.
      continue;
    }

    conversion[toModel] = wrapConversion$1(toModel, graph);
  }

  return conversion;
};

const convert$2 = {};
const models$1 = Object.keys(conversions$1);

function wrapRaw$1(fn) {
  const wrappedFn = function (...args) {
    const arg0 = args[0];

    if (arg0 === undefined || arg0 === null) {
      return arg0;
    }

    if (arg0.length > 1) {
      args = arg0;
    }

    return fn(args);
  }; // Preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

function wrapRounded$1(fn) {
  const wrappedFn = function (...args) {
    const arg0 = args[0];

    if (arg0 === undefined || arg0 === null) {
      return arg0;
    }

    if (arg0.length > 1) {
      args = arg0;
    }

    const result = fn(args); // We're assuming the result is an array here.
    // see notice in conversions.js; don't use box types
    // in conversion functions.

    if (typeof result === 'object') {
      for (let len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }

    return result;
  }; // Preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

models$1.forEach(fromModel => {
  convert$2[fromModel] = {};
  Object.defineProperty(convert$2[fromModel], 'channels', {
    value: conversions$1[fromModel].channels
  });
  Object.defineProperty(convert$2[fromModel], 'labels', {
    value: conversions$1[fromModel].labels
  });
  const routes = route$1(fromModel);
  const routeModels = Object.keys(routes);
  routeModels.forEach(toModel => {
    const fn = routes[toModel];
    convert$2[fromModel][toModel] = wrapRounded$1(fn);
    convert$2[fromModel][toModel].raw = wrapRaw$1(fn);
  });
});
var colorConvert$1 = convert$2;

var ansiStyles$1 = createCommonjsModule(function (module) {

const wrapAnsi16 = (fn, offset) => (...args) => {
  const code = fn(...args);
  return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
  const code = fn(...args);
  return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
  const rgb = fn(...args);
  return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;

const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
  Object.defineProperty(object, property, {
    get: () => {
      const value = get();
      Object.defineProperty(object, property, {
        value,
        enumerable: true,
        configurable: true
      });
      return value;
    },
    enumerable: true,
    configurable: true
  });
};
/** @type {typeof import('color-convert')} */


let colorConvert;

const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
  if (colorConvert === undefined) {
    colorConvert = colorConvert$1;
  }

  const offset = isBackground ? 10 : 0;
  const styles = {};

  for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
    const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;

    if (sourceSpace === targetSpace) {
      styles[name] = wrap(identity, offset);
    } else if (typeof suite === 'object') {
      styles[name] = wrap(suite[targetSpace], offset);
    }
  }

  return styles;
};

function assembleStyles() {
  const codes = new Map();
  const styles = {
    modifier: {
      reset: [0, 0],
      // 21 isn't widely supported and 22 does the same thing
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      // Bright color
      blackBright: [90, 39],
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      // Bright color
      bgBlackBright: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  }; // Alias bright black as gray (and grey)

  styles.color.gray = styles.color.blackBright;
  styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
  styles.color.grey = styles.color.blackBright;
  styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\u001B[${style[0]}m`,
        close: `\u001B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }

    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }

  Object.defineProperty(styles, 'codes', {
    value: codes,
    enumerable: false
  });
  styles.color.close = '\u001B[39m';
  styles.bgColor.close = '\u001B[49m';
  setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
  setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
  setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
  setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
  setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
  setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));
  return styles;
} // Make the export immutable


Object.defineProperty(module, 'exports', {
  enumerable: true,
  get: assembleStyles
});
});

const ESCAPES$1 = ['\u001B', '\u009B'];

const wrapAnsi$1 = code => `${ESCAPES$1[0]}[${code}m`;

const checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {
  let output = [];
  ansiCodes = [...ansiCodes];

  for (let ansiCode of ansiCodes) {
    const ansiCodeOrigin = ansiCode;

    if (ansiCode.match(';')) {
      ansiCode = ansiCode.split(';')[0][0] + '0';
    }

    const item = ansiStyles$1.codes.get(parseInt(ansiCode, 10));

    if (item) {
      const indexEscape = ansiCodes.indexOf(item.toString());

      if (indexEscape >= 0) {
        ansiCodes.splice(indexEscape, 1);
      } else {
        output.push(wrapAnsi$1(isEscapes ? item : ansiCodeOrigin));
      }
    } else if (isEscapes) {
      output.push(wrapAnsi$1(0));
      break;
    } else {
      output.push(wrapAnsi$1(ansiCodeOrigin));
    }
  }

  if (isEscapes) {
    output = output.filter((element, index) => output.indexOf(element) === index);

    if (endAnsiCode !== undefined) {
      const fistEscapeCode = wrapAnsi$1(ansiStyles$1.codes.get(parseInt(endAnsiCode, 10)));
      output = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);
    }
  }

  return output.join('');
};

var sliceAnsi = (string, begin, end) => {
  const characters = [...string.normalize()];
  const ansiCodes = [];
  end = typeof end === 'number' ? end : characters.length;
  let isInsideEscape = false;
  let ansiCode;
  let visible = 0;
  let output = '';

  for (const [index, character] of characters.entries()) {
    let leftEscape = false;

    if (ESCAPES$1.includes(character)) {
      const code = /\d[^m]*/.exec(string.slice(index, index + 18));
      ansiCode = code && code.length > 0 ? code[0] : undefined;

      if (visible < end) {
        isInsideEscape = true;

        if (ansiCode !== undefined) {
          ansiCodes.push(ansiCode);
        }
      }
    } else if (isInsideEscape && character === 'm') {
      isInsideEscape = false;
      leftEscape = true;
    }

    if (!isInsideEscape && !leftEscape) {
      ++visible;
    }

    if (!astralRegex_1({
      exact: true
    }).test(character) && isFullwidthCodePoint_1$1(character.codePointAt())) {
      ++visible;
    }

    if (visible > begin && visible <= end) {
      output += character;
    } else if (visible === begin && !isInsideEscape && ansiCode !== undefined) {
      output = checkAnsi(ansiCodes);
    } else if (visible >= end) {
      output += checkAnsi(ansiCodes, true, ansiCode);
      break;
    }
  }

  return output;
};

var output = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _stringLength = _interopRequireDefault(stringLength_1);

var _sliceAnsi = _interopRequireDefault(sliceAnsi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * "Virtual" output class
 *
 * Handles the positioning and saving of the output of each node in the tree.
 * Also responsible for applying transformations to each character of the output.
 *
 * Used to generate the final output of all nodes before writing it to actual output stream (e.g. stdout)
 */
class Output {
  constructor({
    width,
    height
  }) {
    // Initialize output array with a specific set of rows, so that margin/padding at the bottom is preserved
    const output = [];

    for (let y = 0; y < height; y++) {
      output.push(' '.repeat(width));
    }

    this.output = output;
  }

  write(x, y, text, {
    transformers
  }) {
    if (!text) {
      return;
    }

    const lines = text.split('\n');
    let offsetY = 0;

    for (let line of lines) {
      const length = (0, _stringLength.default)(line);
      const currentLine = this.output[y + offsetY]; // Line can be missing if `text` is taller than height of pre-initialized `this.output`

      if (!currentLine) {
        continue;
      }

      for (const transformer of transformers) {
        line = transformer(line);
      }

      this.output[y + offsetY] = (0, _sliceAnsi.default)(currentLine, 0, x) + line + (0, _sliceAnsi.default)(currentLine, x + length);
      offsetY++;
    }
  }

  get() {
    return this.output.map(line => line.trimRight()).join('\n');
  }

  getHeight() {
    return this.output.length;
  }

}

exports.default = Output;
});

var applyStyles = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _yogaLayoutPrebuilt = _interopRequireDefault(yogaLayoutPrebuilt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const applyMarginStyles = (node, style) => {
  if (style.margin) {
    node.setMargin(_yogaLayoutPrebuilt.default.EDGE_TOP, style.margin);
    node.setMargin(_yogaLayoutPrebuilt.default.EDGE_BOTTOM, style.margin);
    node.setMargin(_yogaLayoutPrebuilt.default.EDGE_START, style.margin);
    node.setMargin(_yogaLayoutPrebuilt.default.EDGE_END, style.margin);
  }

  if (style.marginX) {
    node.setMargin(_yogaLayoutPrebuilt.default.EDGE_START, style.marginX);
    node.setMargin(_yogaLayoutPrebuilt.default.EDGE_END, style.marginX);
  }

  if (style.marginY) {
    node.setMargin(_yogaLayoutPrebuilt.default.EDGE_TOP, style.marginY);
    node.setMargin(_yogaLayoutPrebuilt.default.EDGE_BOTTOM, style.marginY);
  }

  if (style.marginTop) {
    node.setMargin(_yogaLayoutPrebuilt.default.EDGE_TOP, style.marginTop);
  }

  if (style.marginBottom) {
    node.setMargin(_yogaLayoutPrebuilt.default.EDGE_BOTTOM, style.marginBottom);
  }

  if (style.marginLeft) {
    node.setMargin(_yogaLayoutPrebuilt.default.EDGE_START, style.marginLeft);
  }

  if (style.marginRight) {
    node.setMargin(_yogaLayoutPrebuilt.default.EDGE_END, style.marginRight);
  }
};

const applyPaddingStyles = (node, style) => {
  if (style.padding) {
    node.setPadding(_yogaLayoutPrebuilt.default.EDGE_TOP, style.padding);
    node.setPadding(_yogaLayoutPrebuilt.default.EDGE_BOTTOM, style.padding);
    node.setPadding(_yogaLayoutPrebuilt.default.EDGE_LEFT, style.padding);
    node.setPadding(_yogaLayoutPrebuilt.default.EDGE_RIGHT, style.padding);
  }

  if (style.paddingX) {
    node.setPadding(_yogaLayoutPrebuilt.default.EDGE_LEFT, style.paddingX);
    node.setPadding(_yogaLayoutPrebuilt.default.EDGE_RIGHT, style.paddingX);
  }

  if (style.paddingY) {
    node.setPadding(_yogaLayoutPrebuilt.default.EDGE_TOP, style.paddingY);
    node.setPadding(_yogaLayoutPrebuilt.default.EDGE_BOTTOM, style.paddingY);
  }

  if (style.paddingTop) {
    node.setPadding(_yogaLayoutPrebuilt.default.EDGE_TOP, style.paddingTop);
  }

  if (style.paddingBottom) {
    node.setPadding(_yogaLayoutPrebuilt.default.EDGE_BOTTOM, style.paddingBottom);
  }

  if (style.paddingLeft) {
    node.setPadding(_yogaLayoutPrebuilt.default.EDGE_LEFT, style.paddingLeft);
  }

  if (style.paddingRight) {
    node.setPadding(_yogaLayoutPrebuilt.default.EDGE_RIGHT, style.paddingRight);
  }
};

const applyFlexStyles = (node, style) => {
  if (style.flexGrow) {
    node.setFlexGrow(style.flexGrow);
  }

  if (style.flexShrink) {
    node.setFlexShrink(style.flexShrink);
  }

  if (style.flexDirection) {
    if (style.flexDirection === 'row') {
      node.setFlexDirection(_yogaLayoutPrebuilt.default.FLEX_DIRECTION_ROW);
    }

    if (style.flexDirection === 'row-reverse') {
      node.setFlexDirection(_yogaLayoutPrebuilt.default.FLEX_DIRECTION_ROW_REVERSE);
    }

    if (style.flexDirection === 'column') {
      node.setFlexDirection(_yogaLayoutPrebuilt.default.FLEX_DIRECTION_COLUMN);
    }

    if (style.flexDirection === 'column-reverse') {
      node.setFlexDirection(_yogaLayoutPrebuilt.default.FLEX_DIRECTION_COLUMN_REVERSE);
    }
  }

  if (style.flexBasis !== undefined) {
    node.setFlexBasis(style.flexBasis);
  }

  if (style.alignItems) {
    if (style.alignItems === 'flex-start') {
      node.setAlignItems(_yogaLayoutPrebuilt.default.ALIGN_FLEX_START);
    }

    if (style.alignItems === 'center') {
      node.setAlignItems(_yogaLayoutPrebuilt.default.ALIGN_CENTER);
    }

    if (style.alignItems === 'flex-end') {
      node.setAlignItems(_yogaLayoutPrebuilt.default.ALIGN_FLEX_END);
    }
  }

  if (style.justifyContent) {
    if (style.justifyContent === 'flex-start') {
      node.setJustifyContent(_yogaLayoutPrebuilt.default.JUSTIFY_FLEX_START);
    }

    if (style.justifyContent === 'center') {
      node.setJustifyContent(_yogaLayoutPrebuilt.default.JUSTIFY_CENTER);
    }

    if (style.justifyContent === 'flex-end') {
      node.setJustifyContent(_yogaLayoutPrebuilt.default.JUSTIFY_FLEX_END);
    }

    if (style.justifyContent === 'space-between') {
      node.setJustifyContent(_yogaLayoutPrebuilt.default.JUSTIFY_SPACE_BETWEEN);
    }

    if (style.justifyContent === 'space-around') {
      node.setJustifyContent(_yogaLayoutPrebuilt.default.JUSTIFY_SPACE_AROUND);
    }
  }
};

const applyDimensionStyles = (node, style) => {
  if (style.width !== undefined) {
    node.setWidth(style.width);
  }

  if (style.height !== undefined) {
    node.setHeight(style.height);
  }

  if (style.minWidth !== undefined) {
    node.setMinWidth(style.minWidth);
  }

  if (style.minHeight !== undefined) {
    node.setMinHeight(style.minHeight);
  }
};

var _default = (node, style = {}) => {
  applyMarginStyles(node, style);
  applyPaddingStyles(node, style);
  applyFlexStyles(node, style);
  applyDimensionStyles(node, style);
};

exports.default = _default;
});

var buildLayout_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _yogaLayoutPrebuilt = _interopRequireDefault(yogaLayoutPrebuilt);

var _applyStyles = _interopRequireDefault(applyStyles);

var _measureText = _interopRequireDefault(measureText);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Traverse the node tree, create Yoga nodes and assign styles to each Yoga node
const buildLayout = (node, options) => {
  const {
    config,
    terminalWidth,
    skipStaticElements
  } = options;

  const yogaNode = _yogaLayoutPrebuilt.default.Node.create(config);

  node.yogaNode = yogaNode;
  const style = node.style || {}; // Root node of the tree

  if (node.nodeName === 'ROOT') {
    // `terminalWidth` can be `undefined` if env isn't a TTY
    yogaNode.setWidth(terminalWidth || 100);

    if (node.childNodes.length > 0) {
      const childNodes = node.childNodes.filter(childNode => {
        return skipStaticElements ? !childNode.unstable__static : true;
      });

      for (const [index, childNode] of Object.entries(childNodes)) {
        const childYogaNode = buildLayout(childNode, options).yogaNode;
        yogaNode.insertChild(childYogaNode, index);
      }
    }

    return node;
  } // Apply margin, padding, flex, etc styles


  (0, _applyStyles.default)(yogaNode, style); // Nodes with only text have a child Yoga node dedicated for that text

  if (node.textContent || node.nodeValue) {
    const {
      width,
      height
    } = (0, _measureText.default)(node.textContent || node.nodeValue);
    yogaNode.setWidth(style.width || width);
    yogaNode.setHeight(style.height || height);
    return node;
  }

  if (Array.isArray(node.childNodes) && node.childNodes.length > 0) {
    const childNodes = node.childNodes.filter(childNode => {
      return skipStaticElements ? !childNode.unstable__static : true;
    });

    for (const [index, childNode] of Object.entries(childNodes)) {
      const {
        yogaNode: childYogaNode
      } = buildLayout(childNode, options);
      yogaNode.insertChild(childYogaNode, index);
    }
  }

  return node;
};

var _default = buildLayout;
exports.default = _default;
});

/* eslint-disable yoda */

const isFullwidthCodePoint$3 = codePoint => {
  if (Number.isNaN(codePoint)) {
    return false;
  } // Code points are derived from:
  // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt


  if (codePoint >= 0x1100 && (codePoint <= 0x115F || // Hangul Jamo
  codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
  codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  0x3250 <= codePoint && codePoint <= 0x4DBF || // CJK Unified Ideographs .. Yi Radicals
  0x4E00 <= codePoint && codePoint <= 0xA4C6 || // Hangul Jamo Extended-A
  0xA960 <= codePoint && codePoint <= 0xA97C || // Hangul Syllables
  0xAC00 <= codePoint && codePoint <= 0xD7A3 || // CJK Compatibility Ideographs
  0xF900 <= codePoint && codePoint <= 0xFAFF || // Vertical Forms
  0xFE10 <= codePoint && codePoint <= 0xFE19 || // CJK Compatibility Forms .. Small Form Variants
  0xFE30 <= codePoint && codePoint <= 0xFE6B || // Halfwidth and Fullwidth Forms
  0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || // Kana Supplement
  0x1B000 <= codePoint && codePoint <= 0x1B001 || // Enclosed Ideographic Supplement
  0x1F200 <= codePoint && codePoint <= 0x1F251 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  0x20000 <= codePoint && codePoint <= 0x3FFFD)) {
    return true;
  }

  return false;
};

var isFullwidthCodePoint_1$2 = isFullwidthCodePoint$3;
var _default$5 = isFullwidthCodePoint$3;
isFullwidthCodePoint_1$2.default = _default$5;

var emojiRegex$3 = function () {
  // https://mths.be/emoji
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};

const stringWidth$2 = string => {
  string = string.replace(emojiRegex$3(), '  ');

  if (typeof string !== 'string' || string.length === 0) {
    return 0;
  }

  string = stripAnsi(string);
  let width = 0;

  for (let i = 0; i < string.length; i++) {
    const code = string.codePointAt(i); // Ignore control characters

    if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {
      continue;
    } // Ignore combining characters


    if (code >= 0x300 && code <= 0x36F) {
      continue;
    } // Surrogates


    if (code > 0xFFFF) {
      i++;
    }

    width += isFullwidthCodePoint_1$2(code) ? 2 : 1;
  }

  return width;
};

var stringWidth_1$1 = stringWidth$2; // TODO: remove this in the next major version

var _default$6 = stringWidth$2;
stringWidth_1$1.default = _default$6;

/* MIT license */

/* eslint-disable no-mixed-operators */
 // NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)


const reverseKeywords$1 = {};

for (const key of Object.keys(colorName$1)) {
  reverseKeywords$1[colorName$1[key]] = key;
}

const convert$3 = {
  rgb: {
    channels: 3,
    labels: 'rgb'
  },
  hsl: {
    channels: 3,
    labels: 'hsl'
  },
  hsv: {
    channels: 3,
    labels: 'hsv'
  },
  hwb: {
    channels: 3,
    labels: 'hwb'
  },
  cmyk: {
    channels: 4,
    labels: 'cmyk'
  },
  xyz: {
    channels: 3,
    labels: 'xyz'
  },
  lab: {
    channels: 3,
    labels: 'lab'
  },
  lch: {
    channels: 3,
    labels: 'lch'
  },
  hex: {
    channels: 1,
    labels: ['hex']
  },
  keyword: {
    channels: 1,
    labels: ['keyword']
  },
  ansi16: {
    channels: 1,
    labels: ['ansi16']
  },
  ansi256: {
    channels: 1,
    labels: ['ansi256']
  },
  hcg: {
    channels: 3,
    labels: ['h', 'c', 'g']
  },
  apple: {
    channels: 3,
    labels: ['r16', 'g16', 'b16']
  },
  gray: {
    channels: 1,
    labels: ['gray']
  }
};
var conversions$2 = convert$3; // Hide .channels and .labels properties

for (const model of Object.keys(convert$3)) {
  if (!('channels' in convert$3[model])) {
    throw new Error('missing channels property: ' + model);
  }

  if (!('labels' in convert$3[model])) {
    throw new Error('missing channel labels property: ' + model);
  }

  if (convert$3[model].labels.length !== convert$3[model].channels) {
    throw new Error('channel and label counts mismatch: ' + model);
  }

  const {
    channels,
    labels
  } = convert$3[model];
  delete convert$3[model].channels;
  delete convert$3[model].labels;
  Object.defineProperty(convert$3[model], 'channels', {
    value: channels
  });
  Object.defineProperty(convert$3[model], 'labels', {
    value: labels
  });
}

convert$3.rgb.hsl = function (rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const min = Math.min(r, g, b);
  const max = Math.max(r, g, b);
  const delta = max - min;
  let h;
  let s;

  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }

  h = Math.min(h * 60, 360);

  if (h < 0) {
    h += 360;
  }

  const l = (min + max) / 2;

  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }

  return [h, s * 100, l * 100];
};

convert$3.rgb.hsv = function (rgb) {
  let rdif;
  let gdif;
  let bdif;
  let h;
  let s;
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const v = Math.max(r, g, b);
  const diff = v - Math.min(r, g, b);

  const diffc = function (c) {
    return (v - c) / 6 / diff + 1 / 2;
  };

  if (diff === 0) {
    h = 0;
    s = 0;
  } else {
    s = diff / v;
    rdif = diffc(r);
    gdif = diffc(g);
    bdif = diffc(b);

    if (r === v) {
      h = bdif - gdif;
    } else if (g === v) {
      h = 1 / 3 + rdif - bdif;
    } else if (b === v) {
      h = 2 / 3 + gdif - rdif;
    }

    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }

  return [h * 360, s * 100, v * 100];
};

convert$3.rgb.hwb = function (rgb) {
  const r = rgb[0];
  const g = rgb[1];
  let b = rgb[2];
  const h = convert$3.rgb.hsl(rgb)[0];
  const w = 1 / 255 * Math.min(r, Math.min(g, b));
  b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
  return [h, w * 100, b * 100];
};

convert$3.rgb.cmyk = function (rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const k = Math.min(1 - r, 1 - g, 1 - b);
  const c = (1 - r - k) / (1 - k) || 0;
  const m = (1 - g - k) / (1 - k) || 0;
  const y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance$1(x, y) {
  /*
  	See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
  */
  return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
}

convert$3.rgb.keyword = function (rgb) {
  const reversed = reverseKeywords$1[rgb];

  if (reversed) {
    return reversed;
  }

  let currentClosestDistance = Infinity;
  let currentClosestKeyword;

  for (const keyword of Object.keys(colorName$1)) {
    const value = colorName$1[keyword]; // Compute comparative distance

    const distance = comparativeDistance$1(rgb, value); // Check if its less, if so set as closest

    if (distance < currentClosestDistance) {
      currentClosestDistance = distance;
      currentClosestKeyword = keyword;
    }
  }

  return currentClosestKeyword;
};

convert$3.keyword.rgb = function (keyword) {
  return colorName$1[keyword];
};

convert$3.rgb.xyz = function (rgb) {
  let r = rgb[0] / 255;
  let g = rgb[1] / 255;
  let b = rgb[2] / 255; // Assume sRGB

  r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
  g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
  b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
  const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
  const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x * 100, y * 100, z * 100];
};

convert$3.rgb.lab = function (rgb) {
  const xyz = convert$3.rgb.xyz(rgb);
  let x = xyz[0];
  let y = xyz[1];
  let z = xyz[2];
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
  const l = 116 * y - 16;
  const a = 500 * (x - y);
  const b = 200 * (y - z);
  return [l, a, b];
};

convert$3.hsl.rgb = function (hsl) {
  const h = hsl[0] / 360;
  const s = hsl[1] / 100;
  const l = hsl[2] / 100;
  let t2;
  let t3;
  let val;

  if (s === 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }

  const t1 = 2 * l - t2;
  const rgb = [0, 0, 0];

  for (let i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1);

    if (t3 < 0) {
      t3++;
    }

    if (t3 > 1) {
      t3--;
    }

    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }

    rgb[i] = val * 255;
  }

  return rgb;
};

convert$3.hsl.hsv = function (hsl) {
  const h = hsl[0];
  let s = hsl[1] / 100;
  let l = hsl[2] / 100;
  let smin = s;
  const lmin = Math.max(l, 0.01);
  l *= 2;
  s *= l <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  const v = (l + s) / 2;
  const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
  return [h, sv * 100, v * 100];
};

convert$3.hsv.rgb = function (hsv) {
  const h = hsv[0] / 60;
  const s = hsv[1] / 100;
  let v = hsv[2] / 100;
  const hi = Math.floor(h) % 6;
  const f = h - Math.floor(h);
  const p = 255 * v * (1 - s);
  const q = 255 * v * (1 - s * f);
  const t = 255 * v * (1 - s * (1 - f));
  v *= 255;

  switch (hi) {
    case 0:
      return [v, t, p];

    case 1:
      return [q, v, p];

    case 2:
      return [p, v, t];

    case 3:
      return [p, q, v];

    case 4:
      return [t, p, v];

    case 5:
      return [v, p, q];
  }
};

convert$3.hsv.hsl = function (hsv) {
  const h = hsv[0];
  const s = hsv[1] / 100;
  const v = hsv[2] / 100;
  const vmin = Math.max(v, 0.01);
  let sl;
  let l;
  l = (2 - s) * v;
  const lmin = (2 - s) * vmin;
  sl = s * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


convert$3.hwb.rgb = function (hwb) {
  const h = hwb[0] / 360;
  let wh = hwb[1] / 100;
  let bl = hwb[2] / 100;
  const ratio = wh + bl;
  let f; // Wh + bl cant be > 1

  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  const i = Math.floor(6 * h);
  const v = 1 - bl;
  f = 6 * h - i;

  if ((i & 0x01) !== 0) {
    f = 1 - f;
  }

  const n = wh + f * (v - wh); // Linear interpolation

  let r;
  let g;
  let b;
  /* eslint-disable max-statements-per-line,no-multi-spaces */

  switch (i) {
    default:
    case 6:
    case 0:
      r = v;
      g = n;
      b = wh;
      break;

    case 1:
      r = n;
      g = v;
      b = wh;
      break;

    case 2:
      r = wh;
      g = v;
      b = n;
      break;

    case 3:
      r = wh;
      g = n;
      b = v;
      break;

    case 4:
      r = n;
      g = wh;
      b = v;
      break;

    case 5:
      r = v;
      g = wh;
      b = n;
      break;
  }
  /* eslint-enable max-statements-per-line,no-multi-spaces */


  return [r * 255, g * 255, b * 255];
};

convert$3.cmyk.rgb = function (cmyk) {
  const c = cmyk[0] / 100;
  const m = cmyk[1] / 100;
  const y = cmyk[2] / 100;
  const k = cmyk[3] / 100;
  const r = 1 - Math.min(1, c * (1 - k) + k);
  const g = 1 - Math.min(1, m * (1 - k) + k);
  const b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
};

convert$3.xyz.rgb = function (xyz) {
  const x = xyz[0] / 100;
  const y = xyz[1] / 100;
  const z = xyz[2] / 100;
  let r;
  let g;
  let b;
  r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  b = x * 0.0557 + y * -0.2040 + z * 1.0570; // Assume sRGB

  r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
  g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
  b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
};

convert$3.xyz.lab = function (xyz) {
  let x = xyz[0];
  let y = xyz[1];
  let z = xyz[2];
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
  const l = 116 * y - 16;
  const a = 500 * (x - y);
  const b = 200 * (y - z);
  return [l, a, b];
};

convert$3.lab.xyz = function (lab) {
  const l = lab[0];
  const a = lab[1];
  const b = lab[2];
  let x;
  let y;
  let z;
  y = (l + 16) / 116;
  x = a / 500 + y;
  z = y - b / 200;
  const y2 = y ** 3;
  const x2 = x ** 3;
  const z2 = z ** 3;
  y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
  z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
  x *= 95.047;
  y *= 100;
  z *= 108.883;
  return [x, y, z];
};

convert$3.lab.lch = function (lab) {
  const l = lab[0];
  const a = lab[1];
  const b = lab[2];
  let h;
  const hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;

  if (h < 0) {
    h += 360;
  }

  const c = Math.sqrt(a * a + b * b);
  return [l, c, h];
};

convert$3.lch.lab = function (lch) {
  const l = lch[0];
  const c = lch[1];
  const h = lch[2];
  const hr = h / 360 * 2 * Math.PI;
  const a = c * Math.cos(hr);
  const b = c * Math.sin(hr);
  return [l, a, b];
};

convert$3.rgb.ansi16 = function (args, saturation = null) {
  const [r, g, b] = args;
  let value = saturation === null ? convert$3.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

  value = Math.round(value / 50);

  if (value === 0) {
    return 30;
  }

  let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

  if (value === 2) {
    ansi += 60;
  }

  return ansi;
};

convert$3.hsv.ansi16 = function (args) {
  // Optimization here; we already know the value and don't need to get
  // it converted for us.
  return convert$3.rgb.ansi16(convert$3.hsv.rgb(args), args[2]);
};

convert$3.rgb.ansi256 = function (args) {
  const r = args[0];
  const g = args[1];
  const b = args[2]; // We use the extended greyscale palette here, with the exception of
  // black and white. normal palette only has 4 greyscale shades.

  if (r === g && g === b) {
    if (r < 8) {
      return 16;
    }

    if (r > 248) {
      return 231;
    }

    return Math.round((r - 8) / 247 * 24) + 232;
  }

  const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
};

convert$3.ansi16.rgb = function (args) {
  let color = args % 10; // Handle greyscale

  if (color === 0 || color === 7) {
    if (args > 50) {
      color += 3.5;
    }

    color = color / 10.5 * 255;
    return [color, color, color];
  }

  const mult = (~~(args > 50) + 1) * 0.5;
  const r = (color & 1) * mult * 255;
  const g = (color >> 1 & 1) * mult * 255;
  const b = (color >> 2 & 1) * mult * 255;
  return [r, g, b];
};

convert$3.ansi256.rgb = function (args) {
  // Handle greyscale
  if (args >= 232) {
    const c = (args - 232) * 10 + 8;
    return [c, c, c];
  }

  args -= 16;
  let rem;
  const r = Math.floor(args / 36) / 5 * 255;
  const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
  const b = rem % 6 / 5 * 255;
  return [r, g, b];
};

convert$3.rgb.hex = function (args) {
  const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
  const string = integer.toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};

convert$3.hex.rgb = function (args) {
  const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

  if (!match) {
    return [0, 0, 0];
  }

  let colorString = match[0];

  if (match[0].length === 3) {
    colorString = colorString.split('').map(char => {
      return char + char;
    }).join('');
  }

  const integer = parseInt(colorString, 16);
  const r = integer >> 16 & 0xFF;
  const g = integer >> 8 & 0xFF;
  const b = integer & 0xFF;
  return [r, g, b];
};

convert$3.rgb.hcg = function (rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const max = Math.max(Math.max(r, g), b);
  const min = Math.min(Math.min(r, g), b);
  const chroma = max - min;
  let grayscale;
  let hue;

  if (chroma < 1) {
    grayscale = min / (1 - chroma);
  } else {
    grayscale = 0;
  }

  if (chroma <= 0) {
    hue = 0;
  } else if (max === r) {
    hue = (g - b) / chroma % 6;
  } else if (max === g) {
    hue = 2 + (b - r) / chroma;
  } else {
    hue = 4 + (r - g) / chroma;
  }

  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};

convert$3.hsl.hcg = function (hsl) {
  const s = hsl[1] / 100;
  const l = hsl[2] / 100;
  const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
  let f = 0;

  if (c < 1.0) {
    f = (l - 0.5 * c) / (1.0 - c);
  }

  return [hsl[0], c * 100, f * 100];
};

convert$3.hsv.hcg = function (hsv) {
  const s = hsv[1] / 100;
  const v = hsv[2] / 100;
  const c = s * v;
  let f = 0;

  if (c < 1.0) {
    f = (v - c) / (1 - c);
  }

  return [hsv[0], c * 100, f * 100];
};

convert$3.hcg.rgb = function (hcg) {
  const h = hcg[0] / 360;
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;

  if (c === 0.0) {
    return [g * 255, g * 255, g * 255];
  }

  const pure = [0, 0, 0];
  const hi = h % 1 * 6;
  const v = hi % 1;
  const w = 1 - v;
  let mg = 0;
  /* eslint-disable max-statements-per-line */

  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1;
      pure[1] = v;
      pure[2] = 0;
      break;

    case 1:
      pure[0] = w;
      pure[1] = 1;
      pure[2] = 0;
      break;

    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v;
      break;

    case 3:
      pure[0] = 0;
      pure[1] = w;
      pure[2] = 1;
      break;

    case 4:
      pure[0] = v;
      pure[1] = 0;
      pure[2] = 1;
      break;

    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w;
  }
  /* eslint-enable max-statements-per-line */


  mg = (1.0 - c) * g;
  return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
};

convert$3.hcg.hsv = function (hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const v = c + g * (1.0 - c);
  let f = 0;

  if (v > 0.0) {
    f = c / v;
  }

  return [hcg[0], f * 100, v * 100];
};

convert$3.hcg.hsl = function (hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const l = g * (1.0 - c) + 0.5 * c;
  let s = 0;

  if (l > 0.0 && l < 0.5) {
    s = c / (2 * l);
  } else if (l >= 0.5 && l < 1.0) {
    s = c / (2 * (1 - l));
  }

  return [hcg[0], s * 100, l * 100];
};

convert$3.hcg.hwb = function (hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const v = c + g * (1.0 - c);
  return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert$3.hwb.hcg = function (hwb) {
  const w = hwb[1] / 100;
  const b = hwb[2] / 100;
  const v = 1 - b;
  const c = v - w;
  let g = 0;

  if (c < 1) {
    g = (v - c) / (1 - c);
  }

  return [hwb[0], c * 100, g * 100];
};

convert$3.apple.rgb = function (apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};

convert$3.rgb.apple = function (rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};

convert$3.gray.rgb = function (args) {
  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert$3.gray.hsl = function (args) {
  return [0, 0, args[0]];
};

convert$3.gray.hsv = convert$3.gray.hsl;

convert$3.gray.hwb = function (gray) {
  return [0, 100, gray[0]];
};

convert$3.gray.cmyk = function (gray) {
  return [0, 0, 0, gray[0]];
};

convert$3.gray.lab = function (gray) {
  return [gray[0], 0, 0];
};

convert$3.gray.hex = function (gray) {
  const val = Math.round(gray[0] / 100 * 255) & 0xFF;
  const integer = (val << 16) + (val << 8) + val;
  const string = integer.toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};

convert$3.rgb.gray = function (rgb) {
  const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [val / 255 * 100];
};

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/


function buildGraph$2() {
  const graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3

  const models = Object.keys(conversions$2);

  for (let len = models.length, i = 0; i < len; i++) {
    graph[models[i]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  }

  return graph;
} // https://en.wikipedia.org/wiki/Breadth-first_search


function deriveBFS$2(fromModel) {
  const graph = buildGraph$2();
  const queue = [fromModel]; // Unshift -> queue -> pop

  graph[fromModel].distance = 0;

  while (queue.length) {
    const current = queue.pop();
    const adjacents = Object.keys(conversions$2[current]);

    for (let len = adjacents.length, i = 0; i < len; i++) {
      const adjacent = adjacents[i];
      const node = graph[adjacent];

      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }

  return graph;
}

function link$2(from, to) {
  return function (args) {
    return to(from(args));
  };
}

function wrapConversion$2(toModel, graph) {
  const path = [graph[toModel].parent, toModel];
  let fn = conversions$2[graph[toModel].parent][toModel];
  let cur = graph[toModel].parent;

  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link$2(conversions$2[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }

  fn.conversion = path;
  return fn;
}

var route$2 = function (fromModel) {
  const graph = deriveBFS$2(fromModel);
  const conversion = {};
  const models = Object.keys(graph);

  for (let len = models.length, i = 0; i < len; i++) {
    const toModel = models[i];
    const node = graph[toModel];

    if (node.parent === null) {
      // No possible conversion, or this node is the source model.
      continue;
    }

    conversion[toModel] = wrapConversion$2(toModel, graph);
  }

  return conversion;
};

const convert$4 = {};
const models$2 = Object.keys(conversions$2);

function wrapRaw$2(fn) {
  const wrappedFn = function (...args) {
    const arg0 = args[0];

    if (arg0 === undefined || arg0 === null) {
      return arg0;
    }

    if (arg0.length > 1) {
      args = arg0;
    }

    return fn(args);
  }; // Preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

function wrapRounded$2(fn) {
  const wrappedFn = function (...args) {
    const arg0 = args[0];

    if (arg0 === undefined || arg0 === null) {
      return arg0;
    }

    if (arg0.length > 1) {
      args = arg0;
    }

    const result = fn(args); // We're assuming the result is an array here.
    // see notice in conversions.js; don't use box types
    // in conversion functions.

    if (typeof result === 'object') {
      for (let len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }

    return result;
  }; // Preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

models$2.forEach(fromModel => {
  convert$4[fromModel] = {};
  Object.defineProperty(convert$4[fromModel], 'channels', {
    value: conversions$2[fromModel].channels
  });
  Object.defineProperty(convert$4[fromModel], 'labels', {
    value: conversions$2[fromModel].labels
  });
  const routes = route$2(fromModel);
  const routeModels = Object.keys(routes);
  routeModels.forEach(toModel => {
    const fn = routes[toModel];
    convert$4[fromModel][toModel] = wrapRounded$2(fn);
    convert$4[fromModel][toModel].raw = wrapRaw$2(fn);
  });
});
var colorConvert$2 = convert$4;

var ansiStyles$2 = createCommonjsModule(function (module) {

const wrapAnsi16 = (fn, offset) => (...args) => {
  const code = fn(...args);
  return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
  const code = fn(...args);
  return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
  const rgb = fn(...args);
  return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;

const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
  Object.defineProperty(object, property, {
    get: () => {
      const value = get();
      Object.defineProperty(object, property, {
        value,
        enumerable: true,
        configurable: true
      });
      return value;
    },
    enumerable: true,
    configurable: true
  });
};
/** @type {typeof import('color-convert')} */


let colorConvert;

const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
  if (colorConvert === undefined) {
    colorConvert = colorConvert$2;
  }

  const offset = isBackground ? 10 : 0;
  const styles = {};

  for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
    const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;

    if (sourceSpace === targetSpace) {
      styles[name] = wrap(identity, offset);
    } else if (typeof suite === 'object') {
      styles[name] = wrap(suite[targetSpace], offset);
    }
  }

  return styles;
};

function assembleStyles() {
  const codes = new Map();
  const styles = {
    modifier: {
      reset: [0, 0],
      // 21 isn't widely supported and 22 does the same thing
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      // Bright color
      blackBright: [90, 39],
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      // Bright color
      bgBlackBright: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  }; // Alias bright black as gray (and grey)

  styles.color.gray = styles.color.blackBright;
  styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
  styles.color.grey = styles.color.blackBright;
  styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\u001B[${style[0]}m`,
        close: `\u001B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }

    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }

  Object.defineProperty(styles, 'codes', {
    value: codes,
    enumerable: false
  });
  styles.color.close = '\u001B[39m';
  styles.bgColor.close = '\u001B[49m';
  setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
  setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
  setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
  setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
  setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
  setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));
  return styles;
} // Make the export immutable


Object.defineProperty(module, 'exports', {
  enumerable: true,
  get: assembleStyles
});
});

const ESCAPES$2 = new Set(['\u001B', '\u009B']);
const END_CODE$1 = 39;

const wrapAnsi$2 = code => `${ESCAPES$2.values().next().value}[${code}m`; // Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes


const wordLengths$1 = string => string.split(' ').map(character => stringWidth_1$1(character)); // Wrap a long word across multiple rows
// Ansi escape codes do not count towards length


const wrapWord$1 = (rows, word, columns) => {
  const characters = [...word];
  let isInsideEscape = false;
  let visible = stringWidth_1$1(stripAnsi(rows[rows.length - 1]));

  for (const [index, character] of characters.entries()) {
    const characterLength = stringWidth_1$1(character);

    if (visible + characterLength <= columns) {
      rows[rows.length - 1] += character;
    } else {
      rows.push(character);
      visible = 0;
    }

    if (ESCAPES$2.has(character)) {
      isInsideEscape = true;
    } else if (isInsideEscape && character === 'm') {
      isInsideEscape = false;
      continue;
    }

    if (isInsideEscape) {
      continue;
    }

    visible += characterLength;

    if (visible === columns && index < characters.length - 1) {
      rows.push('');
      visible = 0;
    }
  } // It's possible that the last row we copy over is only
  // ansi escape characters, handle this edge-case


  if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
    rows[rows.length - 2] += rows.pop();
  }
}; // Trims spaces from a string ignoring invisible sequences


const stringVisibleTrimSpacesRight$1 = str => {
  const words = str.split(' ');
  let last = words.length;

  while (last > 0) {
    if (stringWidth_1$1(words[last - 1]) > 0) {
      break;
    }

    last--;
  }

  if (last === words.length) {
    return str;
  }

  return words.slice(0, last).join(' ') + words.slice(last).join('');
}; // The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode
//
// 'hard' will never allow a string to take up more than columns characters
//
// 'soft' allows long words to expand past the column length


const exec$1 = (string, columns, options = {}) => {
  if (options.trim !== false && string.trim() === '') {
    return '';
  }

  let pre = '';
  let ret = '';
  let escapeCode;
  const lengths = wordLengths$1(string);
  let rows = [''];

  for (const [index, word] of string.split(' ').entries()) {
    if (options.trim !== false) {
      rows[rows.length - 1] = rows[rows.length - 1].trimLeft();
    }

    let rowLength = stringWidth_1$1(rows[rows.length - 1]);

    if (index !== 0) {
      if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
        // If we start with a new word but the current row length equals the length of the columns, add a new row
        rows.push('');
        rowLength = 0;
      }

      if (rowLength > 0 || options.trim === false) {
        rows[rows.length - 1] += ' ';
        rowLength++;
      }
    } // In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'


    if (options.hard && lengths[index] > columns) {
      const remainingColumns = columns - rowLength;
      const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
      const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);

      if (breaksStartingNextLine < breaksStartingThisLine) {
        rows.push('');
      }

      wrapWord$1(rows, word, columns);
      continue;
    }

    if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
      if (options.wordWrap === false && rowLength < columns) {
        wrapWord$1(rows, word, columns);
        continue;
      }

      rows.push('');
    }

    if (rowLength + lengths[index] > columns && options.wordWrap === false) {
      wrapWord$1(rows, word, columns);
      continue;
    }

    rows[rows.length - 1] += word;
  }

  if (options.trim !== false) {
    rows = rows.map(stringVisibleTrimSpacesRight$1);
  }

  pre = rows.join('\n');

  for (const [index, character] of [...pre].entries()) {
    ret += character;

    if (ESCAPES$2.has(character)) {
      const code = parseFloat(/\d[^m]*/.exec(pre.slice(index, index + 4)));
      escapeCode = code === END_CODE$1 ? null : code;
    }

    const code = ansiStyles$2.codes.get(Number(escapeCode));

    if (escapeCode && code) {
      if (pre[index + 1] === '\n') {
        ret += wrapAnsi$2(code);
      } else if (character === '\n') {
        ret += wrapAnsi$2(escapeCode);
      }
    }
  }

  return ret;
}; // For each newline, invoke the method separately


var wrapAnsi_1$1 = (string, columns, options) => {
  return String(string).normalize().replace(/\r\n/g, '\n').split('\n').map(line => exec$1(line, columns, options)).join('\n');
};

/* eslint-disable yoda */

const isFullwidthCodePoint$4 = codePoint => {
  if (Number.isNaN(codePoint)) {
    return false;
  } // Code points are derived from:
  // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt


  if (codePoint >= 0x1100 && (codePoint <= 0x115F || // Hangul Jamo
  codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
  codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  0x3250 <= codePoint && codePoint <= 0x4DBF || // CJK Unified Ideographs .. Yi Radicals
  0x4E00 <= codePoint && codePoint <= 0xA4C6 || // Hangul Jamo Extended-A
  0xA960 <= codePoint && codePoint <= 0xA97C || // Hangul Syllables
  0xAC00 <= codePoint && codePoint <= 0xD7A3 || // CJK Compatibility Ideographs
  0xF900 <= codePoint && codePoint <= 0xFAFF || // Vertical Forms
  0xFE10 <= codePoint && codePoint <= 0xFE19 || // CJK Compatibility Forms .. Small Form Variants
  0xFE30 <= codePoint && codePoint <= 0xFE6B || // Halfwidth and Fullwidth Forms
  0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || // Kana Supplement
  0x1B000 <= codePoint && codePoint <= 0x1B001 || // Enclosed Ideographic Supplement
  0x1F200 <= codePoint && codePoint <= 0x1F251 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  0x20000 <= codePoint && codePoint <= 0x3FFFD)) {
    return true;
  }

  return false;
};

var isFullwidthCodePoint_1$3 = isFullwidthCodePoint$4;
var _default$7 = isFullwidthCodePoint$4;
isFullwidthCodePoint_1$3.default = _default$7;

var emojiRegex$4 = function () {
  // https://mths.be/emoji
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};

const stringWidth$3 = string => {
  string = string.replace(emojiRegex$4(), '  ');

  if (typeof string !== 'string' || string.length === 0) {
    return 0;
  }

  string = stripAnsi(string);
  let width = 0;

  for (let i = 0; i < string.length; i++) {
    const code = string.codePointAt(i); // Ignore control characters

    if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {
      continue;
    } // Ignore combining characters


    if (code >= 0x300 && code <= 0x36F) {
      continue;
    } // Surrogates


    if (code > 0xFFFF) {
      i++;
    }

    width += isFullwidthCodePoint_1$3(code) ? 2 : 1;
  }

  return width;
};

var stringWidth_1$2 = stringWidth$3; // TODO: remove this in the next major version

var _default$8 = stringWidth$3;
stringWidth_1$2.default = _default$8;

function getIndexOfNearestSpace(string, index, shouldSearchRight) {
  if (string.charAt(index) === ' ') {
    return index;
  }

  for (let i = 1; i <= 3; i++) {
    if (shouldSearchRight) {
      if (string.charAt(index + i) === ' ') {
        return index + i;
      }
    } else if (string.charAt(index - i) === ' ') {
      return index - i;
    }
  }

  return index;
}

var cliTruncate = (text, columns, options) => {
  options = {
    position: 'end',
    preferTruncationOnSpace: false,
    ...options
  };
  const {
    position,
    space,
    preferTruncationOnSpace
  } = options;
  let ellipsis = '…';
  let ellipsisWidth = 1;

  if (typeof text !== 'string') {
    throw new TypeError(`Expected \`input\` to be a string, got ${typeof text}`);
  }

  if (typeof columns !== 'number') {
    throw new TypeError(`Expected \`columns\` to be a number, got ${typeof columns}`);
  }

  if (columns < 1) {
    return '';
  }

  if (columns === 1) {
    return ellipsis;
  }

  const length = stringWidth_1$2(text);

  if (length <= columns) {
    return text;
  }

  if (position === 'start') {
    if (preferTruncationOnSpace) {
      const nearestSpace = getIndexOfNearestSpace(text, length - columns + 1, true);
      return ellipsis + sliceAnsi(text, nearestSpace, length).trim();
    }

    if (space === true) {
      ellipsis += ' ';
      ellipsisWidth = 2;
    }

    return ellipsis + sliceAnsi(text, length - columns + ellipsisWidth, length);
  }

  if (position === 'middle') {
    if (space === true) {
      ellipsis = ' ' + ellipsis + ' ';
      ellipsisWidth = 3;
    }

    const half = Math.floor(columns / 2);

    if (preferTruncationOnSpace) {
      const spaceNearFirstBreakPoint = getIndexOfNearestSpace(text, half);
      const spaceNearSecondBreakPoint = getIndexOfNearestSpace(text, length - (columns - half) + 1, true);
      return sliceAnsi(text, 0, spaceNearFirstBreakPoint) + ellipsis + sliceAnsi(text, spaceNearSecondBreakPoint, length).trim();
    }

    return sliceAnsi(text, 0, half) + ellipsis + sliceAnsi(text, length - (columns - half) + ellipsisWidth, length);
  }

  if (position === 'end') {
    if (preferTruncationOnSpace) {
      const nearestSpace = getIndexOfNearestSpace(text, columns - 1);
      return sliceAnsi(text, 0, nearestSpace) + ellipsis;
    }

    if (space === true) {
      ellipsis = ' ' + ellipsis;
      ellipsisWidth = 2;
    }

    return sliceAnsi(text, 0, columns - ellipsisWidth) + ellipsis;
  }

  throw new Error(`Expected \`options.position\` to be either \`start\`, \`middle\` or \`end\`, got ${position}`);
};

var wrapText = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _wrapAnsi = _interopRequireDefault(wrapAnsi_1$1);

var _cliTruncate = _interopRequireDefault(cliTruncate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (text, maxWidth, {
  textWrap
} = {}) => {
  if (textWrap === 'wrap') {
    return (0, _wrapAnsi.default)(text, maxWidth, {
      trim: false,
      hard: true
    });
  }

  if (String(textWrap).startsWith('truncate')) {
    let position;

    if (textWrap === 'truncate' || textWrap === 'truncate-end') {
      position = 'end';
    }

    if (textWrap === 'truncate-middle') {
      position = 'middle';
    }

    if (textWrap === 'truncate-start') {
      position = 'start';
    }

    return (0, _cliTruncate.default)(text, maxWidth, {
      position
    });
  }

  return text;
};

exports.default = _default;
});

var getMaxWidth = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _default = yogaNode => {
  return yogaNode.getComputedWidth() - yogaNode.getComputedPadding() * 2;
};

exports.default = _default;
});

var renderNodeToOutput_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _widestLine = _interopRequireDefault(widestLine_1);

var _wrapText = _interopRequireDefault(wrapText);

var _getMaxWidth = _interopRequireDefault(getMaxWidth);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isAllTextNodes = node => {
  if (node.nodeName === '#text') {
    return true;
  }

  if (node.nodeName === 'SPAN') {
    if (node.textContent) {
      return true;
    }

    if (Array.isArray(node.childNodes)) {
      return node.childNodes.every(isAllTextNodes);
    }
  }

  return false;
}; // Squashing text nodes allows to combine multiple text nodes into one and write
// to `Output` instance only once. For example, <Text>hello{' '}world</Text>
// is actually 3 text nodes, which would result 3 writes to `Output`.
//
// Also, this is necessary for libraries like ink-link (https://github.com/sindresorhus/ink-link),
// which need to wrap all children at once, instead of wrapping 3 text nodes separately.


const squashTextNodes = node => {
  if (node.childNodes.length === 0) {
    return '';
  } // If parent container is `<Box>`, text nodes will be treated as separate nodes in
  // the tree and will have their own coordinates in the layout.
  // To ensure text nodes are aligned correctly, take X and Y of the first text node
  // and use them as offset for the rest of the nodes
  // Only first node is taken into account, because other text nodes can't have margin or padding,
  // so their coordinates will be relative to the first node anyway


  const offsetX = node.childNodes[0].yogaNode.getComputedLeft();
  const offsetY = node.childNodes[0].yogaNode.getComputedTop();
  let text = '\n'.repeat(offsetY) + ' '.repeat(offsetX);

  for (const childNode of node.childNodes) {
    let nodeText;

    if (childNode.nodeName === '#text') {
      nodeText = childNode.nodeValue;
    }

    if (childNode.nodeName === 'SPAN') {
      nodeText = childNode.textContent || squashTextNodes(childNode);
    } // Since these text nodes are being concatenated, `Output` instance won't be able to
    // apply children transform, so we have to do it manually here for each text node


    if (childNode.unstable__transformChildren) {
      nodeText = childNode.unstable__transformChildren(nodeText);
    }

    text += nodeText;
  }

  return text;
}; // After nodes are laid out, render each to output object, which later gets rendered to terminal


const renderNodeToOutput = (node, output, {
  offsetX = 0,
  offsetY = 0,
  transformers = [],
  skipStaticElements
}) => {
  if (node.unstable__static && skipStaticElements) {
    return;
  }

  const {
    yogaNode
  } = node; // Left and top positions in Yoga are relative to their parent node

  const x = offsetX + yogaNode.getComputedLeft();
  const y = offsetY + yogaNode.getComputedTop(); // Transformers are functions that transform final text output of each component
  // See Output class for logic that applies transformers

  let newTransformers = transformers;

  if (node.unstable__transformChildren) {
    newTransformers = [node.unstable__transformChildren, ...transformers];
  } // Nodes with only text inside


  if (node.textContent) {
    let text = node.textContent; // Since text nodes are always wrapped in an additional node, parent node
    // is where we should look for attributes

    if (node.parentNode.style.textWrap) {
      const currentWidth = (0, _widestLine.default)(text);
      const maxWidth = (0, _getMaxWidth.default)(node.parentNode.yogaNode);

      if (currentWidth > maxWidth) {
        text = (0, _wrapText.default)(text, maxWidth, {
          textWrap: node.parentNode.style.textWrap
        });
      }
    }

    output.write(x, y, text, {
      transformers: newTransformers
    });
    return;
  } // Text nodes


  if (node.nodeName === '#text') {
    output.write(x, y, node.nodeValue, {
      transformers: newTransformers
    });
    return;
  } // Nodes that have other nodes as children


  if (Array.isArray(node.childNodes) && node.childNodes.length > 0) {
    const isFlexDirectionRow = node.style.flexDirection === 'row';

    if (isFlexDirectionRow && node.childNodes.every(isAllTextNodes)) {
      let text = squashTextNodes(node);

      if (node.style.textWrap) {
        const currentWidth = (0, _widestLine.default)(text);
        const maxWidth = (0, _getMaxWidth.default)(yogaNode);

        if (currentWidth > maxWidth) {
          text = (0, _wrapText.default)(text, maxWidth, {
            textWrap: node.style.textWrap
          });
        }
      }

      output.write(x, y, text, {
        transformers: newTransformers
      });
      return;
    }

    for (const childNode of node.childNodes) {
      renderNodeToOutput(childNode, output, {
        offsetX: x,
        offsetY: y,
        transformers: newTransformers,
        skipStaticElements
      });
    }
  }
};

var _default = renderNodeToOutput;
exports.default = _default;
});

var calculateWrappedText_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _measureText = _interopRequireDefault(measureText);

var _wrapText = _interopRequireDefault(wrapText);

var _getMaxWidth = _interopRequireDefault(getMaxWidth);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Since we need to know the width of text container to wrap text, we have to calculate layout twice
// This function is executed after first layout calculation to reassign width and height of text nodes
const calculateWrappedText = node => {
  if (node.textContent && typeof node.parentNode.style.textWrap === 'string') {
    const {
      yogaNode
    } = node;
    const parentYogaNode = node.parentNode.yogaNode;
    const maxWidth = (0, _getMaxWidth.default)(parentYogaNode);
    const currentWidth = yogaNode.getComputedWidth();

    if (currentWidth > maxWidth) {
      const {
        textWrap
      } = node.parentNode.style;
      const wrappedText = (0, _wrapText.default)(node.textContent, maxWidth, {
        textWrap
      });
      const {
        width,
        height
      } = (0, _measureText.default)(wrappedText);
      yogaNode.setWidth(width);
      yogaNode.setHeight(height);
    }

    return;
  }

  if (Array.isArray(node.childNodes) && node.childNodes.length > 0) {
    for (const childNode of node.childNodes) {
      calculateWrappedText(childNode);
    }
  }
};

var _default = calculateWrappedText;
exports.default = _default;
});

var renderer = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _yogaLayoutPrebuilt = _interopRequireDefault(yogaLayoutPrebuilt);

var _output = _interopRequireDefault(output);



var _buildLayout = _interopRequireDefault(buildLayout_1);

var _renderNodeToOutput = _interopRequireDefault(renderNodeToOutput_1);

var _calculateWrappedText = _interopRequireDefault(calculateWrappedText_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Since <Static> components can be placed anywhere in the tree, this helper finds and returns them
const getStaticNodes = element => {
  const staticNodes = [];

  for (const childNode of element.childNodes) {
    if (childNode.unstable__static) {
      staticNodes.push(childNode);
    }

    if (Array.isArray(childNode.childNodes) && childNode.childNodes.length > 0) {
      staticNodes.push(...getStaticNodes(childNode));
    }
  }

  return staticNodes;
}; // Build layout, apply styles, build text output of all nodes and return it


var _default = ({
  terminalWidth
}) => {
  const config = _yogaLayoutPrebuilt.default.Config.create(); // Used to free up memory used by last Yoga node tree


  let lastYogaNode;
  let lastStaticYogaNode;
  return node => {
    if (lastYogaNode) {
      lastYogaNode.freeRecursive();
    }

    if (lastStaticYogaNode) {
      lastStaticYogaNode.freeRecursive();
    }

    const staticElements = getStaticNodes(node);


    let staticOutput;

    if (staticElements.length === 1) {
      const rootNode = (0, dom.createNode)('root');
      (0, dom.appendStaticNode)(rootNode, staticElements[0]);
      const {
        yogaNode: staticYogaNode
      } = (0, _buildLayout.default)(rootNode, {
        config,
        terminalWidth,
        skipStaticElements: false
      });
      staticYogaNode.calculateLayout(_yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.DIRECTION_LTR);
      (0, _calculateWrappedText.default)(rootNode);
      staticYogaNode.calculateLayout(_yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.DIRECTION_LTR); // Save current Yoga node tree to free up memory later

      lastStaticYogaNode = staticYogaNode;
      staticOutput = new _output.default({
        width: staticYogaNode.getComputedWidth(),
        height: staticYogaNode.getComputedHeight()
      });
      (0, _renderNodeToOutput.default)(rootNode, staticOutput, {
        skipStaticElements: false
      });
    }

    const {
      yogaNode
    } = (0, _buildLayout.default)(node, {
      config,
      terminalWidth,
      skipStaticElements: true
    });
    yogaNode.calculateLayout(_yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.DIRECTION_LTR);
    (0, _calculateWrappedText.default)(node);
    yogaNode.calculateLayout(_yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.DIRECTION_LTR); // Save current node tree to free up memory later

    lastYogaNode = yogaNode;
    const output = new _output.default({
      width: yogaNode.getComputedWidth(),
      height: yogaNode.getComputedHeight()
    });
    (0, _renderNodeToOutput.default)(node, output, {
      skipStaticElements: true
    });
    return {
      output: output.get(),
      outputHeight: output.getHeight(),
      staticOutput: staticOutput ? `${staticOutput.get()}\n` : undefined
    };
  };
};

exports.default = _default;
});

var output$1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _stringLength = _interopRequireDefault(stringLength_1);

var _sliceAnsi = _interopRequireDefault(sliceAnsi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * "Virtual" output class
 *
 * Handles the positioning and saving of the output of each node in the tree.
 * Also responsible for applying transformations to each character of the output.
 *
 * Used to generate the final output of all nodes before writing it to actual output stream (e.g. stdout)
 */
class Output {
  constructor({
    width,
    height
  }) {
    this.width = width;
    this.height = height;
    this.writes = []; // Initialize output array with a specific set of rows, so that margin/padding at the bottom is preserved
  }

  write(x, y, text, {
    transformers
  }) {
    if (!text) {
      return;
    }

    this.writes.push({
      x,
      y,
      text,
      transformers
    });
  }

  get() {
    const output = [];

    for (let y = 0; y < this.height; y++) {
      output.push(' '.repeat(this.width));
    }

    for (const write of this.writes) {
      const {
        x,
        y,
        text,
        transformers
      } = write;
      const lines = text.split('\n');
      let offsetY = 0;

      for (let line of lines) {
        const currentLine = output[y + offsetY]; // Line can be missing if `text` is taller than height of pre-initialized `this.output`

        if (!currentLine) {
          continue;
        }

        const length = (0, _stringLength.default)(line);

        for (const transformer of transformers) {
          line = transformer(line);
        }

        output[y + offsetY] = (0, _sliceAnsi.default)(currentLine, 0, x) + line + (0, _sliceAnsi.default)(currentLine, x + length);
        offsetY++;
      }
    }

    const generatedOutput = output.map(line => line.trimRight()).join('\n');
    return {
      output: generatedOutput,
      height: output.length
    };
  }

}

exports.default = Output;
});

var renderer$1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _yogaLayoutPrebuilt = _interopRequireDefault(yogaLayoutPrebuilt);

var _renderNodeToOutput = _interopRequireDefault(renderNodeToOutput_1);

var _calculateWrappedText = _interopRequireDefault(calculateWrappedText_1);

var _output = _interopRequireDefault(output$1);



function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Since <Static> components can be placed anywhere in the tree, this helper finds and returns them
const findStaticNode = node => {
  if (node.unstable__static) {
    return node;
  }

  for (const childNode of node.childNodes) {
    if (childNode.unstable__static) {
      return childNode;
    }

    if (Array.isArray(childNode.childNodes) && childNode.childNodes.length > 0) {
      return findStaticNode(childNode);
    }
  }
};

var _default = ({
  terminalWidth = 100
}) => {
  return node => {
    (0, dom$1.setStyle)(node, {
      width: terminalWidth
    });
    node.yogaNode.calculateLayout(_yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.DIRECTION_LTR);
    (0, _calculateWrappedText.default)(node);
    node.yogaNode.calculateLayout(_yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.DIRECTION_LTR);
    const output = new _output.default({
      width: node.yogaNode.getComputedWidth(),
      height: node.yogaNode.getComputedHeight()
    });
    (0, _renderNodeToOutput.default)(node, output, {
      skipStaticElements: true
    });
    const staticNode = findStaticNode(node);
    let staticOutput;

    if (staticNode) {
      staticOutput = new _output.default({
        width: staticNode.yogaNode.getComputedWidth(),
        height: staticNode.yogaNode.getComputedHeight()
      });
      (0, _renderNodeToOutput.default)(staticNode, staticOutput, {
        skipStaticElements: false
      });
    }

    const {
      output: generatedOutput,
      height: outputHeight
    } = output.get();
    return {
      output: generatedOutput,
      outputHeight,
      // Newline at the end is needed, because static output doesn't have one, so
      // interactive output will override last line of static output
      staticOutput: staticOutput ? `${staticOutput.get().output}\n` : undefined
    };
  };
};

exports.default = _default;
});

var instances = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Store all instances of Ink (instance.js) to ensure that consecutive render() calls
// use the same instance of Ink and don't create a new one
//
// This map has to be stored in a separate file, because render.js creates instances,
// but instance.js should delete itself from the map on unmount
var _default = new WeakMap();

exports.default = _default;
});

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
var ReactPropTypesSecret_1 = ReactPropTypesSecret;

function emptyFunction() {}

function emptyFunctionWithReset() {}

emptyFunctionWithReset.resetWarningCache = emptyFunction;

var factoryWithThrowingShims = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret_1) {
      // It is still safe when called from React.
      return;
    }

    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
    err.name = 'Invariant Violation';
    throw err;
  }
  shim.isRequired = shim;

  function getShim() {
    return shim;
  }
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.

  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};

var propTypes = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
{
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = factoryWithThrowingShims();
}
});

const mimicFn$1 = (to, from) => {
  for (const prop of Reflect.ownKeys(from)) {
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
  }

  return to;
};

var mimicFn_1 = mimicFn$1; // TODO: Remove this for the next major release

var _default$9 = mimicFn$1;
mimicFn_1.default = _default$9;

const calledFunctions = new WeakMap();

const oneTime = (fn, options = {}) => {
  if (typeof fn !== 'function') {
    throw new TypeError('Expected a function');
  }

  let ret;
  let isCalled = false;
  let callCount = 0;
  const functionName = fn.displayName || fn.name || '<anonymous>';

  const onetime = function (...args) {
    calledFunctions.set(onetime, ++callCount);

    if (isCalled) {
      if (options.throw === true) {
        throw new Error(`Function \`${functionName}\` can only be called once`);
      }

      return ret;
    }

    isCalled = true;
    ret = fn.apply(this, args);
    fn = null;
    return ret;
  };

  mimicFn_1(onetime, fn);
  calledFunctions.set(onetime, callCount);
  return onetime;
};

var onetime$1 = oneTime; // TODO: Remove this for the next major release

var _default$a = oneTime;

var callCount = fn => {
  if (!calledFunctions.has(fn)) {
    throw new Error(`The given function \`${fn.name}\` is not wrapped by the \`onetime\` package`);
  }

  return calledFunctions.get(fn);
};
onetime$1.default = _default$a;
onetime$1.callCount = callCount;

var restoreCursor$1 = onetime$1(() => {
  signalExit(() => {
    process.stderr.write('\u001B[?25h');
  }, {
    alwaysLast: true
  });
});

var cliCursor$1 = createCommonjsModule(function (module, exports) {



let isHidden = false;

exports.show = (writableStream = process.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }

  isHidden = false;
  writableStream.write('\u001B[?25h');
};

exports.hide = (writableStream = process.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }

  restoreCursor$1();
  isHidden = true;
  writableStream.write('\u001B[?25l');
};

exports.toggle = (force, writableStream) => {
  if (force !== undefined) {
    isHidden = force;
  }

  if (isHidden) {
    exports.show(writableStream);
  } else {
    exports.hide(writableStream);
  }
};
});

var AppContext = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _react.default.createContext({
  exit() {}

});

exports.default = _default;
});

var StdinContext = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _react.default.createContext({
  stdin: undefined,
  setRawMode: undefined
});

exports.default = _default;
});

var StdoutContext = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _react.default.createContext({
  stdout: undefined
});

exports.default = _default;
});

var App_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(react);

var _propTypes = _interopRequireDefault(propTypes);

var _cliCursor = _interopRequireDefault(cliCursor$1);

var _AppContext = _interopRequireDefault(AppContext);

var _StdinContext = _interopRequireDefault(StdinContext);

var _StdoutContext = _interopRequireDefault(StdoutContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Root component for all Ink apps
// It renders stdin and stdout contexts, so that children can access them if needed
// It also handles Ctrl+C exiting and cursor visibility
class App extends _react.PureComponent {
  // Determines if TTY is supported on the provided stdin
  isRawModeSupported() {
    return this.props.stdin.isTTY;
  }

  constructor() {
    super(); // Count how many components enabled raw mode to avoid disabling
    // raw mode until all components don't need it anymore

    _defineProperty(this, "handleSetRawMode", isEnabled => {
      const {
        stdin
      } = this.props;

      if (!this.isRawModeSupported()) {
        if (stdin === process.stdin) {
          throw new Error('Raw mode is not supported on the current process.stdin, which Ink uses as input stream by default.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported');
        } else {
          throw new Error('Raw mode is not supported on the stdin provided to Ink.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported');
        }
      }

      stdin.setEncoding('utf8');

      if (isEnabled) {
        // Ensure raw mode is enabled only once
        if (this.rawModeEnabledCount === 0) {
          stdin.addListener('data', this.handleInput);
          stdin.resume();
          stdin.setRawMode(true);
        }

        this.rawModeEnabledCount++;
        return;
      } // Disable raw mode only when no components left that are using it


      if (--this.rawModeEnabledCount === 0) {
        stdin.setRawMode(false);
        stdin.removeListener('data', this.handleInput);
        stdin.pause();
      }
    });

    _defineProperty(this, "handleInput", input => {
      // Exit on Ctrl+C
      if (input === '\x03' && this.props.exitOnCtrlC) {
        // eslint-disable-line unicorn/no-hex-escape
        this.handleExit();
      }
    });

    _defineProperty(this, "handleExit", error => {
      if (this.isRawModeSupported()) {
        this.handleSetRawMode(false);
      }

      this.props.onExit(error);
    });

    this.rawModeEnabledCount = 0;
  }

  render() {
    return _react.default.createElement(_AppContext.default.Provider, {
      value: {
        exit: this.handleExit
      }
    }, _react.default.createElement(_StdinContext.default.Provider, {
      value: {
        stdin: this.props.stdin,
        setRawMode: this.handleSetRawMode,
        isRawModeSupported: this.isRawModeSupported()
      }
    }, _react.default.createElement(_StdoutContext.default.Provider, {
      value: {
        stdout: this.props.stdout
      }
    }, this.props.children)));
  }

  componentDidMount() {
    _cliCursor.default.hide(this.props.stdout);
  }

  componentWillUnmount() {
    _cliCursor.default.show(this.props.stdout); // ignore calling setRawMode on an handle stdin it cannot be called


    if (this.isRawModeSupported()) {
      this.handleSetRawMode(false);
    }
  }

  componentDidCatch(error) {
    this.handleExit(error);
  }

}

exports.default = App;

_defineProperty(App, "propTypes", {
  children: _propTypes.default.node.isRequired,
  stdin: _propTypes.default.object.isRequired,
  stdout: _propTypes.default.object.isRequired,
  exitOnCtrlC: _propTypes.default.bool.isRequired,
  // eslint-disable-line react/boolean-prop-naming
  onExit: _propTypes.default.func.isRequired
});
});

var instance = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(react);

var _lodash = _interopRequireDefault(lodash_throttle);

var _autoBind = _interopRequireDefault(autoBind);

var _logUpdate = _interopRequireDefault(logUpdate);

var _isCi = _interopRequireDefault(isCi);

var _signalExit = _interopRequireDefault(signalExit);

var _ansiEscapes = _interopRequireDefault(ansiEscapes_1);

var _reconciler = _interopRequireDefault(reconciler);

var _reconciler2 = _interopRequireDefault(reconciler$1);

var _renderer = _interopRequireDefault(renderer);

var _renderer2 = _interopRequireDefault(renderer$1);

var dom$2 = _interopRequireWildcard(dom);

var experimentalDom = _interopRequireWildcard(dom$1);

var _instances = _interopRequireDefault(instances);

var _App = _interopRequireDefault(App_1);

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Instance {
  constructor(options) {
    (0, _autoBind.default)(this);
    this.options = options;

    if (options.experimental) {
      this.rootNode = experimentalDom.createNode('root');
      this.rootNode.onRender = options.debug ? this.onRender : (0, _lodash.default)(this.onRender, 16, {
        leading: true,
        trailing: true
      });
      this.rootNode.onImmediateRender = this.onRender;
      this.renderer = (0, _renderer2.default)({
        terminalWidth: options.stdout.columns
      });
    } else {
      this.rootNode = dom$2.createNode('root');
      this.rootNode.onRender = this.onRender;
      this.renderer = (0, _renderer.default)({
        terminalWidth: options.stdout.columns
      });
    }

    this.log = _logUpdate.default.create(options.stdout);
    this.throttledLog = options.debug ? this.log : (0, _lodash.default)(this.log, {
      leading: true,
      trailing: true
    }); // Ignore last render after unmounting a tree to prevent empty output before exit

    this.isUnmounted = false; // Store last output to only rerender when needed

    this.lastOutput = ''; // This variable is used only in debug mode to store full static output
    // so that it's rerendered every time, not just new static parts, like in non-debug mode

    this.fullStaticOutput = '';

    if (options.experimental) {
      this.container = _reconciler2.default.createContainer(this.rootNode, false, false);
    } else {
      this.container = _reconciler.default.createContainer(this.rootNode, false, false);
    }

    this.exitPromise = new Promise((resolve, reject) => {
      this.resolveExitPromise = resolve;
      this.rejectExitPromise = reject;
    }); // Unmount when process exits

    this.unsubscribeExit = (0, _signalExit.default)(this.unmount, {
      alwaysLast: false
    });
  }

  onRender() {
    if (this.isUnmounted) {
      return;
    }

    const {
      output,
      outputHeight,
      staticOutput
    } = this.renderer(this.rootNode); // If <Static> output isn't empty, it means new children have been added to it

    const hasStaticOutput = staticOutput && staticOutput !== '\n';

    if (this.options.debug) {
      if (hasStaticOutput) {
        this.fullStaticOutput += staticOutput;
      }

      this.options.stdout.write(this.fullStaticOutput + output);
      return;
    }

    if (_isCi.default) {
      if (hasStaticOutput) {
        this.options.stdout.write(staticOutput);
      }

      this.lastOutput = output;
      return;
    }

    if (hasStaticOutput) {
      this.fullStaticOutput += staticOutput;
    }

    if (this.options.experimental && outputHeight >= this.options.stdout.rows) {
      this.options.stdout.write(_ansiEscapes.default.clearTerminal + this.fullStaticOutput + output);
      this.lastOutput = output;
      return;
    } // To ensure static output is cleanly rendered before main output, clear main output first


    if (hasStaticOutput) {
      this.log.clear();
      this.options.stdout.write(staticOutput);
    }

    if (output !== this.lastOutput) {
      if (this.options.experimental) {
        this.throttledLog(output);
      } else {
        this.log(output);
      }
    }
  }

  render(node) {
    const tree = _react.default.createElement(_App.default, {
      stdin: this.options.stdin,
      stdout: this.options.stdout,
      exitOnCtrlC: this.options.exitOnCtrlC,
      onExit: this.unmount
    }, node);

    if (this.options.experimental) {
      _reconciler2.default.updateContainer(tree, this.container);
    } else {
      _reconciler.default.updateContainer(tree, this.container);
    }
  }

  unmount(error) {
    if (this.isUnmounted) {
      return;
    }

    this.onRender();
    this.unsubscribeExit(); // CIs don't handle erasing ansi escapes well, so it's better to
    // only render last frame of non-static output

    if (_isCi.default) {
      this.options.stdout.write(this.lastOutput + '\n');
    } else if (!this.options.debug) {
      this.log.done();
    }

    this.isUnmounted = true;

    if (this.options.experimental) {
      _reconciler2.default.updateContainer(null, this.container);
    } else {
      _reconciler.default.updateContainer(null, this.container);
    }

    _instances.default.delete(this.options.stdout);

    if (error instanceof Error) {
      this.rejectExitPromise(error);
    } else {
      this.resolveExitPromise();
    }
  }

  waitUntilExit() {
    return this.exitPromise;
  }

}

exports.default = Instance;
});

var render = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _instance = _interopRequireDefault(instance);

var _instances = _interopRequireDefault(instances);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = (node, options = {}) => {
  // Stream was passed instead of `options` object
  if (typeof options.write === 'function') {
    options = {
      stdout: options,
      stdin: process.stdin
    };
  }

  options = _objectSpread({
    stdout: process.stdout,
    stdin: process.stdin,
    debug: false,
    exitOnCtrlC: true,
    experimental: false
  }, options);
  let instance;

  if (_instances.default.has(options.stdout)) {
    instance = _instances.default.get(options.stdout);
  } else {
    instance = new _instance.default(options);

    _instances.default.set(options.stdout, instance);
  }

  instance.render(node);
  return {
    rerender: instance.render,
    unmount: () => instance.unmount(),
    waitUntilExit: instance.waitUntilExit,
    cleanup: () => _instances.default.delete(options.stdout)
  };
};

exports.default = _default;
});

var Box_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(react);

var _propTypes = _interopRequireDefault(propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Box extends _react.PureComponent {
  constructor() {
    super();
    this.nodeRef = _react.default.createRef();
  }

  render() {
    const _this$props = this.props,
          {
      children,
      unstable__transformChildren
    } = _this$props,
          style = _objectWithoutProperties(_this$props, ["children", "unstable__transformChildren"]);

    return _react.default.createElement("div", {
      ref: this.nodeRef,
      style: style,
      unstable__transformChildren: unstable__transformChildren
    }, children);
  }

  unstable__getComputedWidth() {
    return this.nodeRef.current.yogaNode.getComputedWidth();
  }

}

exports.default = Box;

_defineProperty(Box, "propTypes", {
  margin: _propTypes.default.number,
  marginX: _propTypes.default.number,
  marginY: _propTypes.default.number,
  marginTop: _propTypes.default.number,
  marginBottom: _propTypes.default.number,
  marginLeft: _propTypes.default.number,
  marginRight: _propTypes.default.number,
  padding: _propTypes.default.number,
  paddingX: _propTypes.default.number,
  paddingY: _propTypes.default.number,
  paddingTop: _propTypes.default.number,
  paddingBottom: _propTypes.default.number,
  paddingLeft: _propTypes.default.number,
  paddingRight: _propTypes.default.number,
  width: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
  minWidth: _propTypes.default.number,
  height: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
  minHeight: _propTypes.default.number,
  flexGrow: _propTypes.default.number,
  flexShrink: _propTypes.default.number,
  flexDirection: _propTypes.default.oneOf(['row', 'row-reverse', 'column', 'column-reverse']),
  flexBasis: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
  alignItems: _propTypes.default.oneOf(['stretch', 'flex-start', 'center', 'flex-end']),
  justifyContent: _propTypes.default.oneOf(['flex-start', 'center', 'flex-end', 'space-between', 'space-around']),
  textWrap: _propTypes.default.oneOf(['wrap', 'truncate', 'truncate-start', 'truncate-middle', 'truncate-end']),
  unstable__transformChildren: _propTypes.default.func,
  children: _propTypes.default.node
});

_defineProperty(Box, "defaultProps", {
  flexDirection: 'row',
  flexGrow: 0,
  flexShrink: 1
});
});

var Text_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(react);

var _propTypes = _interopRequireDefault(propTypes);

var _chalk = _interopRequireDefault(chalk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable camelcase */
const Text = ({
  bold,
  italic,
  underline,
  strikethrough,
  children,
  unstable__transformChildren
}) => {
  const transformChildren = children => {
    if (bold) {
      children = _chalk.default.bold(children);
    }

    if (italic) {
      children = _chalk.default.italic(children);
    }

    if (underline) {
      children = _chalk.default.underline(children);
    }

    if (strikethrough) {
      children = _chalk.default.strikethrough(children);
    }

    if (unstable__transformChildren) {
      children = unstable__transformChildren(children);
    }

    return children;
  };

  return _react.default.createElement("span", {
    style: {
      flexDirection: 'row'
    },
    unstable__transformChildren: transformChildren
  }, children);
};
/* eslint-disable react/boolean-prop-naming */


Text.propTypes = {
  bold: _propTypes.default.bool,
  italic: _propTypes.default.bool,
  underline: _propTypes.default.bool,
  strikethrough: _propTypes.default.bool,
  children: _propTypes.default.node.isRequired,
  unstable__transformChildren: _propTypes.default.func
};
/* eslint-enable react/boolean-prop-naming */

Text.defaultProps = {
  bold: false,
  italic: false,
  underline: false,
  strikethrough: false,
  unstable__transformChildren: undefined
};
var _default = Text;
exports.default = _default;
});

const arrify = value => {
	if (value === null || value === undefined) {
		return [];
	}

	if (Array.isArray(value)) {
		return value;
	}

	if (typeof value === 'string') {
		return [value];
	}

	if (typeof value[Symbol.iterator] === 'function') {
		return [...value];
	}

	return [value];
};

var arrify_1 = arrify;

var Color_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(react);

var _propTypes = _interopRequireDefault(propTypes);

var _arrify = _interopRequireDefault(arrify_1);

var _chalk = _interopRequireDefault(chalk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const methods = ['hex', 'hsl', 'hsv', 'hwb', 'rgb', 'keyword', 'bgHex', 'bgHsl', 'bgHsv', 'bgHwb', 'bgRgb', 'bgKeyword'];

const Color = (_ref) => {
  let {
    children
  } = _ref,
      colorProps = _objectWithoutProperties(_ref, ["children"]);

  if (children === '') {
    return null;
  }

  const transformChildren = children => {
    Object.keys(colorProps).forEach(method => {
      if (colorProps[method]) {
        if (methods.includes(method)) {
          children = _chalk.default[method](...(0, _arrify.default)(colorProps[method]))(children);
        } else if (typeof _chalk.default[method] === 'function') {
          children = _chalk.default[method](children);
        }
      }
    });
    return children;
  };

  return _react.default.createElement("span", {
    style: {
      flexDirection: 'row'
    },
    unstable__transformChildren: transformChildren
  }, children);
};

Color.propTypes = {
  children: _propTypes.default.node
};
Color.defaultProps = {
  children: ''
};
var _default = Color;
exports.default = _default;
});

var Static_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(react);

var _propTypes = _interopRequireDefault(propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const childrenToArray = children => Array.isArray(children) ? children : [children]; // This component allows developers to render output before main output from all the other components.
// The reason it's called <Static> is it's append-only output. Output from <Static> components
// is written permanently to stdout and is never updated afterwards. If <Static> component
// receives new children, Ink will detect the changes and write them to stdout.
// In order for this mechanism to work perfectly, <Static> children must never update their output
// once they've been appended to <Static>.
//
// A good example of where this component might be useful is interface like Jest's.
// When running tests, Jest keeps writing completed tests to output, while continuously
// rendering test stats at the end of the output.


class Static extends _react.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      lastIndex: null
    });
  }

  render() {
    const _this$props = this.props,
          {
      children
    } = _this$props,
          otherProps = _objectWithoutProperties(_this$props, ["children"]);

    const {
      lastIndex
    } = this.state;
    let newChildren = children;

    if (typeof lastIndex === 'number') {
      newChildren = childrenToArray(children).slice(lastIndex);
    }

    return _react.default.createElement("div", {
      unstable__static: true,
      style: _objectSpread({
        position: 'absolute',
        flexDirection: 'column'
      }, otherProps)
    }, newChildren);
  }

  componentDidMount() {
    this.saveLastIndex(this.props.children);
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevState.lastIndex === this.state.lastIndex) {
      this.saveLastIndex(this.props.children);
    }
  }

  saveLastIndex(children) {
    const nextIndex = childrenToArray(children).length;

    if (this.state.lastIndex !== nextIndex) {
      this.setState({
        lastIndex: nextIndex
      });
    }
  }

}

exports.default = Static;

_defineProperty(Static, "propTypes", {
  children: _propTypes.default.node
});
});

var useInput = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;





var _default = inputHandler => {
  const {
    stdin,
    setRawMode
  } = (0, react.useContext)(build.StdinContext);
  (0, react.useEffect)(() => {
    setRawMode(true);
    return () => {
      setRawMode(false);
    };
  }, [setRawMode]);
  (0, react.useEffect)(() => {
    const handleData = data => {
      let input = String(data);
      const key = {
        upArrow: input === '\u001B[A',
        downArrow: input === '\u001B[B',
        leftArrow: input === '\u001B[D',
        rightArrow: input === '\u001B[C',
        return: input === '\r',
        escape: input === '\u001B',
        ctrl: false,
        shift: false,
        meta: false
      }; // Copied from `keypress` module

      if (input <= '\u001A' && !key.return) {
        input = String.fromCharCode(input.charCodeAt(0) + 'a'.charCodeAt(0) - 1);
        key.ctrl = true;
      }

      if (input[0] === '\u001B') {
        input = input.slice(1);
        key.meta = true;
      }

      const isLatinUppercase = input >= 'A' && input <= 'Z';
      const isCyrillicUppercase = input >= 'А' && input <= 'Я';

      if (input.length === 1 && (isLatinUppercase || isCyrillicUppercase)) {
        key.shift = true;
      }

      inputHandler(input, key);
    };

    stdin.on('data', handleData);
    return () => {
      stdin.off('data', handleData);
    };
  }, [stdin, inputHandler]);
};

exports.default = _default;
});

var useApp = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;



var _AppContext = _interopRequireDefault(AppContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = () => (0, react.useContext)(_AppContext.default);

exports.default = _default;
});

var useStdin = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;



var _StdinContext = _interopRequireDefault(StdinContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = () => (0, react.useContext)(_StdinContext.default);

exports.default = _default;
});

var useStdout = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;



var _StdoutContext = _interopRequireDefault(StdoutContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = () => (0, react.useContext)(_StdoutContext.default);

exports.default = _default;
});

var build = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "render", {
  enumerable: true,
  get: function () {
    return _render.default;
  }
});
Object.defineProperty(exports, "Box", {
  enumerable: true,
  get: function () {
    return _Box.default;
  }
});
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function () {
    return _Text.default;
  }
});
Object.defineProperty(exports, "Color", {
  enumerable: true,
  get: function () {
    return _Color.default;
  }
});
Object.defineProperty(exports, "AppContext", {
  enumerable: true,
  get: function () {
    return _AppContext.default;
  }
});
Object.defineProperty(exports, "StdinContext", {
  enumerable: true,
  get: function () {
    return _StdinContext.default;
  }
});
Object.defineProperty(exports, "StdoutContext", {
  enumerable: true,
  get: function () {
    return _StdoutContext.default;
  }
});
Object.defineProperty(exports, "Static", {
  enumerable: true,
  get: function () {
    return _Static.default;
  }
});
Object.defineProperty(exports, "useInput", {
  enumerable: true,
  get: function () {
    return _useInput.default;
  }
});
Object.defineProperty(exports, "useApp", {
  enumerable: true,
  get: function () {
    return _useApp.default;
  }
});
Object.defineProperty(exports, "useStdin", {
  enumerable: true,
  get: function () {
    return _useStdin.default;
  }
});
Object.defineProperty(exports, "useStdout", {
  enumerable: true,
  get: function () {
    return _useStdout.default;
  }
});

var _render = _interopRequireDefault(render);

var _Box = _interopRequireDefault(Box_1);

var _Text = _interopRequireDefault(Text_1);

var _Color = _interopRequireDefault(Color_1);

var _AppContext = _interopRequireDefault(AppContext);

var _StdinContext = _interopRequireDefault(StdinContext);

var _StdoutContext = _interopRequireDefault(StdoutContext);

var _Static = _interopRequireDefault(Static_1);

var _useInput = _interopRequireDefault(useInput);

var _useApp = _interopRequireDefault(useApp);

var _useStdin = _interopRequireDefault(useStdin);

var _useStdout = _interopRequireDefault(useStdout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
});

// These weird castings we are doing in this file is because the way gatsby-cli works is that it starts with it's own store
// but then quickly swaps it out with the store from the installed gatsby. This would benefit from a refactor later on
// to not use it's own store temporarily.
// By the time this is actually running, it will become an `IGatsbyState`
const StoreStateContext = /*#__PURE__*/react.createContext(redux.getStore().getState());
const StoreStateProvider = ({
  children
}) => {
  const [state, setState] = react.useState(redux.getStore().getState());
  react.useEffect(() => redux.onLogAction(() => {
    setState(redux.getStore().getState());
  }), []);
  return /*#__PURE__*/react.createElement(StoreStateContext.Provider, {
    value: state
  }, children);
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// which causes unwanted lines in the output. An additional check for isCI helps.
// @see https://github.com/prettier/prettier/blob/36aeb4ce4f620023c8174e826d7208c0c64f1a0b/src/utils/is-tty.js

const isTTY = () => process.stdout.isTTY && !gatsbyCoreUtils.isCI();

var dots = {
  interval: 80,
  frames: ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"]
};
var dots2 = {
  interval: 80,
  frames: ["⣾", "⣽", "⣻", "⢿", "⡿", "⣟", "⣯", "⣷"]
};
var dots3 = {
  interval: 80,
  frames: ["⠋", "⠙", "⠚", "⠞", "⠖", "⠦", "⠴", "⠲", "⠳", "⠓"]
};
var dots4 = {
  interval: 80,
  frames: ["⠄", "⠆", "⠇", "⠋", "⠙", "⠸", "⠰", "⠠", "⠰", "⠸", "⠙", "⠋", "⠇", "⠆"]
};
var dots5 = {
  interval: 80,
  frames: ["⠋", "⠙", "⠚", "⠒", "⠂", "⠂", "⠒", "⠲", "⠴", "⠦", "⠖", "⠒", "⠐", "⠐", "⠒", "⠓", "⠋"]
};
var dots6 = {
  interval: 80,
  frames: ["⠁", "⠉", "⠙", "⠚", "⠒", "⠂", "⠂", "⠒", "⠲", "⠴", "⠤", "⠄", "⠄", "⠤", "⠴", "⠲", "⠒", "⠂", "⠂", "⠒", "⠚", "⠙", "⠉", "⠁"]
};
var dots7 = {
  interval: 80,
  frames: ["⠈", "⠉", "⠋", "⠓", "⠒", "⠐", "⠐", "⠒", "⠖", "⠦", "⠤", "⠠", "⠠", "⠤", "⠦", "⠖", "⠒", "⠐", "⠐", "⠒", "⠓", "⠋", "⠉", "⠈"]
};
var dots8 = {
  interval: 80,
  frames: ["⠁", "⠁", "⠉", "⠙", "⠚", "⠒", "⠂", "⠂", "⠒", "⠲", "⠴", "⠤", "⠄", "⠄", "⠤", "⠠", "⠠", "⠤", "⠦", "⠖", "⠒", "⠐", "⠐", "⠒", "⠓", "⠋", "⠉", "⠈", "⠈"]
};
var dots9 = {
  interval: 80,
  frames: ["⢹", "⢺", "⢼", "⣸", "⣇", "⡧", "⡗", "⡏"]
};
var dots10 = {
  interval: 80,
  frames: ["⢄", "⢂", "⢁", "⡁", "⡈", "⡐", "⡠"]
};
var dots11 = {
  interval: 100,
  frames: ["⠁", "⠂", "⠄", "⡀", "⢀", "⠠", "⠐", "⠈"]
};
var dots12 = {
  interval: 80,
  frames: ["⢀⠀", "⡀⠀", "⠄⠀", "⢂⠀", "⡂⠀", "⠅⠀", "⢃⠀", "⡃⠀", "⠍⠀", "⢋⠀", "⡋⠀", "⠍⠁", "⢋⠁", "⡋⠁", "⠍⠉", "⠋⠉", "⠋⠉", "⠉⠙", "⠉⠙", "⠉⠩", "⠈⢙", "⠈⡙", "⢈⠩", "⡀⢙", "⠄⡙", "⢂⠩", "⡂⢘", "⠅⡘", "⢃⠨", "⡃⢐", "⠍⡐", "⢋⠠", "⡋⢀", "⠍⡁", "⢋⠁", "⡋⠁", "⠍⠉", "⠋⠉", "⠋⠉", "⠉⠙", "⠉⠙", "⠉⠩", "⠈⢙", "⠈⡙", "⠈⠩", "⠀⢙", "⠀⡙", "⠀⠩", "⠀⢘", "⠀⡘", "⠀⠨", "⠀⢐", "⠀⡐", "⠀⠠", "⠀⢀", "⠀⡀"]
};
var line = {
  interval: 130,
  frames: ["-", "\\", "|", "/"]
};
var line2 = {
  interval: 100,
  frames: ["⠂", "-", "–", "—", "–", "-"]
};
var pipe = {
  interval: 100,
  frames: ["┤", "┘", "┴", "└", "├", "┌", "┬", "┐"]
};
var simpleDots = {
  interval: 400,
  frames: [".  ", ".. ", "...", "   "]
};
var simpleDotsScrolling = {
  interval: 200,
  frames: [".  ", ".. ", "...", " ..", "  .", "   "]
};
var star = {
  interval: 70,
  frames: ["✶", "✸", "✹", "✺", "✹", "✷"]
};
var star2 = {
  interval: 80,
  frames: ["+", "x", "*"]
};
var flip = {
  interval: 70,
  frames: ["_", "_", "_", "-", "`", "`", "'", "´", "-", "_", "_", "_"]
};
var hamburger = {
  interval: 100,
  frames: ["☱", "☲", "☴"]
};
var growVertical = {
  interval: 120,
  frames: ["▁", "▃", "▄", "▅", "▆", "▇", "▆", "▅", "▄", "▃"]
};
var growHorizontal = {
  interval: 120,
  frames: ["▏", "▎", "▍", "▌", "▋", "▊", "▉", "▊", "▋", "▌", "▍", "▎"]
};
var balloon = {
  interval: 140,
  frames: [" ", ".", "o", "O", "@", "*", " "]
};
var balloon2 = {
  interval: 120,
  frames: [".", "o", "O", "°", "O", "o", "."]
};
var noise = {
  interval: 100,
  frames: ["▓", "▒", "░"]
};
var bounce = {
  interval: 120,
  frames: ["⠁", "⠂", "⠄", "⠂"]
};
var boxBounce = {
  interval: 120,
  frames: ["▖", "▘", "▝", "▗"]
};
var boxBounce2 = {
  interval: 100,
  frames: ["▌", "▀", "▐", "▄"]
};
var triangle = {
  interval: 50,
  frames: ["◢", "◣", "◤", "◥"]
};
var arc = {
  interval: 100,
  frames: ["◜", "◠", "◝", "◞", "◡", "◟"]
};
var circle = {
  interval: 120,
  frames: ["◡", "⊙", "◠"]
};
var squareCorners = {
  interval: 180,
  frames: ["◰", "◳", "◲", "◱"]
};
var circleQuarters = {
  interval: 120,
  frames: ["◴", "◷", "◶", "◵"]
};
var circleHalves = {
  interval: 50,
  frames: ["◐", "◓", "◑", "◒"]
};
var squish = {
  interval: 100,
  frames: ["╫", "╪"]
};
var toggle = {
  interval: 250,
  frames: ["⊶", "⊷"]
};
var toggle2 = {
  interval: 80,
  frames: ["▫", "▪"]
};
var toggle3 = {
  interval: 120,
  frames: ["□", "■"]
};
var toggle4 = {
  interval: 100,
  frames: ["■", "□", "▪", "▫"]
};
var toggle5 = {
  interval: 100,
  frames: ["▮", "▯"]
};
var toggle6 = {
  interval: 300,
  frames: ["ဝ", "၀"]
};
var toggle7 = {
  interval: 80,
  frames: ["⦾", "⦿"]
};
var toggle8 = {
  interval: 100,
  frames: ["◍", "◌"]
};
var toggle9 = {
  interval: 100,
  frames: ["◉", "◎"]
};
var toggle10 = {
  interval: 100,
  frames: ["㊂", "㊀", "㊁"]
};
var toggle11 = {
  interval: 50,
  frames: ["⧇", "⧆"]
};
var toggle12 = {
  interval: 120,
  frames: ["☗", "☖"]
};
var toggle13 = {
  interval: 80,
  frames: ["=", "*", "-"]
};
var arrow = {
  interval: 100,
  frames: ["←", "↖", "↑", "↗", "→", "↘", "↓", "↙"]
};
var arrow2 = {
  interval: 80,
  frames: ["⬆️ ", "↗️ ", "➡️ ", "↘️ ", "⬇️ ", "↙️ ", "⬅️ ", "↖️ "]
};
var arrow3 = {
  interval: 120,
  frames: ["▹▹▹▹▹", "▸▹▹▹▹", "▹▸▹▹▹", "▹▹▸▹▹", "▹▹▹▸▹", "▹▹▹▹▸"]
};
var bouncingBar = {
  interval: 80,
  frames: ["[    ]", "[=   ]", "[==  ]", "[=== ]", "[ ===]", "[  ==]", "[   =]", "[    ]", "[   =]", "[  ==]", "[ ===]", "[====]", "[=== ]", "[==  ]", "[=   ]"]
};
var bouncingBall = {
  interval: 80,
  frames: ["( ●    )", "(  ●   )", "(   ●  )", "(    ● )", "(     ●)", "(    ● )", "(   ●  )", "(  ●   )", "( ●    )", "(●     )"]
};
var smiley = {
  interval: 200,
  frames: ["😄 ", "😝 "]
};
var monkey = {
  interval: 300,
  frames: ["🙈 ", "🙈 ", "🙉 ", "🙊 "]
};
var hearts = {
  interval: 100,
  frames: ["💛 ", "💙 ", "💜 ", "💚 ", "❤️ "]
};
var clock = {
  interval: 100,
  frames: ["🕛 ", "🕐 ", "🕑 ", "🕒 ", "🕓 ", "🕔 ", "🕕 ", "🕖 ", "🕗 ", "🕘 ", "🕙 ", "🕚 "]
};
var earth = {
  interval: 180,
  frames: ["🌍 ", "🌎 ", "🌏 "]
};
var moon = {
  interval: 80,
  frames: ["🌑 ", "🌒 ", "🌓 ", "🌔 ", "🌕 ", "🌖 ", "🌗 ", "🌘 "]
};
var runner = {
  interval: 140,
  frames: ["🚶 ", "🏃 "]
};
var pong = {
  interval: 80,
  frames: ["▐⠂       ▌", "▐⠈       ▌", "▐ ⠂      ▌", "▐ ⠠      ▌", "▐  ⡀     ▌", "▐  ⠠     ▌", "▐   ⠂    ▌", "▐   ⠈    ▌", "▐    ⠂   ▌", "▐    ⠠   ▌", "▐     ⡀  ▌", "▐     ⠠  ▌", "▐      ⠂ ▌", "▐      ⠈ ▌", "▐       ⠂▌", "▐       ⠠▌", "▐       ⡀▌", "▐      ⠠ ▌", "▐      ⠂ ▌", "▐     ⠈  ▌", "▐     ⠂  ▌", "▐    ⠠   ▌", "▐    ⡀   ▌", "▐   ⠠    ▌", "▐   ⠂    ▌", "▐  ⠈     ▌", "▐  ⠂     ▌", "▐ ⠠      ▌", "▐ ⡀      ▌", "▐⠠       ▌"]
};
var shark = {
  interval: 120,
  frames: ["▐|\\____________▌", "▐_|\\___________▌", "▐__|\\__________▌", "▐___|\\_________▌", "▐____|\\________▌", "▐_____|\\_______▌", "▐______|\\______▌", "▐_______|\\_____▌", "▐________|\\____▌", "▐_________|\\___▌", "▐__________|\\__▌", "▐___________|\\_▌", "▐____________|\\▌", "▐____________/|▌", "▐___________/|_▌", "▐__________/|__▌", "▐_________/|___▌", "▐________/|____▌", "▐_______/|_____▌", "▐______/|______▌", "▐_____/|_______▌", "▐____/|________▌", "▐___/|_________▌", "▐__/|__________▌", "▐_/|___________▌", "▐/|____________▌"]
};
var dqpb = {
  interval: 100,
  frames: ["d", "q", "p", "b"]
};
var weather = {
  interval: 100,
  frames: ["☀️ ", "☀️ ", "☀️ ", "🌤 ", "⛅️ ", "🌥 ", "☁️ ", "🌧 ", "🌨 ", "🌧 ", "🌨 ", "🌧 ", "🌨 ", "⛈ ", "🌨 ", "🌧 ", "🌨 ", "☁️ ", "🌥 ", "⛅️ ", "🌤 ", "☀️ ", "☀️ "]
};
var christmas = {
  interval: 400,
  frames: ["🌲", "🎄"]
};
var grenade = {
  interval: 80,
  frames: ["،   ", "′   ", " ´ ", " ‾ ", "  ⸌", "  ⸊", "  |", "  ⁎", "  ⁕", " ෴ ", "  ⁓", "   ", "   ", "   "]
};
var point = {
  interval: 125,
  frames: ["∙∙∙", "●∙∙", "∙●∙", "∙∙●", "∙∙∙"]
};
var layer = {
  interval: 150,
  frames: ["-", "=", "≡"]
};
var spinners = {
  dots: dots,
  dots2: dots2,
  dots3: dots3,
  dots4: dots4,
  dots5: dots5,
  dots6: dots6,
  dots7: dots7,
  dots8: dots8,
  dots9: dots9,
  dots10: dots10,
  dots11: dots11,
  dots12: dots12,
  line: line,
  line2: line2,
  pipe: pipe,
  simpleDots: simpleDots,
  simpleDotsScrolling: simpleDotsScrolling,
  star: star,
  star2: star2,
  flip: flip,
  hamburger: hamburger,
  growVertical: growVertical,
  growHorizontal: growHorizontal,
  balloon: balloon,
  balloon2: balloon2,
  noise: noise,
  bounce: bounce,
  boxBounce: boxBounce,
  boxBounce2: boxBounce2,
  triangle: triangle,
  arc: arc,
  circle: circle,
  squareCorners: squareCorners,
  circleQuarters: circleQuarters,
  circleHalves: circleHalves,
  squish: squish,
  toggle: toggle,
  toggle2: toggle2,
  toggle3: toggle3,
  toggle4: toggle4,
  toggle5: toggle5,
  toggle6: toggle6,
  toggle7: toggle7,
  toggle8: toggle8,
  toggle9: toggle9,
  toggle10: toggle10,
  toggle11: toggle11,
  toggle12: toggle12,
  toggle13: toggle13,
  arrow: arrow,
  arrow2: arrow2,
  arrow3: arrow3,
  bouncingBar: bouncingBar,
  bouncingBall: bouncingBall,
  smiley: smiley,
  monkey: monkey,
  hearts: hearts,
  clock: clock,
  earth: earth,
  moon: moon,
  runner: runner,
  pong: pong,
  shark: shark,
  dqpb: dqpb,
  weather: weather,
  christmas: christmas,
  grenade: grenade,
  point: point,
  layer: layer
};

var spinners$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	dots: dots,
	dots2: dots2,
	dots3: dots3,
	dots4: dots4,
	dots5: dots5,
	dots6: dots6,
	dots7: dots7,
	dots8: dots8,
	dots9: dots9,
	dots10: dots10,
	dots11: dots11,
	dots12: dots12,
	line: line,
	line2: line2,
	pipe: pipe,
	simpleDots: simpleDots,
	simpleDotsScrolling: simpleDotsScrolling,
	star: star,
	star2: star2,
	flip: flip,
	hamburger: hamburger,
	growVertical: growVertical,
	growHorizontal: growHorizontal,
	balloon: balloon,
	balloon2: balloon2,
	noise: noise,
	bounce: bounce,
	boxBounce: boxBounce,
	boxBounce2: boxBounce2,
	triangle: triangle,
	arc: arc,
	circle: circle,
	squareCorners: squareCorners,
	circleQuarters: circleQuarters,
	circleHalves: circleHalves,
	squish: squish,
	toggle: toggle,
	toggle2: toggle2,
	toggle3: toggle3,
	toggle4: toggle4,
	toggle5: toggle5,
	toggle6: toggle6,
	toggle7: toggle7,
	toggle8: toggle8,
	toggle9: toggle9,
	toggle10: toggle10,
	toggle11: toggle11,
	toggle12: toggle12,
	toggle13: toggle13,
	arrow: arrow,
	arrow2: arrow2,
	arrow3: arrow3,
	bouncingBar: bouncingBar,
	bouncingBall: bouncingBall,
	smiley: smiley,
	monkey: monkey,
	hearts: hearts,
	clock: clock,
	earth: earth,
	moon: moon,
	runner: runner,
	pong: pong,
	shark: shark,
	dqpb: dqpb,
	weather: weather,
	christmas: christmas,
	grenade: grenade,
	point: point,
	layer: layer,
	'default': spinners
});

var require$$0 = getCjsExportFromNamespace(spinners$1);

var cliSpinners = require$$0;

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}





const {
  Box
} = build;



class Spinner extends react.Component {
  constructor(...args) {
    super(...args);

    _defineProperty$1(this, "state", {
      frame: 0
    });

    _defineProperty$1(this, "switchFrame", () => {
      const {
        frame
      } = this.state;
      const spinner = this.getSpinner();
      const isLastFrame = frame === spinner.frames.length - 1;
      const nextFrame = isLastFrame ? 0 : frame + 1;
      this.setState({
        frame: nextFrame
      });
    });
  }

  render() {
    const spinner = this.getSpinner();
    return /*#__PURE__*/react.createElement(Box, null, spinner.frames[this.state.frame]);
  }

  componentDidMount() {
    const spinner = this.getSpinner();
    this.timer = setInterval(this.switchFrame, spinner.interval);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  getSpinner() {
    return cliSpinners[this.props.type] || cliSpinners.dots;
  }

}

_defineProperty$1(Spinner, "propTypes", {
  type: propTypes.string
});

_defineProperty$1(Spinner, "defaultProps", {
  type: 'dots'
});

var build$1 = Spinner;
var _default$b = Spinner;
build$1.default = _default$b;

function Spinner$1({
  text,
  statusText
}) {
  let label = text;

  if (statusText) {
    label += ` — ${statusText}`;
  }

  return /*#__PURE__*/react.createElement(build.Box, null, /*#__PURE__*/react.createElement(build$1, {
    type: "dots"
  }), " ", label);
}

function calcElapsedTime(startTime) {
  const elapsed = process.hrtime(startTime);
  return convertHrtime(elapsed)[`seconds`].toFixed(3);
}

const maxWidth = 30;
const minWidth = 10;

const getLength = prop => String(prop).length;

function ProgressBar({
  message,
  current,
  total,
  startTime
}) {
  const percentage = total ? Math.round(current / total * 100) : 0;
  const terminalWidth = process.stdout.columns || 80;
  const availableWidth = terminalWidth - getLength(message) - getLength(current) - getLength(total) - getLength(percentage) - 11; // margins + extra characters

  const progressBarWidth = Math.max(minWidth, Math.min(maxWidth, availableWidth));
  return /*#__PURE__*/react.createElement(build.Box, {
    flexDirection: "row"
  }, /*#__PURE__*/react.createElement(build.Box, {
    marginRight: 3,
    width: progressBarWidth
  }, "[", /*#__PURE__*/react.createElement(build.Box, {
    width: progressBarWidth - 2
  }, `=`.repeat((progressBarWidth - 2) * percentage / 100)), "]"), /*#__PURE__*/react.createElement(build.Box, {
    marginRight: 1
  }, calcElapsedTime(startTime), " s"), /*#__PURE__*/react.createElement(build.Box, {
    marginRight: 1
  }, current, "/", total), /*#__PURE__*/react.createElement(build.Box, {
    marginRight: 1
  }, `` + percentage, "%"), /*#__PURE__*/react.createElement(build.Box, {
    textWrap: "truncate"
  }, message));
}

const ColorSwitcher = ({
  children,
  ...props
}) => /*#__PURE__*/react.createElement(build.Color, props, children);
const createLabel = (text, color) => (...props) => /*#__PURE__*/react.createElement(ColorSwitcher, {
  [color]: true,
  ...props
}, text);

let Actions;

(function (Actions) {
  Actions["LogAction"] = "LOG_ACTION";
  Actions["SetStatus"] = "SET_STATUS";
  Actions["Log"] = "LOG";
  Actions["SetLogs"] = "SET_LOGS";
  Actions["StartActivity"] = "ACTIVITY_START";
  Actions["EndActivity"] = "ACTIVITY_END";
  Actions["UpdateActivity"] = "ACTIVITY_UPDATE";
  Actions["PendingActivity"] = "ACTIVITY_PENDING";
  Actions["CancelActivity"] = "ACTIVITY_CANCEL";
  Actions["ActivityErrored"] = "ACTIVITY_ERRORED";
})(Actions || (Actions = {}));

let LogLevels;

(function (LogLevels) {
  LogLevels["Debug"] = "DEBUG";
  LogLevels["Success"] = "SUCCESS";
  LogLevels["Info"] = "INFO";
  LogLevels["Warning"] = "WARNING";
  LogLevels["Log"] = "LOG";
  LogLevels["Error"] = "ERROR";
})(LogLevels || (LogLevels = {}));

let ActivityLogLevels;

(function (ActivityLogLevels) {
  ActivityLogLevels["Success"] = "ACTIVITY_SUCCESS";
  ActivityLogLevels["Failed"] = "ACTIVITY_FAILED";
  ActivityLogLevels["Interrupted"] = "ACTIVITY_INTERRUPTED";
})(ActivityLogLevels || (ActivityLogLevels = {}));

let ActivityStatuses;

(function (ActivityStatuses) {
  ActivityStatuses["InProgress"] = "IN_PROGRESS";
  ActivityStatuses["NotStarted"] = "NOT_STARTED";
  ActivityStatuses["Interrupted"] = "INTERRUPTED";
  ActivityStatuses["Failed"] = "FAILED";
  ActivityStatuses["Success"] = "SUCCESS";
  ActivityStatuses["Cancelled"] = "CANCELLED";
})(ActivityStatuses || (ActivityStatuses = {}));

let ActivityTypes;

(function (ActivityTypes) {
  ActivityTypes["Spinner"] = "spinner";
  ActivityTypes["Hidden"] = "hidden";
  ActivityTypes["Progress"] = "progress";
  ActivityTypes["Pending"] = "pending";
})(ActivityTypes || (ActivityTypes = {}));

const getLabel = level => {
  switch (level) {
    case ActivityLogLevels.Success:
    case LogLevels.Success:
      return createLabel(`success`, `green`);

    case LogLevels.Warning:
      return createLabel(`warn`, `yellow`);

    case LogLevels.Debug:
      return createLabel(`verbose`, `gray`);

    case LogLevels.Info:
      return createLabel(`info`, `blue`);

    case ActivityLogLevels.Failed:
      return createLabel(`failed`, `red`);

    case ActivityLogLevels.Interrupted:
      return createLabel(`not finished`, `gray`);

    default:
      return createLabel(level, `blue`);
  }
};

const Message = /*#__PURE__*/react.memo(({
  level,
  text,
  duration,
  statusText
}) => {
  let message = text;

  if (duration) {
    message += ` - ${duration.toFixed(3)}s`;
  }

  if (statusText) {
    message += ` - ${statusText}`;
  }

  if (!level || level === `LOG`) {
    return /*#__PURE__*/react.createElement(react.Fragment, null, message);
  }

  const TextLabel = getLabel(level);
  return /*#__PURE__*/react.createElement(build.Box, {
    textWrap: "wrap",
    flexDirection: "row"
  }, /*#__PURE__*/react.createElement(TextLabel, null), ` `, message);
});

const File = ({
  filePath,
  location
}) => {
  const lineNumber = location === null || location === void 0 ? void 0 : location.start.line;
  let locString = ``;

  if (typeof lineNumber !== `undefined`) {
    locString += `:${lineNumber}`;
    const columnNumber = location === null || location === void 0 ? void 0 : location.start.column;

    if (typeof columnNumber !== `undefined`) {
      locString += `:${columnNumber}`;
    }
  }

  return /*#__PURE__*/react.createElement(build.Color, {
    blue: true
  }, path.relative(process.cwd(), filePath), locString);
};

const DocsLink = ({
  docsUrl
}) => {
  // TODO: when there's no specific docsUrl, add helpful message describing how
  // to submit an issue
  if (docsUrl === `https://gatsby.dev/issue-how-to`) return null;
  return /*#__PURE__*/react.createElement(build.Box, {
    marginTop: 1
  }, "See our docs page for more info on this error: ", docsUrl);
};

const Error$1 = /*#__PURE__*/react.memo(({
  details
}) =>
/*#__PURE__*/
// const stackLength = get(details, `stack.length`, 0
react.createElement(build.Box, {
  marginY: 1,
  flexDirection: "column"
}, /*#__PURE__*/react.createElement(build.Box, {
  flexDirection: "column"
}, /*#__PURE__*/react.createElement(build.Box, {
  flexDirection: "column"
}, /*#__PURE__*/react.createElement(build.Box, null, /*#__PURE__*/react.createElement(build.Box, {
  marginRight: 1
}, /*#__PURE__*/react.createElement(build.Color, {
  black: true,
  bgRed: true
}, ` ${details.level} `, details.code ? `#${details.code} ` : ``), /*#__PURE__*/react.createElement(build.Color, {
  red: true
}, details.type ? ` ` + details.type : ``))), /*#__PURE__*/react.createElement(build.Box, {
  marginTop: 1
}, details.text), details.filePath && /*#__PURE__*/react.createElement(build.Box, {
  marginTop: 1
}, "File:", ` `, /*#__PURE__*/react.createElement(File, {
  filePath: details.filePath,
  location: details.location
}))), /*#__PURE__*/react.createElement(DocsLink, {
  docsUrl: details.docsUrl
}))));

const getLabel$1 = level => {
  switch (level) {
    case ActivityStatuses.InProgress:
      return createLabel(`In Progress`, `white`);

    case ActivityStatuses.Interrupted:
      return createLabel(`Interrupted`, `gray`);

    case ActivityStatuses.Failed:
      return createLabel(`Failed`, `red`);

    case ActivityStatuses.Success:
      return createLabel(`Success`, `green`);

    default:
      return createLabel(level, `white`);
  }
}; // Track the width and height of the terminal. Responsive app design baby!


const useTerminalResize = () => {
  const {
    stdout
  } = react.useContext(build.StdoutContext);
  const [sizes, setSizes] = react.useState([stdout.columns, stdout.rows]);
  react.useEffect(() => {
    const resizeListener = () => {
      setSizes([stdout.columns, stdout.rows]);
    };

    stdout.on(`resize`, resizeListener);
    return () => {
      stdout.off(`resize`, resizeListener);
    };
  }, [stdout]);
  return sizes;
};

const Develop = ({
  pagesCount,
  appName,
  status
}) => {
  const [width] = useTerminalResize();
  const StatusLabel = getLabel$1(status);
  return /*#__PURE__*/react.createElement(build.Box, {
    flexDirection: "column",
    marginTop: 2
  }, /*#__PURE__*/react.createElement(build.Box, {
    textWrap: `truncate`
  }, `—`.repeat(width)), /*#__PURE__*/react.createElement(build.Box, {
    height: 1,
    flexDirection: "row"
  }, /*#__PURE__*/react.createElement(StatusLabel, null), /*#__PURE__*/react.createElement(build.Box, {
    flexGrow: 1
  }), /*#__PURE__*/react.createElement(build.Color, null, appName), /*#__PURE__*/react.createElement(build.Box, {
    flexGrow: 1
  }), /*#__PURE__*/react.createElement(build.Color, null, pagesCount, " pages")));
};

const ConnectedDevelop = () => {
  var _state$pages, _state$program, _state$logs;

  const state = react.useContext(StoreStateContext);
  return /*#__PURE__*/react.createElement(Develop, {
    pagesCount: ((_state$pages = state.pages) === null || _state$pages === void 0 ? void 0 : _state$pages.size) || 0,
    appName: ((_state$program = state.program) === null || _state$program === void 0 ? void 0 : _state$program.sitePackageJson.name) || ``,
    status: ((_state$logs = state.logs) === null || _state$logs === void 0 ? void 0 : _state$logs.status) || ``
  });
};

const showProgress = isTTY();

class CLI extends react.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      hasError: false
    });

    _defineProperty(this, "memoizedReactElementsForMessages", []);
  }

  componentDidCatch(error, info) {
    gatsbyTelemetry.trackBuildError(`INK`, {
      error: {
        error: {
          stack: info.componentStack
        },
        text: error.message
      }
    });
  }

  static getDerivedStateFromError(error) {
    return {
      hasError: true,
      error
    };
  }

  render() {
    const {
      logs: {
        messages,
        activities
      },
      showStatusBar
    } = this.props;
    const {
      hasError,
      error
    } = this.state;

    if (hasError && error) {
      // You can render any custom fallback UI
      return /*#__PURE__*/react.createElement(build.Box, {
        flexDirection: "row"
      }, /*#__PURE__*/react.createElement(Message, {
        level: ActivityLogLevels.Failed,
        text: `We've encountered an error: ${error.message}`
      }));
    }
    /*
      Only operation on messages array is to push new message into it. Once
      message is there it can't change. Because of that we can do single
      transform from message object to react element and store it.
      This will avoid calling React.createElement completely for every message
      that can't change.
    */


    if (messages.length > this.memoizedReactElementsForMessages.length) {
      for (let index = this.memoizedReactElementsForMessages.length; index < messages.length; index++) {
        const msg = messages[index];
        this.memoizedReactElementsForMessages.push(msg.level === `ERROR` ? /*#__PURE__*/react.createElement(Error$1, {
          details: msg,
          key: index
        }) : /*#__PURE__*/react.createElement(Message, _extends({
          key: index
        }, msg)));
      }
    }

    const spinners = [];
    const progressBars = [];

    if (showProgress) {
      Object.keys(activities).forEach(activityName => {
        const activity = activities[activityName];

        if (activity.status !== `IN_PROGRESS`) {
          return;
        }

        if (activity.type === `spinner`) {
          spinners.push(activity);
        }

        if (activity.type === `progress` && activity.startTime) {
          progressBars.push(activity);
        }
      });
    }

    return /*#__PURE__*/react.createElement(build.Box, {
      flexDirection: "column"
    }, /*#__PURE__*/react.createElement(build.Box, {
      flexDirection: "column"
    }, /*#__PURE__*/react.createElement(build.Static, null, this.memoizedReactElementsForMessages), spinners.map(activity => /*#__PURE__*/react.createElement(Spinner$1, _extends({
      key: activity.id
    }, activity))), progressBars.map(activity => /*#__PURE__*/react.createElement(ProgressBar, {
      key: activity.id,
      message: activity.text,
      total: activity.total || 0,
      current: activity.current || 0,
      startTime: activity.startTime || [0, 0]
    }))), showStatusBar && /*#__PURE__*/react.createElement(ConnectedDevelop, null));
  }

}

const ConnectedCLI = () => {
  var _state$program, _state$program$_, _state$program2;

  const state = react.useContext(StoreStateContext);
  const showStatusBar = ((_state$program = state.program) === null || _state$program === void 0 ? void 0 : (_state$program$_ = _state$program._) === null || _state$program$_ === void 0 ? void 0 : _state$program$_[0]) === `develop` && ((_state$program2 = state.program) === null || _state$program2 === void 0 ? void 0 : _state$program2.status) === `BOOTSTRAP_FINISHED`;
  return /*#__PURE__*/react.createElement(CLI, {
    showStatusBar: Boolean(showStatusBar),
    logs: state.logs
  });
};

function initializeINKLogger() {
  build.render( /*#__PURE__*/react.createElement(StoreStateProvider, null, /*#__PURE__*/react.createElement(ConnectedCLI, null)));
}

exports.initializeINKLogger = initializeINKLogger;
