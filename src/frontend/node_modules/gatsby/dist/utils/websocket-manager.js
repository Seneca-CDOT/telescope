"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.websocketManager = exports.WebsocketManager = void 0;

var _path = _interopRequireDefault(require("path"));

var _redux = require("../redux");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _pageData = require("../utils/page-data");

var _gatsbyTelemetry = _interopRequireDefault(require("gatsby-telemetry"));

var _url = _interopRequireDefault(require("url"));

var _crypto = require("crypto");

var _normalizePagePath = require("./normalize-page-path");

var _socket = _interopRequireDefault(require("socket.io"));

/* eslint-disable no-invalid-this */

/**
 * Get page query result for given page path.
 * @param {string} pagePath Path to a page.
 */
async function getPageData(pagePath) {
  const {
    program,
    pages
  } = _redux.store.getState();

  const publicDir = _path.default.join(program.directory, `public`);

  const result = {
    id: pagePath,
    result: undefined
  };

  if (pages.has((0, _normalizePagePath.denormalizePagePath)(pagePath)) || pages.has(pagePath)) {
    try {
      const pageData = await (0, _pageData.readPageData)(publicDir, pagePath);
      result.result = pageData;
    } catch (err) {
      throw new Error(`Error loading a result for the page query in "${pagePath}". Query was not run and no cached result was found.`);
    }
  }

  return result;
}
/**
 * Get page query result for given page path.
 * @param {string} pagePath Path to a page.
 */


async function getStaticQueryData(staticQueryId) {
  const {
    program
  } = _redux.store.getState();

  const publicDir = _path.default.join(program.directory, `public`);

  const filePath = _path.default.join(publicDir, `page-data`, `sq`, `d`, `${staticQueryId}.json`);

  const result = {
    id: staticQueryId,
    result: undefined
  };

  if (await _fsExtra.default.pathExists(filePath)) {
    try {
      const fileResult = await _fsExtra.default.readJson(filePath);
      result.result = fileResult;
    } catch (err) {// ignore errors
    }
  }

  return result;
}

function hashPaths(paths) {
  return paths.map(path => (0, _crypto.createHash)(`sha256`).update(path).digest(`hex`));
}

const getRoomNameFromPath = path => `path-${path}`;

class WebsocketManager {
  constructor() {
    this.activePaths = new Set();
    this.connectedClients = 0;
    this.errors = new Map();
    this.pageResults = new Map();
    this.staticQueryResults = new Map();

    this.init = ({
      server
    }) => {
      this.websocket = (0, _socket.default)(server, {
        // we see ping-pong timeouts on gatsby-cloud when socket.io is running for a while
        // increasing it should help
        // @see https://github.com/socketio/socket.io/issues/3259#issuecomment-448058937
        pingTimeout: 30000
      });
      this.websocket.on(`connection`, socket => {
        var _socket$handshake, _socket$handshake$hea;

        let activePath = null;

        if (socket === null || socket === void 0 ? void 0 : (_socket$handshake = socket.handshake) === null || _socket$handshake === void 0 ? void 0 : (_socket$handshake$hea = _socket$handshake.headers) === null || _socket$handshake$hea === void 0 ? void 0 : _socket$handshake$hea.referer) {
          const path = _url.default.parse(socket.handshake.headers.referer).path;

          if (path) {
            activePath = path;
            this.activePaths.add(path);
          }
        }

        this.connectedClients += 1;
        this.errors.forEach((message, errorID) => {
          socket.send({
            type: `overlayError`,
            payload: {
              id: errorID,
              message
            }
          });
        });

        const leaveRoom = path => {
          socket.leave(getRoomNameFromPath(path));
          if (!this.websocket) return;
          const leftRoom = this.websocket.sockets.adapter.rooms[getRoomNameFromPath(path)];

          if (!leftRoom || leftRoom.length === 0) {
            this.activePaths.delete(path);
          }
        };

        const getDataForPath = async path => {
          var _pageData$result$stat, _pageData$result;

          let pageData = this.pageResults.get(path);

          if (!pageData) {
            try {
              pageData = await getPageData(path);
              this.pageResults.set(path, pageData);
            } catch (err) {
              console.log(err.message);
              return;
            }
          }

          const staticQueryHashes = (_pageData$result$stat = (_pageData$result = pageData.result) === null || _pageData$result === void 0 ? void 0 : _pageData$result.staticQueryHashes) !== null && _pageData$result$stat !== void 0 ? _pageData$result$stat : [];
          await Promise.all(staticQueryHashes.map(async queryId => {
            let staticQueryResult = this.staticQueryResults.get(queryId);

            if (!staticQueryResult) {
              staticQueryResult = await getStaticQueryData(queryId);
              this.staticQueryResults.set(queryId, staticQueryResult);
            }

            socket.send({
              type: `staticQueryResult`,
              payload: staticQueryResult
            });
          }));
          socket.send({
            type: `pageQueryResult`,
            why: `getDataForPath`,
            payload: pageData
          });

          if (this.connectedClients > 0) {
            _gatsbyTelemetry.default.trackCli(`WEBSOCKET_PAGE_DATA_UPDATE`, {
              siteMeasurements: {
                clientsCount: this.connectedClients,
                paths: hashPaths(Array.from(this.activePaths))
              }
            }, {
              debounce: true
            });
          }
        };

        socket.on(`getDataForPath`, getDataForPath);
        socket.on(`registerPath`, path => {
          socket.join(getRoomNameFromPath(path));

          if (path) {
            activePath = path;
            this.activePaths.add(path);
          }
        });
        socket.on(`disconnect`, () => {
          if (activePath) leaveRoom(activePath);
          this.connectedClients -= 1;
        });
        socket.on(`unregisterPath`, path => {
          leaveRoom(path);
        });
      });
      return this.websocket;
    };

    this.getSocket = () => this.websocket;

    this.emitStaticQueryData = data => {
      this.staticQueryResults.set(data.id, data);

      if (this.websocket) {
        this.websocket.send({
          type: `staticQueryResult`,
          payload: data
        });

        if (this.connectedClients > 0) {
          _gatsbyTelemetry.default.trackCli(`WEBSOCKET_EMIT_STATIC_PAGE_DATA_UPDATE`, {
            siteMeasurements: {
              clientsCount: this.connectedClients,
              paths: hashPaths(Array.from(this.activePaths))
            }
          }, {
            debounce: true
          });
        }
      }
    };

    this.emitPageData = data => {
      data.id = (0, _normalizePagePath.normalizePagePath)(data.id);
      this.pageResults.set(data.id, data);

      if (this.websocket) {
        this.websocket.send({
          type: `pageQueryResult`,
          payload: data
        });

        if (this.connectedClients > 0) {
          _gatsbyTelemetry.default.trackCli(`WEBSOCKET_EMIT_PAGE_DATA_UPDATE`, {
            siteMeasurements: {
              clientsCount: this.connectedClients,
              paths: hashPaths(Array.from(this.activePaths))
            }
          }, {
            debounce: true
          });
        }
      }
    };

    this.emitError = (id, message) => {
      if (message) {
        this.errors.set(id, message);
      } else {
        this.errors.delete(id);
      }

      if (this.websocket) {
        this.websocket.send({
          type: `overlayError`,
          payload: {
            id,
            message
          }
        });
      }
    };
  }

}

exports.WebsocketManager = WebsocketManager;
const websocketManager = new WebsocketManager();
exports.websocketManager = websocketManager;
//# sourceMappingURL=websocket-manager.js.map