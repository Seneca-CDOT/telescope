import { __awaiter, __generator, __read, __values, __assign } from 'tslib';
import { Kind, print, parse, buildASTSchema } from 'graphql';
import { observableToAsyncIterable } from '@graphql-tools/utils/es5';
import { isWebUri } from 'valid-url';
import { fetch } from 'cross-fetch';
import { introspectSchema, introspectSchemaSync, wrapSchema } from '@graphql-tools/wrap/es5';
import { SubscriptionClient } from 'subscriptions-transport-ws';
import { w3cwebsocket } from 'websocket';
import syncFetch from 'sync-fetch';

/**
 * This loader loads a schema from a URL. The loaded schema is a fully-executable,
 * remote schema since it's created using [@graphql-tools/wrap](/docs/remote-schemas).
 *
 * ```
 * const schema = await loadSchema('http://localhost:3000/graphql', {
 *   loaders: [
 *     new UrlLoader(),
 *   ]
 * });
 * ```
 */
var UrlLoader = /** @class */ (function () {
    function UrlLoader() {
    }
    UrlLoader.prototype.loaderId = function () {
        return 'url';
    };
    UrlLoader.prototype.canLoad = function (pointer, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.canLoadSync(pointer, options)];
            });
        });
    };
    UrlLoader.prototype.canLoadSync = function (pointer, _options) {
        return !!isWebUri(pointer);
    };
    UrlLoader.prototype.buildAsyncExecutor = function (_a) {
        var _this = this;
        var pointer = _a.pointer, fetch = _a.fetch, extraHeaders = _a.extraHeaders, defaultMethod = _a.defaultMethod, useGETForQueries = _a.useGETForQueries;
        var HTTP_URL = switchProtocols(pointer, {
            wss: 'https',
            ws: 'http',
        });
        return function (_a) {
            var document = _a.document, variables = _a.variables;
            return __awaiter(_this, void 0, void 0, function () {
                var method, _b, _c, definition, fetchResult, query, _d, urlObj, finalUrl;
                var e_1, _e;
                return __generator(this, function (_f) {
                    switch (_f.label) {
                        case 0:
                            method = defaultMethod;
                            if (useGETForQueries) {
                                method = 'GET';
                                try {
                                    for (_b = __values(document.definitions), _c = _b.next(); !_c.done; _c = _b.next()) {
                                        definition = _c.value;
                                        if (definition.kind === Kind.OPERATION_DEFINITION) {
                                            if (definition.operation !== 'query') {
                                                method = defaultMethod;
                                            }
                                        }
                                    }
                                }
                                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                                finally {
                                    try {
                                        if (_c && !_c.done && (_e = _b.return)) _e.call(_b);
                                    }
                                    finally { if (e_1) throw e_1.error; }
                                }
                            }
                            query = print(document);
                            _d = method;
                            switch (_d) {
                                case 'GET': return [3 /*break*/, 1];
                                case 'POST': return [3 /*break*/, 3];
                            }
                            return [3 /*break*/, 5];
                        case 1:
                            urlObj = new URL(HTTP_URL);
                            urlObj.searchParams.set('query', query);
                            if (variables && Object.keys(variables).length > 0) {
                                urlObj.searchParams.set('variables', JSON.stringify(variables));
                            }
                            finalUrl = urlObj.toString();
                            return [4 /*yield*/, fetch(finalUrl, {
                                    method: 'GET',
                                    headers: extraHeaders,
                                })];
                        case 2:
                            fetchResult = _f.sent();
                            return [3 /*break*/, 5];
                        case 3: return [4 /*yield*/, fetch(HTTP_URL, {
                                method: 'POST',
                                body: JSON.stringify({
                                    query: query,
                                    variables: variables,
                                }),
                                headers: extraHeaders,
                            })];
                        case 4:
                            fetchResult = _f.sent();
                            return [3 /*break*/, 5];
                        case 5: return [2 /*return*/, fetchResult.json()];
                    }
                });
            });
        };
    };
    UrlLoader.prototype.buildSyncExecutor = function (_a) {
        var pointer = _a.pointer, fetch = _a.fetch, extraHeaders = _a.extraHeaders, defaultMethod = _a.defaultMethod, useGETForQueries = _a.useGETForQueries;
        var HTTP_URL = switchProtocols(pointer, {
            wss: 'https',
            ws: 'http',
        });
        return function (_a) {
            var e_2, _b;
            var document = _a.document, variables = _a.variables;
            var method = defaultMethod;
            if (useGETForQueries) {
                method = 'GET';
                try {
                    for (var _c = __values(document.definitions), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var definition = _d.value;
                        if (definition.kind === Kind.OPERATION_DEFINITION) {
                            if (definition.operation !== 'query') {
                                method = defaultMethod;
                            }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            var fetchResult;
            var query = print(document);
            switch (method) {
                case 'GET':
                    var urlObj = new URL(HTTP_URL);
                    urlObj.searchParams.set('query', query);
                    if (variables && Object.keys(variables).length > 0) {
                        urlObj.searchParams.set('variables', JSON.stringify(variables));
                    }
                    var finalUrl = urlObj.toString();
                    fetchResult = fetch(finalUrl, {
                        method: 'GET',
                        headers: extraHeaders,
                    });
                    break;
                case 'POST':
                    fetchResult = fetch(HTTP_URL, {
                        method: 'POST',
                        body: JSON.stringify({
                            query: query,
                            variables: variables,
                        }),
                        headers: extraHeaders,
                    });
                    break;
            }
            return fetchResult.json();
        };
    };
    UrlLoader.prototype.buildSubscriber = function (pointer, webSocketImpl) {
        var _this = this;
        var WS_URL = switchProtocols(pointer, {
            https: 'wss',
            http: 'ws',
        });
        var subscriptionClient = new SubscriptionClient(WS_URL, {}, webSocketImpl);
        return function (_a) {
            var document = _a.document, variables = _a.variables;
            return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_b) {
                    return [2 /*return*/, observableToAsyncIterable(subscriptionClient.request({
                            query: document,
                            variables: variables,
                        }))];
                });
            });
        };
    };
    UrlLoader.prototype.getFetchAsync = function (options, defaultMethod) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, fetch$1, _a, moduleName, fetchFnName_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        headers = {};
                        fetch$1 = fetch;
                        if (!options) return [3 /*break*/, 4];
                        if (Array.isArray(options.headers)) {
                            headers = options.headers.reduce(function (prev, v) { return (__assign(__assign({}, prev), v)); }, {});
                        }
                        else if (typeof options.headers === 'object') {
                            headers = options.headers;
                        }
                        if (!options.customFetch) return [3 /*break*/, 3];
                        if (!(typeof options.customFetch === 'string')) return [3 /*break*/, 2];
                        _a = __read(options.customFetch.split('#'), 2), moduleName = _a[0], fetchFnName_1 = _a[1];
                        return [4 /*yield*/, import(moduleName).then(function (module) { return (fetchFnName_1 ? module[fetchFnName_1] : module); })];
                    case 1:
                        fetch$1 = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        fetch$1 = options.customFetch;
                        _b.label = 3;
                    case 3:
                        if (options.method) {
                            defaultMethod = options.method;
                        }
                        _b.label = 4;
                    case 4: return [2 /*return*/, { headers: headers, defaultMethod: defaultMethod, fetch: fetch$1 }];
                }
            });
        });
    };
    UrlLoader.prototype.getFetchSync = function (options, defaultMethod) {
        var headers = {};
        var fetch = syncFetch;
        if (options) {
            if (Array.isArray(options.headers)) {
                headers = options.headers.reduce(function (prev, v) { return (__assign(__assign({}, prev), v)); }, {});
            }
            else if (typeof options.headers === 'object') {
                headers = options.headers;
            }
            if (options.customFetch) {
                if (typeof options.customFetch === 'string') {
                    var _a = __read(options.customFetch.split('#'), 2), moduleName = _a[0], fetchFnName = _a[1];
                    var module_1 = require(moduleName);
                    fetch = fetchFnName ? module_1[fetchFnName] : module_1;
                }
                else {
                    fetch = options.customFetch;
                }
            }
            if (options.method) {
                defaultMethod = options.method;
            }
        }
        return { headers: headers, defaultMethod: defaultMethod, fetch: fetch };
    };
    UrlLoader.prototype.getWebSocketImplAsync = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var webSocketImpl, _a, moduleName, webSocketImplName_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        webSocketImpl = w3cwebsocket;
                        if (!(typeof options.webSocketImpl === 'string')) return [3 /*break*/, 2];
                        _a = __read(options.webSocketImpl.split('#'), 2), moduleName = _a[0], webSocketImplName_1 = _a[1];
                        return [4 /*yield*/, import(moduleName).then(function (module) { return (webSocketImplName_1 ? module[webSocketImplName_1] : module); })];
                    case 1:
                        webSocketImpl = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        webSocketImpl = options.webSocketImpl;
                        _b.label = 3;
                    case 3: return [2 /*return*/, webSocketImpl];
                }
            });
        });
    };
    UrlLoader.prototype.getWebSocketImplSync = function (options) {
        var webSocketImpl = w3cwebsocket;
        if (typeof options.webSocketImpl === 'string') {
            var _a = __read(options.webSocketImpl.split('#'), 2), moduleName = _a[0], webSocketImplName = _a[1];
            var module_2 = require(moduleName);
            webSocketImpl = webSocketImplName ? module_2[webSocketImplName] : module_2;
        }
        else {
            webSocketImpl = options.webSocketImpl;
        }
        return webSocketImpl;
    };
    UrlLoader.prototype.getExecutorAndSubscriberAsync = function (pointer, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, headers, defaultMethod, fetch, extraHeaders, executor, subscriber, webSocketImpl;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getFetchAsync(options, 'POST')];
                    case 1:
                        _a = _b.sent(), headers = _a.headers, defaultMethod = _a.defaultMethod, fetch = _a.fetch;
                        extraHeaders = __assign({ Accept: 'application/json', 'Content-Type': 'application/json' }, headers);
                        executor = this.buildAsyncExecutor({
                            pointer: pointer,
                            fetch: fetch,
                            extraHeaders: extraHeaders,
                            defaultMethod: defaultMethod,
                            useGETForQueries: options.useGETForQueries,
                        });
                        if (!options.enableSubscriptions) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getWebSocketImplAsync(options)];
                    case 2:
                        webSocketImpl = _b.sent();
                        subscriber = this.buildSubscriber(pointer, webSocketImpl);
                        _b.label = 3;
                    case 3: return [2 /*return*/, {
                            executor: executor,
                            subscriber: subscriber,
                        }];
                }
            });
        });
    };
    UrlLoader.prototype.getExecutorAndSubscriberSync = function (pointer, options) {
        var _a = this.getFetchSync(options, 'POST'), headers = _a.headers, defaultMethod = _a.defaultMethod, fetch = _a.fetch;
        var extraHeaders = __assign({ Accept: 'application/json', 'Content-Type': 'application/json' }, headers);
        var executor = this.buildSyncExecutor({
            pointer: pointer,
            fetch: fetch,
            extraHeaders: extraHeaders,
            defaultMethod: defaultMethod,
            useGETForQueries: options.useGETForQueries,
        });
        var subscriber;
        if (options.enableSubscriptions) {
            var webSocketImpl = this.getWebSocketImplSync(options);
            subscriber = this.buildSubscriber(pointer, webSocketImpl);
        }
        return {
            executor: executor,
            subscriber: subscriber,
        };
    };
    UrlLoader.prototype.getSubschemaConfigAsync = function (pointer, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, executor, subscriber;
            var _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.getExecutorAndSubscriberAsync(pointer, options)];
                    case 1:
                        _a = _c.sent(), executor = _a.executor, subscriber = _a.subscriber;
                        _b = {};
                        return [4 /*yield*/, introspectSchema(executor, undefined, options)];
                    case 2: return [2 /*return*/, (_b.schema = _c.sent(),
                            _b.executor = executor,
                            _b.subscriber = subscriber,
                            _b)];
                }
            });
        });
    };
    UrlLoader.prototype.getSubschemaConfigSync = function (pointer, options) {
        var _a = this.getExecutorAndSubscriberSync(pointer, options), executor = _a.executor, subscriber = _a.subscriber;
        return {
            schema: introspectSchemaSync(executor, undefined, options),
            executor: executor,
            subscriber: subscriber,
        };
    };
    UrlLoader.prototype.handleSDLAsync = function (pointer, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, fetch, defaultMethod, headers, response, schemaString, document, schema;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getFetchAsync(options, 'GET')];
                    case 1:
                        _a = _b.sent(), fetch = _a.fetch, defaultMethod = _a.defaultMethod, headers = _a.headers;
                        return [4 /*yield*/, fetch(pointer, {
                                method: defaultMethod,
                                headers: headers,
                            })];
                    case 2:
                        response = _b.sent();
                        return [4 /*yield*/, response.text()];
                    case 3:
                        schemaString = _b.sent();
                        document = parse(schemaString, options);
                        schema = buildASTSchema(document, options);
                        return [2 /*return*/, {
                                document: document,
                                schema: schema,
                            }];
                }
            });
        });
    };
    UrlLoader.prototype.handleSDLSync = function (pointer, options) {
        var _a = this.getFetchSync(options, 'GET'), fetch = _a.fetch, defaultMethod = _a.defaultMethod, headers = _a.headers;
        var response = fetch(pointer, {
            method: defaultMethod,
            headers: headers,
        });
        var schemaString = response.text();
        var document = parse(schemaString, options);
        var schema = buildASTSchema(document, options);
        return {
            document: document,
            schema: schema,
        };
    };
    UrlLoader.prototype.load = function (pointer, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, document_1, schema, subschemaConfig, remoteExecutableSchema;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!pointer.endsWith('.graphql')) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.handleSDLAsync(pointer, options)];
                    case 1:
                        _a = _b.sent(), document_1 = _a.document, schema = _a.schema;
                        return [2 /*return*/, {
                                location: pointer,
                                document: document_1,
                                schema: schema,
                            }];
                    case 2: return [4 /*yield*/, this.getSubschemaConfigAsync(pointer, options)];
                    case 3:
                        subschemaConfig = _b.sent();
                        remoteExecutableSchema = wrapSchema(subschemaConfig);
                        return [2 /*return*/, {
                                location: pointer,
                                schema: remoteExecutableSchema,
                            }];
                }
            });
        });
    };
    UrlLoader.prototype.loadSync = function (pointer, options) {
        if (pointer.endsWith('.graphql')) {
            var _a = this.handleSDLSync(pointer, options), document_2 = _a.document, schema = _a.schema;
            return {
                location: pointer,
                document: document_2,
                schema: schema,
            };
        }
        var subschemaConfig = this.getSubschemaConfigSync(pointer, options);
        var remoteExecutableSchema = wrapSchema(subschemaConfig);
        return {
            location: pointer,
            schema: remoteExecutableSchema,
        };
    };
    return UrlLoader;
}());
function switchProtocols(pointer, protocolMap) {
    var protocols = Object.keys(protocolMap).map(function (source) { return [source, protocolMap[source]]; });
    return protocols.reduce(function (prev, _a) {
        var _b = __read(_a, 2), source = _b[0], target = _b[1];
        return prev.replace(source + "://", target + "://").replace(source + ":\\", target + ":\\");
    }, pointer);
}

export { UrlLoader };
//# sourceMappingURL=index.esm.js.map
