{"version":3,"file":"graphql-tag.umd.js","sources":["../src/index.js"],"sourcesContent":["var parser = require('graphql/language/parser');\n\nvar parse = parser.parse;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\n// A map docString -> graphql document\nvar docCache = {};\n\n// A map fragmentName -> [normalized source]\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// For testing.\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nvar printFragmentWarnings = true;\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n\n      // We know something about this fragment\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  }\n\n  // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  }\n\n  // https://github.com/apollographql/graphql-tag/issues/40\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  }\n\n  // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nfunction gql(/* arguments */) {\n  var args = Array.prototype.slice.call(arguments);\n\n  var literals = args[0];\n\n  // We always get literals[0] and then matching post literals for each arg given\n  var result = (typeof(literals) === \"string\") ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n}\n\n// Support typescript, which isn't as nice as Babel about default exports\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n\nmodule.exports = gql;\n"],"names":[],"mappings":"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"}